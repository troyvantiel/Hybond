module modpsf
  use chm_kinds
  implicit none

  character(len=*), parameter, private :: SRCFILE = 'modpsf.src'

contains

SUBROUTINE PATCH(COMLYN, COMLEN)
  !-----------------------------------------------------------------------
  !     Process PATCH command.
  !-----------------------------------------------------------------------
  use number
  use dimens_fcm
  use bases_fcm
  use psf
  use genpsf_m
  use rtf,only:autop,autod,autot
  use stream
  use memory
#if KEY_MMFF==1
  use ffieldm           
#endif
  use memory
  use chutil,only:getrsn
  use string
  ! . Passed variables.
  CHARACTER(len=*) COMLYN
  INTEGER   COMLEN
  ! . Local variables.
  !RCZ 91/10/24 MXNPA = maximum number of patch atoms
  integer,allocatable,dimension(:,:) :: IATBON
  integer,allocatable,dimension(:) :: NATBON
  INTEGER,PARAMETER :: MXNPA=100
  !RCZ
  character(len=8) PPRES, PPSEG
  character(len=6) PRES
  INTEGER     IPRES(MXNPA), K
  INTEGER     I 
  LOGICAL     CMPLTD, LSETIC, LSORT, LWARN, LANGLE, LPHI   
  LOGICAL     LDRUDE, LSHOW
  real(chm_real) DMASS
  !
#if KEY_MMFF==1
  LOGICAL     LMMFF
  !
  LMMFF = INDXA(COMLYN, COMLEN, 'MMFF') .GT. 0
#endif 
  !
  LSETIC = INDXA(COMLYN, COMLEN, 'SETU') .GT. 0
  LSORT  = INDXA(COMLYN, COMLEN, 'SORT') .GT. 0
  LWARN  = INDXA(COMLYN, COMLEN, 'WARN') .GT. 0
  !
  ! . Check for auto generation requests.
  LANGLE = AUTOT.AND.AUTOP
  LPHI   = AUTOD.AND.AUTOP
  IF (INDXA(COMLYN, COMLEN, 'ANGL') .GT. 0) LANGLE = .TRUE.
  IF (INDXA(COMLYN, COMLEN, 'NOAN') .GT. 0) LANGLE = .FALSE.
  IF (INDXA(COMLYN, COMLEN, 'DIHE') .GT. 0) LPHI = .TRUE.
  IF (INDXA(COMLYN, COMLEN, 'NODI') .GT. 0) LPHI = .FALSE.

      LDRUDE = (INDXA(COMLYN, COMLEN, 'DRUD') .GT. 0).or.QDRUDE
      LSHOW  = (INDXA(COMLYN, COMLEN, 'SHOW') .GT. 0)
      IF(LDRUDE)THEN
          DMASS  = GTRMF(COMLYN,COMLEN,'DMAS',0.4)
          IF(DMASS.LE.ZERO) DMASS = 0.4
          write(outu,'(1x,2A,f10.4)') &
         'Drude polarizability will be setup ', &
         'mass of Drudes particles =',DMASS
      ENDIF

  ! . Parse the residue list
  PRES = NEXTA6(COMLYN, COMLEN)
  K = 0
  CMPLTD = .TRUE.
  DO WHILE (COMLEN.GT.0 .AND. K.LT.MXNPA)
     PPSEG = NEXTA8(COMLYN, COMLEN)
     PPRES = NEXTA8(COMLYN, COMLEN)
     CALL TRIME(COMLYN, COMLEN)
     K = K + 1
     IPRES(K) = GETRSN(PPSEG, PPRES, ' ', SEGID, RESID, ATYPE, &
          IBASE, NICTOT, NSEG)
     CMPLTD = CMPLTD .AND. (IPRES(K).NE.-1)
  ENDDO
  IF(CMPLTD) THEN
     CALL PATIC(PRES, IPRES, K, LWARN, LSETIC, LSORT)
#if KEY_MMFF==1
     if(FFIELD.eq.MMFF .AND. LMMFF) call mmff_setup
#endif 
     !
     ! . Process autogenerate option (if requested)
     IF(LANGLE) THEN
        NTHETA=0
        NTHETT=0
        IF (PRNLEV.GE.2) WRITE(OUTU,45) 'angles'
     ENDIF
     IF(LPHI) THEN
        NPHI=0
        NPHIT=0
        IF (PRNLEV.GE.2) WRITE(OUTU,45) 'dihedrals'
     ENDIF
45   FORMAT(' AUTOGEN: All ',A,' are removed and regenerated.')
     IF(LANGLE .OR. LPHI) THEN
        call chmalloc(SRCFILE,'PATCH','NATBON',NATOM,intg=NATBON)
        call chmalloc(SRCFILE,'PATCH','IATBON',IATBMX,natom,intg=IATBON)

        CALL AUTGEN(1,NATBON,IATBON,LANGLE,LPHI, &
             LDRUDE)

        call chmdealloc(SRCFILE,'PATCH','NATBON',NATOM,intg=NATBON)
        call chmdealloc(SRCFILE,'PATCH','IATBON',IATBMX,natom,intg=IATBON)

     ENDIF
     !adm..11-Aug-2004
     IF (PRNLEV.GE.2) WRITE(OUTU,46)
46   FORMAT(' PATCH: Check angles and dihedrals autogenerated.')
     !adm..
     ! . Print out the structure file counters.
     CALL PSFSUM(OUTU)
  ELSE
     CALL WRNDIE(-3,'<CHARMM>','Bad residue specified for patching')
  ENDIF
  !

        IF(QDRUDE) THEN

      if(prnlev.ge.5)then
      write(outu,*)
      write(outu,'(1x,a)') &
       'MKDRUDE generate list and setup for drude polarizability'
      write(outu,*)
      endif

!        DO I=1,NATOM
        DO I=2,NATOM  ! I cannot be 1, since ALPHADP(i-1)

        LDRUDE = (atype(i)(1:1).eq.'D').and. &
                 (amass(i).eq.0.0).and. &
                 (abs(ALPHADP(i-1)).ne.0.0)
        IF (LDRUDE.and..not.ISDRUDE(I)) THEN

           CALL MKDRUD(i-2,i,ATYPE,IAC,CG,AMASS,DMASS,THOLEI, &
                ALPHADP,ISDRUDE,nbond,ib,jb,NDRUDE,LSHOW)
           nbdrude=nbond
        ENDIF
        ENDDO
        ENDIF

  RETURN
END SUBROUTINE PATCH

SUBROUTINE PATIC(PRES,IPR,NPR,LWARN,LSETIC,LSORT)
  !-----------------------------------------------------------------------
  !     General patching routine, patching data read from RTF.
  !     Deletions and addition of atoms, bonds, etc,
  !     modify atom specifications and group boundaries.
  !
  !     ORIGINAL VERSION APR-82  BRB
  !     GENERALISED VERSION 23-JAN-83 Axel Brunger
  !
  use dimens_fcm
  use psf
  use rtf,only:nrtrs, rtrtyp, nic
  !
  character(len=6) :: PRES
  INTEGER :: IPR(:), NPR
  LOGICAL   LWARN, LSETIC, LSORT
  !
  INTEGER :: alen, I
  !
  ! The following should give an estimate of needed space
  !
  alen=NATOM
  DO I=1,NRTRS
     IF (RTRTYP(I).EQ.1) THEN
        IF(I.EQ.1) THEN
           alen=alen+NIC(1,1)
        ELSE
           alen=alen+NIC(1,I)-NIC(1,I-1)+1
        ENDIF
     ENDIF
  ENDDO
  alen=MIN(alen,MAXA)

  CALL PATIC2(PRES,IPR,NPR,LWARN,LSETIC,LSORT,alen)
  RETURN
END SUBROUTINE PATIC

SUBROUTINE PATIC2(PRES,IPR,NPR,LWARN,LSETIC,LSORT,alen)
  !-----------------------------------------------------------------------
  !     See PATIC above.
  !
  !     23-JAN-83 Axel Brunger
  !     06-Nov-95 Jay Banks, add BondType and AtNum
  !
  use intcor_module,only: reintc_new,icr_struct
  use intcor2,only:geticel,puticel
  use dimens_fcm
  use exfunc, only: find52, order, order5
  use number
  use consta
  use aniso_fcm
  use lonepr
  use bases_fcm
  use psf
  use genpsf_m
  use rtf,only: nrtrs, aa, rtrtyp, nic, delat, ftp, mxn, mnb, mac, armass, &
    alph, thol, chg, grpr, mib, mjb, delbd, mit, mjt, mkt, &
    delan, mip, mjp, mkp, mlp, delpt, mip, mjp, mim, mjm, mkm, delmt, &
    mlp1ct, mlp2ct, mlp3ct, mlp4ct, mlp0ct, mlpct1d, rlpct, tlpct, plpct, mianis, &
    maxcent_hosts, &
    mjanis, mlm, mkanis, mlanis, a22anis, a11anis, &
    delanis, &
    mh, md, deldn, ma, maa, &
    delac, bari, barj, bark, barl, delic, bart, icb1, icb2, icth1, icth2, &
    icphi
#if KEY_MMFF==1
  use rtf, only: atnumr, mbtype 
#endif
#if KEY_CMAP==1
  use rtf, only: mi1ct, mj1ct, mk1ct, ml1ct, mi2ct, mj2ct, mk2ct, ml2ct 
#endif
#if KEY_CMAP==1
  use rtf, only: delpct 
#endif
  use coord
  use coordc
  use stream
  use mmffm
  use ffieldm
  use chutil,only:getseg,atomid
  use machutil,only:die

  character(len=*)   PRES
  INTEGER :: IPR(:), NPR
  LOGICAL   LWARN, LSETIC, LSORT
  integer :: alen
  !
  EXTERNAL EXCH, EXCH5
  integer, dimension(alen) :: SEGLST, RESLST, GRPLST, ATMLST, MAP, INVMAP
  integer, dimension(alen) :: DATOM1, DATOM2, LIBLO
  integer, dimension(NNB) :: LINB
  INTEGER   INDEX, OFFSET, PATGRP
  INTEGER GROUP,I,II,IPATC,IPT,IDELTA,K,ERRCNT
  INTEGER   J, JJ, KK, LL, NL, NDATOM, PATRES, OLDRES,OLDATM, JK
  INTEGER, DIMENSION(maxcent_hosts) :: IIJ   ! Dimension equal to maximum number of lone pair center hosts.
#if KEY_CMAP==1
  INTEGER II1,JJ1,KK1,LL1,II2,JJ2,KK2,LL2
  INTEGER INX1,INX2
#endif 
  LOGICAL   FOUND, QDELET, ERROR, BYPASS, QNEWRS, LW, TT
  LOGICAL OK1
  INTEGER IX 
  INTEGER IRSZ
  real(chm_real)  RX
  real(chm_real) A33
  !     Temporary mark for deleted atoms, bonds,... in PSF:
  INTEGER,PARAMETER :: MARK = -99999999
  LOGICAL :: LOK
  !
  !     Mark for unknown atom coordinates for added atoms:
  !
  character(len=4)   BLANK
  character(len=8)   SIDDN,RIDDN,RESDN,ATDN,PTYP
  DATA   BLANK/'    '/
  !
  LW = (WRNLEV.GE.2) .AND. (PRNLEV.GE.2)
  FOUND=.FALSE.
  DO J=1,NRTRS
     IF(PRES.EQ.AA(J)) THEN
        IF(RTRTYP(J).NE.1) THEN
           IF(WRNLEV.GE.2 .AND. PRNLEV.GE.2) WRITE(OUTU,1000) PRES
           CALL DIEWRN(-4)
        ELSE
           IPATC=J
           FOUND=.TRUE.
        ENDIF
     ENDIF
  ENDDO
1000 FORMAT(' ERROR in PATIC: Residue ',A6,' has wrong patch type.')
  IF(.NOT.FOUND) THEN
     IF(WRNLEV.GE.2 .AND. PRNLEV.GE.2) WRITE(OUTU,1010) PRES
     CALL DIEWRN(-4)
  ENDIF
1010 FORMAT(' ERROR in PATIC: Residue ',A6,' was not found.')
  !
  ! patch atom sequence.
  !
  ERRCNT=0
  NDATOM=0
  !
  !     Fill segment list SEGLST with values corresonding to current
  !     PSF.
  !
  DO I=1,NSEG
     DO J=NICTOT(I)+1,NICTOT(I+1)
        DO K=IBASE(J)+1,IBASE(J+1)
           SEGLST(K)=I
        ENDDO
     ENDDO
  ENDDO
  !
  ! Fill residue list RESLST with values corresponding to current PSF.
  !
  DO I=1,NRES
     DO J=IBASE(I)+1,IBASE(I+1)
        RESLST(J)=I
     ENDDO
  ENDDO
  !
  ! Fill group list GRPLST with values corresponding to current PSF
  !
  GROUP = 0
  DO I=1,NGRP
     DO J=IGPBS(I)+1,IGPBS(I+1)
        GRPLST(J)=I*(GRPR(NIC(1,IPATC))+1)*10
        ! allow 100 atoms to be inserted between existing atoms
        ATMLST(J)=J*100
     ENDDO
  ENDDO
  !
  ! Read in atoms of patch residue PRES == IPATC
  ! Prepare atom mapping (add atoms, modify GRPLST, make list
  ! of atoms to be deleted)
  !
  PATGRP=-1
  OLDRES=-1
  BYPASS=.TRUE.
  !
  IF(IPATC.GT.1) THEN
     II=NIC(1,IPATC-1)+1
  ELSE
     II=1
  ENDIF
  DO I=II,NIC(1,IPATC)
     QDELET=DELAT(I)
     CALL PATOM(NL,PATRES,PTYP,FTP(I),ATYPE,IBASE,IPR,NPR, &
          1,NRES,.FALSE.)
     QNEWRS=.FALSE.
     IF (PATRES.NE.OLDRES) THEN
        QNEWRS=.TRUE.
        OLDRES=PATRES
        OLDATM=IBASE(PATRES+1)
     ENDIF

     IF(NL.NE.MARK .AND. QDELET) THEN
        !
        ! Atom NL is in residue PATRES and is to be deleted:
        !
        NDATOM = NDATOM + 1
        DATOM1(NDATOM) = NL
        DATOM2(NDATOM) = MARK
        BYPASS=.FALSE.
        !C
        II=0
        IF(I.GT.1) II=MXN(I-1)
        IF(MXN(I).GT.II) THEN
           II=II+1
           CALL PATOM(LL,PATRES,PTYP,MNB(II),ATYPE,IBASE,IPR,NPR, &
                1,NRES,.FALSE.)
           IF(LL.GT.0) THEN
              DATOM2(NDATOM) = LL
           ELSE
              IF(LW) WRITE(OUTU,1015) FTP(I),PRES, &
                   RES(PATRES)(1:idleng),RESID(PATRES)(1:idleng), &
                   MNB(II)
              ERRCNT=ERRCNT+1
           ENDIF
        ENDIF
1015    FORMAT(' <PATIC> Atom ',A6,' in PATCH ',A6, &
             ' is to be deleted in residue ',2A,',',/, &
             ' but the connecting atom ',A6, &
             ' is not present.  No connecting atom will be used.',/, &
             ' The COMBine option only works for atoms already', &
             ' existing atoms in the PSF.')
        !
        OLDATM=NL
        CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
        IF(PRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
             ' ATOM ',SIDDN(1:idleng),RIDDN(1:idleng), &
             RESDN(1:idleng),ATDN(1:idleng), &
             ' AND ALL REFERENCES TO IT DELETED.'
        !
     ELSE IF(NL.EQ.MARK .AND. QDELET) THEN
        IF(LW) THEN
           WRITE(OUTU,1020) FTP(I),PRES, &
                RES(PATRES)(1:idleng),RESID(PATRES)(1:idleng)
1020       FORMAT(' <PATIC> Atom ',A6,' in PATCH ',A6, &
                ' was to be deleted in residue ',2A, &
                ' but is not present.')
        ENDIF
        ERRCNT=ERRCNT+1
     ELSE IF(NL.NE.MARK .AND. .NOT. QDELET) THEN
        !
        ! Atom NL exists in residue PATRES, change atom specifications
        ! according to patch residue.
        !
        IAC(NL)=MAC(I)
        AMASS(NL)=ARMASS(IAC(NL))
        ALPHADP(NL)=ALPH(I)
        THOLEI(NL)=THOL(I)
        ISDRUDE(NL)=.FALSE.
#if KEY_MMFF==1
        if(ffield == mmff) AtNum(NL)=AtNumR(I) 
#endif
        IF(ABS(CHG(I)).GT. NINETY) THEN
           IF(CHG(I).GT.0) THEN
              CG(NL)=CG(NL)-HUNDRD+CHG(I)
           ELSE
              CG(NL)=CG(NL)+HUNDRD+CHG(I)
           ENDIF
        ELSE
           CG(NL)=CHG(I)
        ENDIF
        OLDATM=NL
        !
        ! The following group re-assignment is bypassed if atom I in PRES
        ! has group number 0 (e.g. in old RTF files...)
        !
        IF (GRPR(I).GT.0) THEN
           IF (GRPR(I).NE.PATGRP) THEN
              PATGRP=GRPR(I)
              IF(QNEWRS) THEN
                 GROUP=GRPLST(NL)-GRPR(NIC(1,IPATC))
              ELSE
                 GROUP=GROUP+1
              ENDIF
              !
              ! This should give the correct group boundaries and residue
              ! boundaries.
              !
           ENDIF
           GRPLST(NL)=GROUP
        ENDIF
        !
     ELSE IF(NL.EQ.MARK .AND. .NOT. QDELET) THEN
        !
        ! This atom should be added.
        !
        IF(NATOM+1.GT.MAXA) THEN
           CALL WRNDIE(-4,'<PATIC>', &
                'Max numb. of atoms MAXA exceeded')
        ELSE
           BYPASS=.FALSE.
           NATOM=NATOM+1
           IAC(NATOM)=MAC(I)
           AMASS(NATOM)=ARMASS(IAC(NATOM))
#if KEY_MMFF==1
           if(ffield == mmff) AtNum(NATOM)=AtNumR(I) 
#endif
           CG(NATOM)=CHG(I)
           IF(ABS(CHG(I)).GT. NINETY) &
                CALL WRNDIE(-2,'<MODPSF>','Charge value out of range')
           ATYPE(NATOM)=PTYP
           RSCLF(NATOM)=ONE
#if KEY_WCA==1
           WCA(NATOM)=ONE             
#endif
           IMOVE(NATOM)=0
           RESLST(NATOM)=PATRES
           SEGLST(NATOM)=GETSEG(PATRES,NICTOT,NSEG)
           ALPHADP(NATOM)=ALPH(I)
           THOLEI(NATOM)=THOL(I)
           ISDRUDE(NATOM)=.FALSE.
           ! here no explicit nonbonded exclusions are allowed for this atom
           !
           IBLO(NATOM)=NNB
           !
           !     now, the new atom has to be to assigned to a group number
           !     the case with GRPR(I)=0 is special (e.g. old RTF files...)
           !
           IF(GRPR(I).EQ.0) THEN
              GROUP=GRPLST(OLDATM)
           ELSE
              IF (GRPR(I).NE.PATGRP) THEN
                 PATGRP=GRPR(I)
                 IF(QNEWRS) THEN
                    GROUP=GRPLST(IBASE(PATRES+1))-GRPR(NIC(1,IPATC))
                 ELSE
                    GROUP=GROUP+1
                 ENDIF
              ENDIF
              !
              !     This should give the correct group boundaries and residue
              !     boundaries.
              !
           ENDIF
        ENDIF
        ATMLST(NATOM)=ATMLST(OLDATM)+1
        OLDATM=NATOM
        !
        GRPLST(NATOM)=GROUP
        !
        !     Now reset coordinates, etc. for added atom:
        !
        CALL ATMINI(NATOM,NATOM)
        !
        IF(PRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
             ' ATOM ',SEGID(SEGLST(NATOM))(1:idleng), &
             RES(PATRES)(1:idleng),RESID(PATRES)(1:idleng), &
             PTYP(1:idleng),' ADDED.'
     ENDIF
  ENDDO
  !
  CALL SORT(NDATOM, EXCH5, ORDER5, DATOM1, DATOM2, (/0/), (/0/), (/0/), (/0/), (/0/), (/2/))
  !
  !C
  !      DO (I=1,NATOM)
  !      WRITE(OUTU,444) I,ATMLST(I),GRPLST(I),RESLST(I),TYPE(I)
  ! 444  FORMAT(4I5,2X,A4)
  !      FIN
  !C
  !
  !     Now define a map as well as an inverse map to map the atom
  !     numbers.
  !     First, sort GRPLST, using quicksort (SORT4P conserves the order of
  !     equal elements, this is essential at this point!)
  !
  CALL SORTP(NATOM,INVMAP,ORDER,ATMLST,1,0,0,0,0,0,0)
  DO I=1,NATOM
     MAP(INVMAP(I))=I
  ENDDO
  !
  !     account for deletions, reduce NATOM by NDATOM,
  !     deleted atoms are mapped to MARK
  !
  OFFSET=1
  DO I=1,NATOM
     IF (OFFSET.LE.NDATOM) THEN
        IF (DATOM1(OFFSET) == I) THEN
           MAP(I)=MARK
           OFFSET=OFFSET+1
        ENDIF
     ENDIF
  ENDDO
  NATOM=NATOM-NDATOM
  OFFSET=0
  DO I=1,NATOM
     DO WHILE (MAP(INVMAP(I+OFFSET)).EQ.MARK)
        OFFSET=OFFSET+1
     ENDDO
     INVMAP(I)=INVMAP(I+OFFSET)
  ENDDO
  DO I=1,NATOM
     MAP(INVMAP(I))=I
  ENDDO
  !
  DO I=1,NDATOM
     IF (DATOM2(I) /= MARK) MAP(DATOM1(I)) = MAP(DATOM2(I))
  ENDDO
  !
  !     now begin complete mapping of PSF, INTCR, COORD, COORDC, CNST
  !     note that NATOM is already reduced by the number of deleted atoms.
  !
  CALL MAPIC(MAP,INVMAP,SEGLST,RESLST,GRPLST,LINB,LIBLO, &
       MARK,BYPASS)
  !
  !
  !
  ! add in or delete internal coordinates using final atom sequence
  !
  ! deletion of bonds, angles, dihedrals and improper dihedrals
  ! takes account of the symmetry operations:
  ! bonds:     (a,b)<-->(b,a)
  ! angles:    (a,b,c)<-->(c,b,a)
  ! dihedrals: (a,b,c,d)<-->(d,c,b,a)
  ! impropers: (a,b,c,d)<-->(d,c,b,a)
  ! donors, acceptors and IC's have to be specified the same way as
  ! in the PSF resp. RTF.
  !
  !
  ! put in bonds
  !
  IF(IPATC.GT.1) THEN
     I=NIC(2,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(2,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIB(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJB(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND..NOT.DELBD(IPT)) THEN
            FOUND = .false.
            DO KK=1,NBOND
              IF(((II.EQ.IB(KK)).AND.(JJ.EQ.JB(KK))) &
                 .OR. &
              ((II.EQ.JB(KK)).AND.(JJ.EQ.IB(KK))))THEN
                 FOUND = .true.
              ENDIF
            ENDDO
            IF (.not. FOUND) THEN
              NBOND=NBOND+1
              IB(NBOND)=II
              JB(NBOND)=JJ
            ENDIF
#if KEY_MMFF==1
            if(ffield == mmff) BondType(NBOND)=MBTYPE(IPT) 
#endif
     ELSE IF(II.GT.0.AND.JJ.GT.0.AND.DELBD(IPT)) THEN
        INDEX=FIND52(IB,JB,0,0,0,II,JJ,0,0,0,NBOND,2,MARK)
        IF(INDEX.EQ.MARK) INDEX=FIND52(IB,JB,0,0,0,JJ,II,0,0,0, &
             NBOND,2,MARK)
        IF(INDEX.NE.MARK) THEN
           IB(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF(ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1080) AA(IPATC),MIB(IPT),MJB(IPT)
1080    FORMAT(' ** WARNING ** BOND NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',2(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
  !
  ! put in angles
  !
  IF(IPATC.GT.1) THEN
     I=NIC(3,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(3,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIT(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJT(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(KK,PATRES,PTYP,MKT(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND..NOT.DELAN(IPT)) THEN
        NTHETA=NTHETA+1
        IT(NTHETA)=II
        JT(NTHETA)=JJ
        KT(NTHETA)=KK
     ELSE IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.DELAN(IPT)) THEN
        INDEX=FIND52(IT,JT,KT,0,0,II,JJ,KK,0,0,NTHETA,3,MARK)
        IF(INDEX.EQ.MARK) INDEX=FIND52(IT,JT,KT,0,0,KK,JJ,II,0,0, &
             NTHETA,3,MARK)
        IF(INDEX.NE.MARK) THEN
           IT(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF(ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1090) AA(IPATC),MIT(IPT),MJT(IPT),MKT(IPT)
1090    FORMAT(' ** WARNING ** ANGLE NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',3(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
  !
  ! put in dihedrals
  !
  IF(IPATC.GT.1) THEN
     I=NIC(4,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(4,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(KK,PATRES,PTYP,MKP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(LL,PATRES,PTYP,MLP(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.AND. &
          .NOT.DELPT(IPT)) THEN
        NPHI=NPHI+1
        IP(NPHI)=II
        JP(NPHI)=JJ
        KP(NPHI)=KK
        LP(NPHI)=LL
     ELSE IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.AND. &
          DELPT(IPT)) THEN
        INDEX=FIND52(IP,JP,KP,LP,0,II,JJ,KK,LL,0,NPHI,4,MARK)
        IF (INDEX.EQ.MARK) &
             INDEX=FIND52(IP,JP,KP,LP,0,LL,KK,JJ,II,0,NPHI,4,MARK)
        IF(INDEX.NE.MARK) THEN
           IP(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF(ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) THEN
           WRITE(OUTU,1100) AA(IPATC),MIP(IPT),MJP(IPT),MKP(IPT), &
                MLP(IPT)
1100       FORMAT(' ** WARNING ** DIHEDRAL NOT FOUND FOR PATCH ',A6, &
                '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')
        ENDIF
     ENDIF
  ENDDO
  !
  ! put in improper dihedrals
  !
  IF(IPATC.GT.1) THEN
     I=NIC(5,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(5,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MIM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MJM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(KK,PATRES,PTYP,MKM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(LL,PATRES,PTYP,MLM(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.AND. &
          .NOT.DELMT(IPT)) THEN
        NIMPHI=NIMPHI+1
        IM(NIMPHI)=II
        JM(NIMPHI)=JJ
        KM(NIMPHI)=KK
        LM(NIMPHI)=LL
     ELSE IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.AND. &
          DELMT(IPT)) THEN
        INDEX=FIND52(IM,JM,KM,LM,0,II,JJ,KK,LL,0,NIMPHI,4,MARK)
        IF (INDEX.EQ.MARK) &
             INDEX=FIND52(IM,JM,KM,LM,0,LL,KK,JJ,II,0,NIMPHI,4,MARK)
        IF(INDEX.NE.MARK) THEN
           IM(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF (ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1120) AA(IPATC),MIM(IPT),MJM(IPT), &
             MKM(IPT),MLM(IPT)
1120    FORMAT(' ** WARNING ** IMPROPER NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO

#if KEY_LONEPAIR==1
      IF(IPATC.GT.1) THEN
         I=NIC(12,IPATC-1)+1
      ELSE
         I=1
      ENDIF
      DO IPT=I,NIC(12,IPATC)
         CALL PATOM(II,PATRES,PTYP,MLP1CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(JJ,PATRES,PTYP,MLP2CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(KK,PATRES,PTYP,MLP3CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(LL,PATRES,PTYP,MLP4CT(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         
         LOK=.FALSE.
         J=1
         DO WHILE (MLPCT1D((IPT-1)*MAXCENT_HOSTS+J)/=BLANK)
            CALL PATOM(IIJ(J),PATRES,PTYP,MLPCT1D((IPT-1)*MAXCENT_HOSTS+J),ATYPE,IBASE,IPR,NPR,1,NRES,LW)
            LOK=(IIJ(J).GT.0)
            J=J+1
         END DO

         IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0.OR.LOK) THEN
           if(.not.allocated(lpnhost)) call allocate_lonepair
           IF (MLP0CT(IPT).eq.'CENT') THEN                    
              NUMLP = NUMLP + 1                                    
              LPHPTR(NUMLP) = NUMLPH + 1                           
              NUMLPH = NUMLPH + J - 1                              
              LPNHOST(NUMLP)   = J - 2                             
              DO JK = 1, J-1                                  
                 LPHOST(LPHPTR(NUMLP)+(JK-1))   = IIJ(JK)          
              END DO                                               
              LPWGHT(NUMLP) = .FALSE.                              
              LPVALUE(1,NUMLP) = RLPCT(IPT)                        
              LPVALUE(2,NUMLP) = TLPCT(IPT)                        
              LPVALUE(3,NUMLP) = PLPCT(IPT)                        
              JK=IIJ(1)                                            
              IMOVE(JK) = -1                                       
           ELSEIF((MLP0CT(IPT).eq.'RELA').or.(MLP0CT(IPT).eq.'BISE'))THEN
              NUMLP = NUMLP + 1
              LPHPTR(NUMLP) = NUMLPH + 1
              NUMLPH = NUMLPH + 4
              LPNHOST(NUMLP)   = 3
              LPHOST(LPHPTR(NUMLP))   = II
              LPHOST(LPHPTR(NUMLP)+1) = JJ
              LPHOST(LPHPTR(NUMLP)+2) = KK
              LPHOST(LPHPTR(NUMLP)+3) = LL
              LPWGHT(NUMLP) = .FALSE.
              LPVALUE(1,NUMLP) = RLPCT(IPT)
              IF(MLP0CT(IPT).eq.'BISECT') THEN
                  LPVALUE(1,NUMLP) = -RLPCT(IPT)
              ENDIF ! RELATI and BISECT differ only in RLPCT
              LPVALUE(2,NUMLP) = TLPCT(IPT)
              LPVALUE(3,NUMLP) = PLPCT(IPT)
              IMOVE(II) = -1
           ELSEIF((MLP0CT(IPT).eq.'COLI')) THEN
              NUMLP = NUMLP + 1
              LPHPTR(NUMLP) = NUMLPH + 1
              NUMLPH = NUMLPH + 3
              LPNHOST(NUMLP)   = 2
              LPHOST(LPHPTR(NUMLP))   = II
              LPHOST(LPHPTR(NUMLP)+1) = JJ
              LPHOST(LPHPTR(NUMLP)+2) = KK
              LPWGHT(NUMLP) = .FALSE.
              LPVALUE(1,NUMLP) = RLPCT(IPT)
              LPVALUE(2,NUMLP) = TLPCT(IPT)      
              IMOVE(II) = -1 
           ELSE
            CALL WRNDIE(-4,'<PATIC2>','Unknown lone pair type')
           ENDIF
         ELSE
            CALL WRNDIE(-4,'<PATIC2>','lone pair not found')
         ENDIF
      ENDDO
      J=0   ! Reinitialize
      IF(IPATC.GT.1) THEN
         I=NIC(13,IPATC-1)+1
      ELSE
         I=1
      ENDIF
      DO IPT=I,NIC(13,IPATC)
         CALL PATOM(II,PATRES,PTYP,MIANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(JJ,PATRES,PTYP,MJANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(KK,PATRES,PTYP,MKANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)
         CALL PATOM(LL,PATRES,PTYP,MLANIS(IPT),ATYPE,IBASE,IPR,NPR,1, &
                    NRES,LW)

         IF(II.GT.0.AND.JJ.GT.0.AND.KK.GT.0.AND.LL.GT.0) THEN
          IF(.NOT.DELANIS(IPT)) THEN
           IF( (A11ANIS(IPT).ne.ZERO).and. &
               (A22ANIS(IPT).ne.ZERO) ) THEN
              NANISO = NANISO + 1
              LSTANI1(NANISO) = II
              LSTANI2(NANISO) = JJ
              LSTANI3(NANISO) = KK
              LSTANI4(NANISO) = LL
              A33 = THREE-A11ANIS(IPT)-A22ANIS(IPT)
              IF(A33.le.ZERO) CALL WRNDIE &
              (5,'<PATIC2>','ANISO: A33 negative ')

              K11(NANISO) = ONE/A11ANIS(IPT)
              K22(NANISO) = ONE/A22ANIS(IPT)
              K33(NANISO) = ONE/A33

              if(PRNLEV.GE.8)then
                write(*,'(1x,a,5i6,3f10.3)') &
               'Add anisotropy for one atom: ', &
                naniso,ii,jj,kk,ll, &
                K11(NANISO),K22(NANISO),K33(NANISO)
              endif
           ELSE
            CALL WRNDIE(-4,'<PATIC2>','Zero aniso force constant')
           ENDIF
          ELSE ! delete anisotropy, HJ 
            DO J=1,NANISO
             IF((LSTANI1(J).eq.II).and.(LSTANI2(J).eq.JJ).and.(LSTANI3(J).eq.KK).and.(LSTANI4(J).eq.LL)) THEN
                 if(PRNLEV.GE.8)then
                  write(*,'(1x,a,5i6,3f10.3)') &
                 'delete anisotropy for one atom: ', &
                  J,ii,jj,kk,ll, &
                  K11(J),K22(J),K33(J)
                endif
               DO K=J+1,NANISO
                  LSTANI1(K-1) = LSTANI1(K)
                  LSTANI2(K-1) = LSTANI2(K)
                  LSTANI3(K-1) = LSTANI3(K)
                  LSTANI4(K-1) = LSTANI4(K)
                  K11(K-1) = K11(K)
                  K22(K-1) = K22(K)
                  K33(K-1) = K33(K)
                ENDDO
                NANISO = NANISO - 1   
              ENDIF
            ENDDO
          ENDIF
         ENDIF
      ENDDO
#endif 
#if KEY_CMAP==1
  !
  ! put in cross-term maps
  !
  IF(IPATC.GT.1) THEN
     I=NIC(11,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(11,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II1,PATRES,PTYP,MI1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(JJ1,PATRES,PTYP,MJ1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(KK1,PATRES,PTYP,MK1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(LL1,PATRES,PTYP,ML1CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(II2,PATRES,PTYP,MI2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(JJ2,PATRES,PTYP,MJ2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(KK2,PATRES,PTYP,MK2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)
     CALL PATOM(LL2,PATRES,PTYP,ML2CT(IPT),ATYPE,IBASE,IPR, &
          NPR,1,NRES,LW)

     IF(  II1.GT.0.AND.JJ1.GT.0.AND.KK1.GT.0.AND.LL1.GT.0 &
          .AND.II2.GT.0.AND.JJ2.GT.0.AND.KK2.GT.0.AND.LL2.GT.0) THEN
        IF (.NOT.DELPCT(IPT)) THEN
           NCRTERM=NCRTERM+1
           I1CT(NCRTERM)=II1
           J1CT(NCRTERM)=JJ1
           K1CT(NCRTERM)=KK1
           L1CT(NCRTERM)=LL1
           I2CT(NCRTERM)=II2
           J2CT(NCRTERM)=JJ2
           K2CT(NCRTERM)=KK2
           L2CT(NCRTERM)=LL2
        ELSE
           INX1=FIND52(I1CT,J1CT,K1CT,L1CT,0, &
                II1,JJ1,KK1,LL1,0,NCRTERM,4,MARK)
           IF (INX1.EQ.MARK) &
                INX1=FIND52(I1CT,J1CT,K1CT,L1CT,0, &
                LL1,KK1,JJ1,II1,0,NCRTERM,4,MARK)

           INX2=FIND52(I2CT,J2CT,K2CT,L2CT,0, &
                II2,JJ2,KK2,LL2,0,NCRTERM,4,MARK)
           IF (INX2.EQ.MARK) &
                INX2=FIND52(I2CT,J2CT,K2CT,L2CT,0, &
                LL2,KK2,JJ2,II2,0,NCRTERM,4,MARK)

           IF(INX1.NE.MARK) THEN
              I1CT(INDEX)=MARK
              IF (INX2.NE.MARK) THEN
                 I2CT(INDEX)=MARK
              ELSE
                 ERROR=.TRUE.
              ENDIF
           ELSE
              ERROR=.TRUE.
           ENDIF
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF

     IF (ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1121) AA(IPATC),MI1CT(IPT),MJ1CT(IPT), &
             MK1CT(IPT),ML1CT(IPT), &
             MI2CT(IPT),MJ2CT(IPT), &
             MK2CT(IPT),ML2CT(IPT)
1121    FORMAT(' ** WARNING ** CROSSTERM NOT FOUND FOR PATCH ', &
             A6, &
             '.'/,' ATOMS',4(1X,'"',A6,'"'), &
             /,' ATOMS',4(1X,'"',A6,'"'), &
             ' WERE REQUESTED.')
     ENDIF
  ENDDO
#endif 

  !
  ! put in donors
  !
  IF(IPATC.GT.1) THEN
     I=NIC(7,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(7,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MH(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MD(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(II.EQ.MARK) II=0
     IF(JJ.GT.0.AND.(II.GT.0.OR.MH(IPT).EQ.BLANK).AND. &
          .NOT.DELDN(IPT)) THEN
        NDON=NDON+1
        IHD1(NDON)=II
        IDON(NDON)=JJ
     ELSE IF(JJ.GT.0.AND.(II.GT.0.OR.MH(IPT).EQ.BLANK).AND. &
          DELDN(IPT)) THEN
        INDEX=FIND52(IDON,IHD1,0,0,0,JJ,II,0,0,0,NDON,2,MARK)
        IF(INDEX.NE.MARK) THEN
           IDON(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF (ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1130) AA(IPATC),MH(IPT),MD(IPT)
1130    FORMAT(' ** WARNING ** DONOR NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',2(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
  !
  !     put in acceptors
  !
  IF(IPATC.GT.1) THEN
     I=NIC(8,IPATC-1)+1
  ELSE
     I=1
  ENDIF
  DO IPT=I,NIC(8,IPATC)
     ERROR=.FALSE.
     CALL PATOM(II,PATRES,PTYP,MA(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     CALL PATOM(JJ,PATRES,PTYP,MAA(IPT),ATYPE,IBASE,IPR,NPR,1, &
          NRES,LW)
     IF(JJ.EQ.MARK) JJ=0
     IF(II.GT.0.AND..NOT.DELAC(IPT)) THEN
        NACC=NACC+1
        IACC(NACC)=II
        IAC1(NACC)=JJ
     ELSE IF(II.GT.0.AND.DELAC(IPT)) THEN
        INDEX=FIND52(IACC,IAC1,0,0,0,II,JJ,0,0,0,NACC,2,MARK)
        IF(INDEX.NE.MARK) THEN
           IACC(INDEX)=MARK
        ELSE
           ERROR=.TRUE.
        ENDIF
     ELSE
        ERROR=.TRUE.
     ENDIF
     IF(ERROR) THEN
        ERRCNT=ERRCNT+1
        IF(LW) WRITE(OUTU,1140) AA(IPATC),MA(IPT),MAA(IPT)
1140    FORMAT(' ** WARNING ** ACCEPTOR NOT FOUND FOR PATCH ',A6, &
             '.'/,' ATOMS',2(1X,'"',A6,'"'),' WERE REQUESTED.')
     ENDIF
  ENDDO
  !
  ! put in build/ic elements
  !
  IF(LSETIC) THEN
     IF(IPATC.GT.1) THEN
        I=NIC(9,IPATC-1)+1
     ELSE
        I=1
     ENDIF
     DO IPT=I,NIC(9,IPATC)
        ERROR=.FALSE.
        CALL PATOM(II,PATRES,PTYP,BARI(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        CALL PATOM(JJ,PATRES,PTYP,BARJ(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        CALL PATOM(KK,PATRES,PTYP,BARK(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        CALL PATOM(LL,PATRES,PTYP,BARL(IPT),ATYPE,IBASE,IPR,NPR,1, &
             NRES,LW)
        IF(II.GT.0.OR.JJ.GT.0.OR.KK.GT.0.OR.LL.GT.0) THEN
           ! passing unallocated arrays in for arrays not marked allocated
           ! is not standard fortran
           if (.not. allocated(icr_struct%iar)) then
              index = mark
           else
              INDEX=FIND52(icr_struct%IAR,icr_struct%JAR,  &
                 icr_struct%KAR,icr_struct%LAR, &
                 0,II,JJ,KK,LL,0,&
                 icr_struct%lenic,4,MARK)
           end if
           IF(.NOT.DELIC(IPT)) THEN
              !
              ! first check if that IC table entry already exists
              !
              IF(INDEX.NE.MARK) THEN
                 CALL GETICEL(II,JJ,KK,LL,TT,RX,RX,RX,RX,RX,INDEX, &
                      icr_struct%B1ic,icr_struct%B2ic, &
                      icr_struct%T1ic,icr_struct%T2ic, &
                      icr_struct%PIC, icr_struct%IAR, &
                      icr_struct%JAR, icr_struct%KAR, &
                      icr_struct%LAR, icr_struct%TAR)
                 IF(BART(IPT).NEQV.TT) INDEX=MARK
              ENDIF
              IF(INDEX.EQ.MARK) THEN
                 IF(icr_struct%intlen.LE.icr_struct%lenic) THEN  ! get more space...
                    IRSZ=icr_struct%lenic+200

                    CALL REINTC_NEW(IRSZ,icr_struct)
                 ENDIF
                 icr_struct%lenic=icr_struct%lenic+1
                 INDEX=icr_struct%lenic
              ENDIF
           ELSE
              IF(INDEX.NE.MARK) THEN
                 II=MARK
                 JJ=MARK
                 KK=MARK
                 LL=MARK
              ELSE
                 ERROR=.TRUE.
              ENDIF
           ENDIF
        ELSE
           ERROR=.TRUE.
        ENDIF
        IF(ERROR) THEN
           ERRCNT=ERRCNT+1
           IF(LW) WRITE(OUTU,1150)AA(IPATC),BARI(IPT), &
                BARJ(IPT),BARK(IPT),BARL(IPT)
1150       FORMAT(' ** WARNING ** IC NOT FOUND FOR PATCH ',A6, &
                '.'/,' ATOMS',4(1X,'"',A6,'"'),' WERE REQUESTED.')
        ELSE
           CALL PUTICEL(II,JJ,KK,LL,BART(IPT),ICB1(IPT),ICB2(IPT), &
                ICTH1(IPT),ICTH2(IPT),ICPHI(IPT),INDEX, &
                icr_struct%B1ic,icr_struct%B2ic, &
                icr_struct%T1ic,icr_struct%T2ic, &
                icr_struct%PIC, icr_struct%IAR, &
                icr_struct%JAR, icr_struct%KAR, &
                icr_struct%LAR, icr_struct%TAR)
        ENDIF
     ENDDO
  ENDIF
  !
  !     remove all internal coordinates containing MARK
  !
  CALL CMPRIC(MARK,LSORT)
  !
  !     add in explicit nonbonded exclusions if present.
  !
  IF(IPATC.GT.1) THEN
     II=NIC(1,IPATC-1)+1
  ELSE
     II=1
  ENDIF
  DO J=II,NIC(1,IPATC)
     QDELET=DELAT(J)
     !
     IF(J.GT.1) THEN
        LL=MXN(J-1)
     ELSE
        LL=0
     ENDIF
     IF(LL.LT.MXN(J) .AND. .NOT.QDELET) THEN
        CALL PATOM(JJ,PATRES,PTYP,FTP(J),ATYPE,IBASE,IPR,NPR, &
             1,NRES,.FALSE.)
        IF(JJ.EQ.MARK) CALL DIE
        !        remove all previous exclusions for this atom
        IF(JJ.GT.1) THEN
           IDELTA=(IBLO(JJ)-IBLO(JJ-1))
        ELSE
           IDELTA=IBLO(JJ)
        ENDIF
        IF(IDELTA.GT.0) THEN
           NNB=NNB-IDELTA
           DO IPT=JJ,NATOM
              IBLO(IPT)=IBLO(IPT)-IDELTA
           ENDDO
           DO IPT=IBLO(JJ)+1,NNB
              INB(IPT)=INB(IPT+IDELTA)
           ENDDO
        ENDIF
        !
        ! add in new pairs
        DO K=LL+1,MXN(J)
           CALL PATOM(KK,PATRES,PTYP,MNB(K),ATYPE,IBASE,IPR,NPR,1, &
                NRES,LW)
           IF(KK.EQ.MARK) THEN
              ERRCNT=ERRCNT+1
              IF(LW) WRITE(OUTU,1160) AA(IPATC),MNB(K)
1160          FORMAT(' ** WARNING ** EXCLUSION NOT FOUND FOR PATCH ' &
                   ,A6,'.'/,' ATOM',1X,'"',A6,'" WAS REQUESTED.')
           ELSE IF(NNB.GE.MAXNB) THEN
              CALL WRNDIE(-2,'<PATIC2>', &
                   'Maximum number of exclusions exceeded')
           ELSE
              NNB=NNB+1
              DO IPT=JJ,NATOM
                 IBLO(IPT)=IBLO(IPT)+1
              ENDDO
              DO IPT=NNB,IBLO(JJ)+1,-1
                 INB(IPT)=INB(IPT-1)
              ENDDO
              INB(IBLO(JJ))=KK
           ENDIF
        ENDDO
     ENDIF
  ENDDO
  !
  IF(ERRCNT.GT.0) THEN
     IF(LW) WRITE(OUTU,432) ERRCNT
432  FORMAT(' There were a total of',I5, &
          ' errors found for this patch')
     IF(LWARN) THEN
        CALL DIEWRN(1)
     ELSE
        CALL DIEWRN(-3)
     ENDIF
  ENDIF
  !
  RETURN
  !
END SUBROUTINE PATIC2

SUBROUTINE DELTIC(COMLYN,COMLEN)
  !-----------------------------------------------------------------------
  !     Process DELETION command.
  !
  use psf
  use stream

  character(len=*) COMLYN
  INTEGER COMLEN

  IF (NATOM <= 0) RETURN

  CALL DELTI2(COMLYN, COMLEN)

  ! . Print out the structure file counters.
  CALL PSFSUM(OUTU)
  !
  RETURN
END SUBROUTINE DELTIC

SUBROUTINE DELTI2(COMLYN, COMLEN)
  !-----------------------------------------------------------------------
  !     Routine deletes atoms and all references to atoms
  !     in PSF, CNST, COORD, COORDC and INTCR.
  !
  !     Syntax:
  !
  !     DELEte [SORT] <atom-selection-syntax>
  !
  !     If SORT is referenced the bond, angle,... lists are sorted after
  !     compression.
  !
  !     23-JAN-83 AB
  !
  use dimens_fcm
  use psf
  use genpsf_m
  use aniso_fcm 
  use coord
  use stream
  use ffieldm
  use memory
  use select
  use string
#if KEY_MMFF==1
  use mmffm  
#endif

  character(len=*) COMLYN
  INTEGER   COMLEN

  integer, dimension(NNB) :: LINB
  integer, dimension(NATOM) :: LIBLO, ISLCT, JSLCT
  integer, dimension(NATOM) :: MAP, INVMAP, SEGLST, RESLST, GRPLST
  character(len=4) WRD
  !
  LOGICAL LSORT,LATOM,LBOND,LANGL,LDIHE,LIMPR,LFIRST,LSECON,OK,ERR
#if KEY_CMAP==1
  LOGICAL LCMAP
#endif 
  INTEGER   I, J, II, OFFSET, K
  !
  !     Temporary mark for deleted atoms:
  INTEGER,PARAMETER :: MARK = -99999999
  !
  !
  LSORT=(INDXA(COMLYN,COMLEN,'SORT').GT.0)
  WRD=NEXTA4(COMLYN,COMLEN)
  LATOM=.FALSE.
  LBOND=.FALSE.
  LANGL=.FALSE.
  LDIHE=.FALSE.
  LIMPR=.FALSE.
#if KEY_CMAP==1
  LCMAP=.FALSE.
#endif 
  IF(WRD.EQ.'ATOM') THEN
     LATOM=.TRUE.
  ELSE IF(WRD.EQ.'BOND') THEN
     LBOND=.TRUE.
  ELSE IF(WRD.EQ.'ANGL') THEN
     LANGL=.TRUE.
  ELSE IF(WRD.EQ.'DIHE') THEN
     LDIHE=.TRUE.
  ELSE IF(WRD.EQ.'IMPR') THEN
     LIMPR=.TRUE.
#if KEY_CMAP==1
  ELSE IF(WRD.EQ.'CMAP') THEN
     LCMAP=.TRUE.
#endif 
  ELSE IF(WRD.EQ.'CONN') THEN
     LBOND=.TRUE.
     LANGL=.TRUE.
     LDIHE=.TRUE.
     LIMPR=.TRUE.
#if KEY_CMAP==1
     LCMAP=.TRUE.
#endif 
  ELSE
     CALL WRNDIE(0,'<DELTIC>', &
          'Unrecognized DELEte option. Nothing done.')
     RETURN
  ENDIF
  !
  !
  IF(LATOM) THEN
     CALL SELCTA(COMLYN,COMLEN,ISLCT,X,Y,Z,WMAIN,.TRUE.)
     !
     ! construct MAP and INVMAP
     !
     II=NATOM
     DO I=1,NATOM
        IF (ISLCT(I).EQ.1) THEN
           II=II-1
           MAP(I)=MARK
#if KEY_MMFF==1
           IF(FFIELD.EQ.MMFF) THEN
              MTYPE(I)=0    ! this is necessary for MMFF
              CALL ATMINI(I,I)
           ENDIF
#endif 
        ENDIF
     ENDDO
     IF (NATOM.EQ.II) THEN
        CALL WRNDIE(0,'<DELTIC>', &
             'No atoms selected for deletion. Nothing done.')
        RETURN
     ENDIF
     !
     NATOM=II
     !
     OFFSET=0
     DO I=1,NATOM
        DO WHILE (ISLCT(I+OFFSET).EQ.1)
           OFFSET=OFFSET+1
        ENDDO
        INVMAP(I)=I+OFFSET
     ENDDO
     DO I=1,NATOM
        MAP(INVMAP(I))=I
     ENDDO
     !
     !     fill temporary segment list
     !
     DO I=1,NSEG
        DO J=NICTOT(I)+1,NICTOT(I+1)
           DO K=IBASE(J)+1,IBASE(J+1)
              SEGLST(K)=I
           ENDDO
        ENDDO
     ENDDO
     !
     !     fill temporary residue list
     !
     DO I=1,NRES
        DO J=IBASE(I)+1,IBASE(I+1)
           RESLST(J)=I
        ENDDO
     ENDDO
     !
     !     fill temporary group list
     !
     DO I=1,NGRP
        DO J=IGPBS(I)+1,IGPBS(I+1)
           GRPLST(J)=I
        ENDDO
     ENDDO
     !
     !     now do mapping and compression of PSF,...
     !
     CALL MAPIC(MAP,INVMAP,SEGLST,RESLST,GRPLST,LINB, &
          LIBLO,MARK,.FALSE.)

     if(qdrude)then
        if(natom.eq.0)then
           ndrude = 0
        else
           ndrude = 0
           do i = 1,natom
              if(isdrude(i)) ndrude=ndrude+1
           enddo
        endif
     endif
  ELSE
     CALL SELCTD(COMLYN,COMLEN,ISLCT,JSLCT,X,Y,Z,WMAIN,.TRUE.,ERR)
     IF(ERR) RETURN
  ENDIF
  !
  IF(LBOND) THEN
     DO I=1,NBOND
        OK=(IB(I).GT.0 .AND. JB(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(IB(I)).EQ.1 .AND. JSLCT(JB(I)).EQ.1)
           LSECON=(JSLCT(IB(I)).EQ.1 .AND. ISLCT(JB(I)).EQ.1)
        ENDIF
        IF(.NOT.OK) THEN
           IB(I)=MARK
        ELSE IF(LFIRST.OR.LSECON) THEN
           IB(I)=MARK
        ENDIF
     ENDDO
  ENDIF
  !
  IF(LANGL) THEN
     DO I=1,NTHETA
        OK=(IT(I).GT.0 .AND. JT(I).GT.0 .AND. KT(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(IT(I)).EQ.1 .OR. ISLCT(JT(I)).EQ.1 .OR. &
                ISLCT(KT(I)).EQ.1)
           LSECON=(JSLCT(IT(I)).EQ.1 .OR. JSLCT(JT(I)).EQ.1 .OR. &
                JSLCT(KT(I)).EQ.1)
        ENDIF
        IF(.NOT.OK) THEN
           IT(I)=MARK
        ELSE IF(LFIRST.AND.LSECON) THEN
           IT(I)=MARK
        ENDIF
     ENDDO
  ENDIF
  !
  IF(LDIHE) THEN
     DO I=1,NPHI
        OK=(IP(I).GT.0 .AND. JP(I).GT.0 .AND. KP(I).GT.0 .AND. &
             LP(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(IP(I)).EQ.1 .OR. ISLCT(JP(I)).EQ.1 .OR. &
                ISLCT(KP(I)).EQ.1 .OR. ISLCT(LP(I)).EQ.1)
           LSECON=(JSLCT(IP(I)).EQ.1 .OR. JSLCT(JP(I)).EQ.1 .OR. &
                JSLCT(KP(I)).EQ.1 .OR. JSLCT(LP(I)).EQ.1)
        ENDIF
        IF(.NOT.OK) THEN
           IP(I)=MARK
        ELSE IF(LFIRST.AND.LSECON) THEN
           IP(I)=MARK
        ENDIF
     ENDDO
  ENDIF
  !
  IF(LIMPR) THEN
     DO I=1,NIMPHI
        OK=(IM(I).GT.0 .AND. JM(I).GT.0 .AND. KM(I).GT.0 .AND. &
             LM(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(IM(I)).EQ.1 .OR. ISLCT(JM(I)).EQ.1 .OR. &
                ISLCT(KM(I)).EQ.1 .OR. ISLCT(LM(I)).EQ.1)
           LSECON=(JSLCT(IM(I)).EQ.1 .OR. JSLCT(JM(I)).EQ.1 .OR. &
                JSLCT(KM(I)).EQ.1 .OR. JSLCT(LM(I)).EQ.1)
        ENDIF
        IF(.NOT.OK) THEN
           IM(I)=MARK
        ELSE IF(LFIRST.AND.LSECON) THEN
           IM(I)=MARK
        ENDIF
     ENDDO
  ENDIF

#if KEY_CMAP==1
  IF(LCMAP) THEN
     DO I=1,NCRTERM
        OK=(I1CT(I).GT.0 .AND. J1CT(I).GT.0 .AND. &
             K1CT(I).GT.0 .AND. L1CT(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(I1CT(I)).EQ.1 .OR. &
                ISLCT(J1CT(I)).EQ.1 .OR. &
                ISLCT(K1CT(I)).EQ.1 .OR. &
                ISLCT(L1CT(I)).EQ.1)
           LSECON=(JSLCT(I1CT(I)).EQ.1 .OR. &
                JSLCT(J1CT(I)).EQ.1 .OR. &
                JSLCT(K1CT(I)).EQ.1 .OR. &
                JSLCT(L1CT(I)).EQ.1)
        ENDIF
        IF(.NOT.OK) THEN
           I1CT(I)=MARK
        ELSE IF(LFIRST.AND.LSECON) THEN
           I1CT(I)=MARK
        ENDIF

        OK=(I2CT(I).GT.0 .AND. J2CT(I).GT.0 .AND. &
             K2CT(I).GT.0 .AND. L2CT(I).GT.0)
        IF(OK) THEN
           LFIRST=(ISLCT(I2CT(I)).EQ.1 .OR. &
                ISLCT(J2CT(I)).EQ.1 .OR. &
                ISLCT(K2CT(I)).EQ.1 .OR. &
                ISLCT(L2CT(I)).EQ.1)
           LSECON=(JSLCT(I2CT(I)).EQ.1 .OR. &
                JSLCT(J2CT(I)).EQ.1 .OR. &
                JSLCT(K2CT(I)).EQ.1 .OR. &
                JSLCT(L2CT(I)).EQ.1)
        ENDIF
        IF(.NOT.OK) THEN
           I2CT(I)=MARK
        ELSE IF(LFIRST.AND.LSECON) THEN
           I2CT(I)=MARK
        ENDIF

     ENDDO
  ENDIF
#endif 
  !
  CALL CMPRIC(MARK,LSORT)

  IF(qdrude) nbdrude = nbond

  !
  RETURN
END SUBROUTINE DELTI2

SUBROUTINE MAPIC(MAP,INVMAP,SEGLST,RESLST,GRPLST,LINB, &
     LIBLO,MARK,BYPASS)
  !-----------------------------------------------------------------------
  !  This routine maps PSF, coordinates, constraints and IC's according to
  !  a MAP and its inverse INV_MAP. GRP_LST contains a group number for
  !  each atom and is used to redefine the group boundaries. See PATIC2
  !  for use of this routine. If BYPASS only the groups are redefined.
  !
  !
  !    MAP(NATOM)    - Forward map, for each atom, what does it become?
  !    INVMAP(NATOM) - Inverse map, for each atom, where did it come from?
  !    SEGLST        -
  !    RESLST        -
  !    GRPLST        -
  !    LINB          -
  !    LIBLO         -
  !    MARK          - The value to mark an atom for deletion
  !    BYPASS        - Logical flag to skip atom remapping
  !
  !
  !     NOTE: THIS ROUTINE MAY BE MODIFIED IF THE PSF, COORDINATES,
  !     CONSTRAINTS OR IC COMMON BLOCKS ARE MODIFIED.
  !     AFTER CALLING THIS ROUTINE A CALL TO CMPRIC IS NECESSARY TO
  !     DELETE MARKED ATOMS IN ALL LISTS.
  !
  !     23-JAN-83 AB
  !

#if KEY_CHEQ==1
  use cheq,only: ech,eha,qcgrp,molbl,molsrt,allocate_cheq  
#endif

  use dimens_fcm
  use psf
  use aniso_fcm
  use coord
  use coordc
  use cnst_fcm
  use hbondm
  use stream
  use lonepr
  use noem
#if KEY_REPLICA==1
  use replica_mod      
#endif
  use mmffm
  use ffieldm
  use memory
  use intcor_module,only:remapic
  use chutil,only:getres
  !
  integer,allocatable,dimension(:) :: WORK
  integer,allocatable,dimension(:,:) :: WORK2D
  real(chm_real),allocatable,dimension(:) :: RWORK
  logical,allocatable,dimension(:) :: LWORK
  INTEGER :: MAP(:), INVMAP(:), SEGLST(:)
  INTEGER :: RESLST(:), GRPLST(:)
  INTEGER :: LINB(:), LIBLO(:)
  INTEGER   MARK
  INTEGER   IX, NANISOLD
  LOGICAL   BYPASS, OK
  !
  INTEGER   NDEL
  character(len=8),allocatable,dimension(:) :: cwork
  real(chm_real)    QTOT
  INTEGER   GROUP, I, IR, II, J, JJ, IGRP, RESIDU, SEGMEN
  INTEGER   I2, JS
  !
  call chmalloc(SRCFILE,'MAPIC','WORK',NATOM,intg=WORK)
  call chmalloc(SRCFILE,'MAPIC','cWORK',NATOM,ch8=cWORK)
  call chmalloc(SRCFILE,'MAPIC','RWORK',NATOM,crl=RWORK)
  call chmalloc(SRCFILE,'MAPIC','LWORK',NATOM,log=LWORK)
  IF(.NOT.BYPASS) THEN
     !
     IF(PRNLEV.GE.2) WRITE(OUTU,1500)
1500 FORMAT(/' Message from MAPIC: Atom numbers are changed.')
     CALL AINDX4(INVMAP,IAC,NATOM,WORK)
     CALL AINDEX(INVMAP,AMASS,NATOM,RWORK)
#if KEY_MMFF==1
     if(ffield == mmff) CALL AINDX4(INVMAP,AtNum,NATOM,WORK) 
#endif
     ! SAPATEL
#if KEY_CHEQ==1
     CALL AINDEX(INVMAP,ECH,NATOM,RWORK)
     CALL AINDEX(INVMAP,EHA,NATOM,RWORK)
#endif 
     ! SAPATEL
     CALL AINDEX(INVMAP,CG,NATOM,RWORK)
     CALL AINDXC(INVMAP,ATYPE,NATOM,CWORK)
     CALL AINDX4(INVMAP,IMOVE,NATOM,WORK)
     CALL AINDEX(INVMAP,ALPHADP,NATOM,RWORK)
     CALL AINDEX(INVMAP,THOLEI,NATOM,RWORK)
     CALL AINDXL(INVMAP,ISDRUDE,NATOM,LWORK)
     !
     CALL AINDEX(INVMAP,X,NATOM,RWORK)
     CALL AINDEX(INVMAP,Y,NATOM,RWORK)
     CALL AINDEX(INVMAP,Z,NATOM,RWORK)
     CALL AINDEX(INVMAP,WMAIN,NATOM,RWORK)
     CALL AINDEX(INVMAP,XCOMP,NATOM,RWORK)
     CALL AINDEX(INVMAP,YCOMP,NATOM,RWORK)
     CALL AINDEX(INVMAP,ZCOMP,NATOM,RWORK)
     CALL AINDEX(INVMAP,WCOMP,NATOM,RWORK)
#if KEY_WCA==1
     CALL AINDEX(INVMAP,WCA,NATOM,RWORK)
#endif 
     CALL AINDEX(INVMAP,RSCLF,NATOM,RWORK)

     if (allocated(ihset)) then
        call allocate_cnst(NATOM)
        CALL AINDEX(INVMAP,KCNSTR,NATOM,RWORK)
        CALL AINDX4(INVMAP,IHSET,NATOM,WORK)
        CALL AINDEX(INVMAP,REFX,NATOM,RWORK)
        CALL AINDEX(INVMAP,REFY,NATOM,RWORK)
        CALL AINDEX(INVMAP,REFZ,NATOM,RWORK)
        CALL AINDEX(INVMAP,FBETA,NATOM,RWORK)
     endif
#if KEY_REPLICA==1
     !# <caves>-Aug-4-1993 (Leo Caves) Remap replica atom flags and weights
     IF (qRep) THEN
        CALL AINDEX(INVMAP,repWt,NATOM,RWORK)
        CALL AINDX4(INVMAP,repNoA,NATOM,WORK)
     ENDIF ! qRep
#endif /*  REPLICA*/
     CALL AVALUE(MAP,ICS,NCSPHI,MARK)
     CALL AVALUE(MAP,JCS,NCSPHI,MARK)
     CALL AVALUE(MAP,KCS,NCSPHI,MARK)
     CALL AVALUE(MAP,LCS,NCSPHI,MARK)
     !
     CALL AVALUE(MAP,IB,NBOND,MARK)
     CALL AVALUE(MAP,JB,NBOND,MARK)
     !
     CALL AVALUE(MAP,IT,NTHETA,MARK)
     CALL AVALUE(MAP,JT,NTHETA,MARK)
     CALL AVALUE(MAP,KT,NTHETA,MARK)
     !
     CALL AVALUE(MAP,IP,NPHI,MARK)
     CALL AVALUE(MAP,JP,NPHI,MARK)
     CALL AVALUE(MAP,KP,NPHI,MARK)
     CALL AVALUE(MAP,LP,NPHI,MARK)
     !
     CALL AVALUE(MAP,IM,NIMPHI,MARK)
     CALL AVALUE(MAP,JM,NIMPHI,MARK)
     CALL AVALUE(MAP,KM,NIMPHI,MARK)
     CALL AVALUE(MAP,LM,NIMPHI,MARK)

#if KEY_CMAP==1
     CALL AVALUE(MAP,I1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,J1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,K1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,L1CT,NCRTERM,MARK)
     CALL AVALUE(MAP,I2CT,NCRTERM,MARK)
     CALL AVALUE(MAP,J2CT,NCRTERM,MARK)
     CALL AVALUE(MAP,K2CT,NCRTERM,MARK)
     CALL AVALUE(MAP,L2CT,NCRTERM,MARK)
#endif 
     !
     CALL AVALUE(MAP,IHD1,NDON,MARK)
     CALL AVALUE(MAP,IDON,NDON,MARK)
     !
     CALL AVALUE(MAP,IACC,NACC,MARK)
     CALL AVALUE(MAP,IAC1,NACC,MARK)
     !
#if KEY_NOMISC==0
     CALL AVALUE(MAP,NOELIS,NOENM2,MARK)
#endif 
     !
#if KEY_LONEPAIR==1
     CALL AVALUE(MAP,LPHOST,NUMLPH,MARK)
     !
     ! Do we need to remove any deleted lonepairs?
     OK=.TRUE.
     DO I=1,NUMLPH
        IF(LPHOST(I).EQ.MARK) OK=.FALSE.
     ENDDO
     ! If not OK, then we need to remove some lonepairs
     IF(.NOT.OK) CALL LONEPRD(MARK)
#endif 
         CALL AVALUE(MAP,LSTANI1,NANISO,MARK)
         CALL AVALUE(MAP,LSTANI2,NANISO,MARK)
         CALL AVALUE(MAP,LSTANI3,NANISO,MARK)
         CALL AVALUE(MAP,LSTANI4,NANISO,MARK)

         NANISOLD=NANISO
         NANISO=0
         DO I=1,NANISOLD
           IF((LSTANI1(I).EQ.MARK).OR.(LSTANI2(I).EQ.MARK) &
           .OR.(LSTANI3(I).EQ.MARK).OR.(LSTANI4(I).EQ.MARK))THEN
              NANISO=NANISO
           ELSE
              NANISO=NANISO+1
              LSTANI1(NANISO)=LSTANI1(I)
              LSTANI2(NANISO)=LSTANI2(I)
              LSTANI3(NANISO)=LSTANI3(I)
              LSTANI4(NANISO)=LSTANI4(I)
              K11(NANISO)=K11(I)
              K22(NANISO)=K22(I)
              K33(NANISO)=K33(I)
           ENDIF
         ENDDO
         IF(NANISOLD.GT.NANISO .and. prnlev.ge.2)THEN
            write(outu,*) NANISOLD-NANISO,' anisotropic terms deleted'
         ENDIF

     ! Remove any worthless dihedral constraint table entries
     II=0
     DO I=1,NCSPHI
        IF(ICS(I).NE.MARK .AND. JCS(I).NE.MARK .AND. &
             KCS(I).NE.MARK .AND. LCS(I).NE.MARK) THEN
           II=II+1
           ICS(II)=ICS(I)
           JCS(II)=JCS(I)
           KCS(II)=KCS(I)
           LCS(II)=LCS(I)
        ENDIF
     ENDDO
     NDEL=NCSPHI-II
     NCSPHI=II
     IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) &
          NDEL,'dihedral constraints'
22   FORMAT(' DELTIC:',I10,1X,A,' deleted')
     !
#if KEY_NOMISC==0
     ! Remove any worthless NOE constraint table entries
     NDEL=0
     DO I=1,NOENUM
        II=NOEIPT(I)-1
        DO J=1,NOEINM(I)
           IF(NOELIS(II+J).EQ.MARK) THEN
              NOEINM(I)=0
              NOEJNM(I)=0
              NDEL=NDEL+1
              GOTO 125
           ENDIF
        ENDDO
        II=NOEJPT(I)-1
        DO J=1,NOEJNM(I)
           IF(NOELIS(II+J).EQ.MARK) THEN
              NOEINM(I)=0
              NOEJNM(I)=0
              NDEL=NDEL+1
              GOTO 125
           ENDIF
        ENDDO
125     CONTINUE
     ENDDO
     IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) &
          NDEL,'NOE restraints'
#endif 
     !
     !  Remap all internal coordinate tables.
     CALL REMAPIC(MAP,MARK)
     !
     CALL AINDX4(INVMAP,RESLST,NATOM,WORK)
     CALL AINDX4(INVMAP,SEGLST,NATOM,WORK)
     CALL AINDX4(INVMAP,GRPLST,NATOM,WORK)
     !
     !
     ! re-define INB, IBLO explicit non-bond-exclusion list.
     !
     CALL AVALUE(MAP,INB,NNB,MARK)
     !
     NNB=0
     DO I=1,NATOM
        IF(INVMAP(I).EQ.1) THEN
           JS=1
        ELSE
           JS=IBLO(INVMAP(I)-1)+1
        ENDIF
        DO J=JS,IBLO(INVMAP(I))
           IF (INB(J).NE.MARK) THEN
              NNB=NNB+1
              LINB(NNB)=INB(J)
           ENDIF
        ENDDO
        LIBLO(I)=NNB
     ENDDO
     !
     DO I=1,NATOM
        IBLO(I)=LIBLO(I)
     ENDDO
     DO I=1,NNB
        INB(I)=LINB(I)
     ENDDO
     !
     !
     !     Redefine residue pointers IBASE as well as RES and RESID:
     !
     !
     RESIDU=-1
     II=NRES
     NRES=0
     DO I=1,NATOM
        IF(RESIDU.NE.RESLST(I)) THEN
           RESIDU=RESLST(I)
           NRES=NRES+1
           IBASE(NRES)=I-1
           INVMAP(NRES)=RESLST(I)
        ENDIF
     ENDDO
     IBASE(NRES+1)=NATOM
     !
     CALL AINDXC(INVMAP,RES,NRES,CWORK)
     CALL AINDXC(INVMAP,RESID,NRES,CWORK)
     !
     IF(NRES.NE.II .AND. PRNLEV.GE.2) WRITE(OUTU,1070) (II-NRES)
1070 FORMAT(/' Message from MAPIC: ',I10,' residues deleted.')
     !
     ! Redefine segment pointers NICTOT(*) as well as SEGID:
     !
     !
     SEGMEN=-1
     II=NSEG
     NSEG=0
     DO I=1,NATOM
        IF (SEGMEN.NE.SEGLST(I)) THEN
           SEGMEN=SEGLST(I)
           NSEG=NSEG+1
           I2=I
           NICTOT(NSEG)=GETRES(I2,IBASE,NRES)-1
           INVMAP(NSEG)=SEGLST(I)
        ENDIF
     ENDDO
     NICTOT(NSEG+1)=NRES
     !
     CALL AINDXC(INVMAP,SEGID,NSEG,CWORK)
     !
     IF (NSEG.NE.II .AND. PRNLEV.GE.2) WRITE(OUTU,1080) (II-NSEG)
1080 FORMAT(/' Message from MAPIC: ',I10,' segments deleted.')
  ENDIF
  !
  ! now re-define groups:
  !
  GROUP=-1
  NGRP=0
  DO I=1,NATOM
     IF(GROUP.NE.GRPLST(I)) THEN
        GROUP=GRPLST(I)
        IF(NGRP.GE.MAXGRP) THEN
           CALL WRNDIE(-4,'<MAPIC>', &
                'Max. numb. of groups MAXGRP exceeded')
        ELSE
           NGRP=NGRP+1
           IGPBS(NGRP)=I-1
           IMOVEG(NGRP)=0
        ENDIF
     ENDIF
  ENDDO
  IGPBS(NGRP+1)=NATOM
  !
  ! Find group types
  !
  NST2=0
  IR=1
  DO IGRP=1,NGRP
     II=IGPBS(IGRP)+1
     JJ=IGPBS(IGRP+1)
     !
     DO WHILE(IBASE(IR+1).LT.II)
        IR=IR+1
     ENDDO
     I=1
     DO WHILE (IMOVE(I).GT.0 .AND. I.LT.JJ)
        I=I+1
     ENDDO
     IF(IMOVE(I).GT.0) THEN
        IMOVEG(IGRP)=1
     ELSE
        IMOVEG(IGRP)=0
     ENDIF
     !
     ! Test for ST2
     !
     IF(RES(IR).NE.'ST2 ') THEN
        !
#if KEY_REPLICA==1
        !# <caves>-Aug-4-1993 (Leo Caves) remap replica group membership
        IF (qRep) repNoG(iGrp) = repNoA(ii)
#endif /*  REPLICA*/
        !
        IGPTYP(IGRP)=0
        QTOT=0.0
        DO I=II,JJ
           QTOT=QTOT+CG(I)
           IF(CG(I).NE.0.0) IGPTYP(IGRP)=1
        ENDDO
        IF(ABS(QTOT).GT.0.0001) IGPTYP(IGRP)=2
     ELSE
        !
        !     Group is of ST2 type
        !
#if KEY_NOST2==0
        NST2=NST2+1
        IGPTYP(IGRP)=3
        IF((JJ-II).NE.4) &
             CALL WRNDIE(0,'<MAPIC>',' ST2 group must have 5 atoms')
        IMOVE(JJ-1)=-1
        IMOVE(JJ)=-1
#else /**/
        CALL WRNDIE(-1,'<MAPIC>','ST2 code is not compiled.')
#endif 
     ENDIF
  ENDDO
  !
  !     reset hbond list:
  !
  NHB=0
  !
  call chmdealloc(SRCFILE,'MAPIC','WORK',NATOM,intg=WORK)
  call chmdealloc(SRCFILE,'MAPIC','cWORK',NATOM,ch8=cWORK)
  call chmdealloc(SRCFILE,'MAPIC','RWORK',NATOM,crl=RWORK)
  call chmdealloc(SRCFILE,'MAPIC','LWORK',NATOM,log=LWORK)

  ! SAPATEL
#if KEY_CHEQ==1
#if KEY_REPLICA==1
  IF(.NOT.QREP) THEN      
#endif
     ! sort for molecular label
     if(allocated(molbl)) then
        ! psf changed, check whether arrays are still right size
        call allocate_cheq(natom, ngrp)
        CALL MOLSRT(NATOM,IB,JB,NBOND,QCGRP,NGRP,IGPBS)
     endif
#if KEY_REPLICA==1
  ENDIF                   
#endif
#endif 
  ! SAPATEL
  RETURN
END SUBROUTINE MAPIC

SUBROUTINE CMPRIC(MARK,LSORT)
  !-----------------------------------------------------------------------
  !     This routine deletes marked bonds, angles, ..., IC's and
  !     compresses PSF and IC listings. Optional a sorting is performed.
  !
  !     23-JAN-83, Axel Brunger
  !
  use dimens_fcm
  use exfunc
  use psf
  use stream
  use mmffm
  use ffieldm
  use chutil,only:atomid

  INTEGER   MARK
  LOGICAL   LSORT
  !
  !
  EXTERNAL  EXCH5
#if KEY_CMAP==1
  EXTERNAL EXCH8
#endif 
  INTEGER   I, II, NL
  LOGICAL   CONDIT
  INTEGER NDEL
  !C
  character(len=8) SIDDN,RIDDN,RESDN,ATDN
  !
  !     compress bond lists,...
  !
  II=0
  DO I=1,NBOND
     CONDIT=(IB(I).EQ.MARK.OR.JB(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IB(II)=IB(I)
        JB(II)=JB(I)
#if KEY_MMFF==1
        if(ffield == mmff)  BondType(II)=BondType(I) 
#endif
     ENDIF
  ENDDO
  NDEL=NBOND-II
  NBOND=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'bonds'
22 FORMAT(' DELTIC:',I10,1X,A,' deleted')
  !
  II=0
  DO I=1,NTHETA
     CONDIT=(IT(I).EQ.MARK.OR.JT(I).EQ.MARK.OR.KT(I).EQ.MARK)
     IF(.NOT. CONDIT) THEN
        II=II+1
        IT(II)=IT(I)
        JT(II)=JT(I)
        KT(II)=KT(I)
     ENDIF
  ENDDO
  NDEL=NTHETA-II
  NTHETA=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'angles'
  !
  II=0
  DO I=1,NPHI
     CONDIT=(IP(I).EQ.MARK.OR.JP(I).EQ.MARK.OR.KP(I).EQ.MARK &
          .OR.LP(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IP(II)=IP(I)
        JP(II)=JP(I)
        KP(II)=KP(I)
        LP(II)=LP(I)
     ENDIF
  ENDDO
  NDEL=NPHI-II
  NPHI=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'dihedrals'
  !
  II=0
  DO I=1,NIMPHI
     CONDIT=(IM(I).EQ.MARK.OR.JM(I).EQ.MARK.OR.KM(I).EQ.MARK &
          .OR.LM(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        IM(II)=IM(I)
        JM(II)=JM(I)
        KM(II)=KM(I)
        LM(II)=LM(I)
     ENDIF
  ENDDO
  NDEL=NIMPHI-II
  NIMPHI=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL, &
       'improper dihedrals'

#if KEY_CMAP==1
  II=0
  DO I=1,NCRTERM
     CONDIT=(I1CT(I).EQ.MARK.OR.J1CT(I).EQ.MARK.OR. &
          K1CT(I).EQ.MARK.OR.L1CT(I).EQ.MARK.OR. &
          I2CT(I).EQ.MARK.OR.J2CT(I).EQ.MARK.OR. &
          K2CT(I).EQ.MARK.OR.L2CT(I).EQ.MARK)
     IF(.NOT.CONDIT) THEN
        II=II+1
        I1CT(II)=I1CT(I)
        J1CT(II)=J1CT(I)
        K1CT(II)=K1CT(I)
        L1CT(II)=L1CT(I)

        I2CT(II)=I2CT(I)
        J2CT(II)=J2CT(I)
        K2CT(II)=K2CT(I)
        L2CT(II)=L2CT(I)
     ENDIF
  ENDDO
  NDEL=NCRTERM-II
  NCRTERM=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL, &
       'crossterm maps'
#endif 

  !
  CALL SORT(NDON,EXCH5,ORDER5,IDON,IHD1,0,0,0,0,0,2)
  II=0
  DO I=1,NDON
     CONDIT=(IDON(I).EQ.MARK.OR.IHD1(I).EQ.MARK)
     !
     IF(II.GT.0 .AND. .NOT.CONDIT) THEN
        IF(IDON(I).EQ.IDON(II).AND.IHD1(I).EQ.IHD1(II)) THEN
           CONDIT=.TRUE.
           !C
           NL=IDON(I)
           CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                ' DUPLICATE DONOR FOUND FOR ', &
                SIDDN(1:idleng),RIDDN(1:idleng), &
                RESDN(1:idleng),ATDN(1:idleng)
           IF (IHD1(I).NE.0) THEN
              NL=IHD1(I)
              CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
              IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                   ' WITH DONOR HYDROGEN ', &
                   SIDDN(1:idleng),RIDDN(1:idleng), &
                   RESDN(1:idleng),ATDN(1:idleng)
           ENDIF
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a)') &
                ' DUPLICATE ENTRY REMOVED.'
           !
        ENDIF
     ENDIF
     !
     IF(.NOT.CONDIT) THEN
        II=II+1
        IDON(II)=IDON(I)
        IHD1(II)=IHD1(I)
     ENDIF
  ENDDO
  NDEL=NDON-II
  NDON=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'donors'
  !
  CALL SORT(NACC,EXCH5,ORDER5,IACC,IAC1,0,0,0,0,0,2)
  II=0
  DO I=1,NACC
     CONDIT=(IACC(I).EQ.MARK.OR.IAC1(I).EQ.MARK)
     !
     IF(II.GT.0 .AND. .NOT.CONDIT) THEN
        IF(IACC(I).EQ.IACC(II)) THEN
           CONDIT=.TRUE.
           !C
           NL=IACC(I)
           CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                ' DUPLICATE ACCEPTOR FOUND FOR ', &
                SIDDN(1:idleng),RIDDN(1:idleng), &
                RESDN(1:idleng),ATDN(1:idleng)
           IF (IAC1(I).NE.0) THEN
              NL=IAC1(I)
              CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
              IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                   ' ACCEPTOR ANTECEDENT ', &
                   SIDDN(1:idleng),RIDDN(1:idleng), &
                   RESDN(1:idleng),ATDN(1:idleng), &
                   ' REMOVED.'
           ENDIF
           IF (IAC1(II).NE.0) THEN
              NL=IAC1(II)
              CALL ATOMID(NL,SIDDN,RIDDN,RESDN,ATDN)
              IF(WRNLEV.GE.2) WRITE(OUTU,'(a,4(1x,a),a)') &
                   ' ACCEPTOR ANTECEDENT ', &
                   SIDDN(1:idleng),RIDDN(1:idleng), &
                   RESDN(1:idleng),ATDN(1:idleng), &
                   ' REMOVED.'
           ENDIF
           IF(WRNLEV.GE.2) WRITE(OUTU,'(a)') &
                ' DUPLICATE ENTRY REMOVED.'
           !C
           IAC1(II)=0
        ENDIF
     ENDIF
     !
     IF(.NOT.CONDIT) THEN
        II=II+1
        IACC(II)=IACC(I)
        IAC1(II)=IAC1(I)
     ENDIF
  ENDDO
  NDEL=NACC-II
  NACC=II
  IF(NDEL.GT.0 .AND. PRNLEV.GE.2) WRITE(OUTU,22) NDEL,'acceptors'
  !
  ! finally sort all lists if LSORT is true
  !
  IF (LSORT) THEN
     CALL SORT(NBOND,EXCH5,ORDER5,IB,JB,0,0,0,0,0,2)
     CALL SORT(NTHETA,EXCH5,ORDER5,IT,JT,KT,0,0,0,0,3)
     CALL SORT(NPHI,EXCH5,ORDER5,IP,JP,KP,LP,0,0,0,4)
     CALL SORT(NIMPHI,EXCH5,ORDER5,IM,JM,KM,LM,0,0,0,4)
#if KEY_CMAP==1
     CALL SORT(NCRTERM,EXCH8,ORDER8, &
          I1CT,J1CT,K1CT,L1CT,I2CT,J2CT,K2CT,L2CT)
#endif 
     CALL SORT(NDON,EXCH5,ORDER5,IDON,IHD1,0,0,0,0,0,2)
     CALL SORT(NACC,EXCH5,ORDER5,IACC,IAC1,0,0,0,0,0,2)
  ENDIF
  !
  RETURN
END SUBROUTINE CMPRIC

SUBROUTINE ADDSRCHAT(SID,PDEF,NXGRID,NYGRID,NZGRID, &
     XMAT,YMAT,ZMAT,MAT)
  !
  ! This routine adds dummy atoms based on a grid of selected
  ! points (called from the COOR SEARch command).
  !
  !     By Bernard R. Brooks  1998
  !
  use dimens_fcm
  use exfunc
  use number
  use psf
  use rtf,only: atct, natct, armass
  use coord
  use stream

  character(len=*) SID,PDEF
  INTEGER     NXGRID,NYGRID,NZGRID
  real(chm_real)      XMAT(NXGRID),YMAT(NYGRID),ZMAT(NZGRID)
  INTEGER     MAT(*)
  !
  INTEGER I,J,K,IPT,NADD,TYPECD
  character(len=8) TYPENM
  !
  TYPENM=PDEF
  TYPECD=SRCHWS(ATCT,NATCT,TYPENM)
  IF (TYPECD.EQ.0) THEN
     CALL WRNDIE(-2,'<ADDSRCHAT>', &
          'Bad atom type code specified')
     RETURN
  ENDIF
  !
  IPT=0
  NADD=0
  DO I=1,NXGRID
     DO J=1,NYGRID
        DO K=1,NZGRID
           IPT=IPT+1
           IF(MAT(IPT).GE.1) NADD=NADD+1
        ENDDO
     ENDDO
  ENDDO
  !
  IF(NATOM+NADD.GT.MAXA .OR. NGRP+NADD.GT.MAXGRP) THEN
     CALL WRNDIE(-2,'<ADDSRCHAT>', &
          'Too many grid points to add as dummy atoms')
     RETURN
  ENDIF
  !
  IPT=0
  NADD=0
  DO I=1,NXGRID
     DO J=1,NYGRID
        DO K=1,NZGRID
           IPT=IPT+1
           IF(MAT(IPT).GE.1) THEN
              NADD=NADD+1
              !
              IGPBS(NGRP+NADD+1)=NATOM+NADD
              IGPTYP(NGRP+NADD)=0
              IMOVEG(NGRP+NADD)=0
              IAC(NATOM+NADD)=TYPECD
              IMOVE(NATOM+NADD)=0
              IBLO(NATOM+NADD)=IBLO(NATOM)
              ATYPE(NATOM+NADD)='DUM'
              CG(NATOM+NADD)=ZERO
              AMASS(NATOM+NADD)=ARMASS(TYPECD)
              RSCLF(NATOM+NADD)=ONE
#if KEY_WCA==1
              WCA(NATOM+NADD)=ONE          
#endif
              !
              X(NATOM+NADD)=XMAT(I)
              Y(NATOM+NADD)=YMAT(J)
              Z(NATOM+NADD)=ZMAT(K)
              !
           ENDIF
        ENDDO
     ENDDO
  ENDDO
  !
  NATOM=NATOM+NADD
  NGRP=NGRP+NADD
  !
  NRES=NRES+1
  IBASE(NRES+1)=NATOM
  RES(NRES)='DUM'
  RESID(NRES)='1'
  NSEG=NSEG+1
  NICTOT(NSEG+1)=NRES
  SEGID(NSEG)=SID
  !
  ! . Print out the structure file counters.
  CALL PSFSUM(OUTU)
  !
  RETURN
END SUBROUTINE ADDSRCHAT

SUBROUTINE CRENAME(COMLYN,COMLEN)
  !-----------------------------------------------------------------------
  !     THIS ROUTINE RENAMES SEGMENTS, RESIDUES, RESNAMES, ATOM NAMES.
  !
  !     By Bernard R. Brooks  1983
  !
  use dimens_fcm
  use stream
  use psf
  use coord
  use memory
  use select
  use string

  CHARACTER(len=*) :: COMLYN
  INTEGER COMLEN
  INTEGER,allocatable,dimension(:) :: ISLCT
  character(len=4) WRD
  character(len=8) WRD2
  LOGICAL FOUND,GOTIT
  INTEGER ISEG,IRESI,IRESF,IRES,IS,IQ,I
  !
  !
  call chmalloc('charmm_main.src','CRENAME','islct',NATOM,intg=islct)
  WRD=NEXTA4(COMLYN,COMLEN)
  WRD2=NEXTA8(COMLYN,COMLEN)
  CALL SELCTA(COMLYN,COMLEN,ISLCT,X,Y,Z,WMAIN,.TRUE.)
  !
  IF(WRD.EQ.'SEGI') THEN
     GOTIT=.FALSE.
     DO ISEG=1,NSEG
        FOUND=.FALSE.
        IF(WRD2.EQ.SEGID(ISEG)) THEN
           FOUND=.TRUE.
           IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                'DUPLICATE SEGID''S ENTERED')
        ENDIF
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           DO I=IS,IQ
              IF(ISLCT(I).EQ.1 .AND. .NOT.FOUND) THEN
                 IF(PRNLEV.GE.3) WRITE(OUTU,22) &
                      SEGID(ISEG)(1:idleng),WRD2(1:idleng)
22               FORMAT(' SEGMENT ''',A,''' IS RENAMED TO ''', &
                      A,'''')
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE SEGID''S ENTERED')
                 FOUND=.TRUE.
                 SEGID(ISEG)=WRD2
              ENDIF
           ENDDO
        ENDDO
        GOTIT=FOUND .OR. GOTIT
     ENDDO
  ELSE IF(WRD.EQ.'RESI') THEN
     DO ISEG=1,NSEG
        GOTIT=.FALSE.
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           FOUND=.FALSE.
           IF(WRD2.EQ.RESID(IRES)) THEN
              FOUND=.TRUE.
              IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                   'DUPLICATE RESID''S ENTERED')
           ENDIF
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           DO I=IS,IQ
              IF(ISLCT(I).EQ.1 .AND. .NOT.FOUND) THEN
                 IF(PRNLEV.GE.3) WRITE(OUTU,32) &
                      SEGID(ISEG)(1:idleng),RESID(IRES)(1:idleng), &
                      WRD2(1:idleng)
32               FORMAT(' FOR SEGMENT ''',A,''', RESIDUE ''',A, &
                      ''' IS RENAMED',' TO ''',A,'''')
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE RESID''S ENTERED')
                 FOUND=.TRUE.
                 RESID(IRES)=WRD2
              ENDIF
           ENDDO
           GOTIT=FOUND .OR. GOTIT
        ENDDO
     ENDDO
  ELSE IF(WRD.EQ.'RESN') THEN
     DO ISEG=1,NSEG
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           FOUND=.FALSE.
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           DO I=IS,IQ
              IF(ISLCT(I).EQ.1) THEN
                 IF(.NOT.FOUND) THEN
                    IF(PRNLEV.GE.3) WRITE(OUTU,42) &
                         SEGID(ISEG)(1:idleng), &
                         RESID(IRES)(1:idleng), &
                         RES(IRES)(1:idleng),WRD2(1:idleng)
                 ENDIF
42               FORMAT(' FOR SEGMENT ''',A,''' RESIDUE ''',A, &
                      ''', RESNAME ''',A,''' IS RENAMED TO ''', &
                      A,'''')
                 FOUND=.TRUE.
                 RES(IRES)=WRD2
              ENDIF
           ENDDO
        ENDDO
     ENDDO
  ELSE IF(WRD.EQ.'ATOM') THEN
     DO ISEG=1,NSEG
        IRESI=NICTOT(ISEG)+1
        IRESF=NICTOT(ISEG+1)
        DO IRES=IRESI,IRESF
           IS=IBASE(IRES)+1
           IQ=IBASE(IRES+1)
           GOTIT=.FALSE.
           DO I=IS,IQ
              FOUND=.FALSE.
              IF (WRD2 == ATYPE(I)) THEN
                 FOUND=.TRUE.
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE ATOMS ENTERED')
              ENDIF
              IF(ISLCT(I).EQ.1 .AND. .NOT.FOUND) THEN
                 IF(PRNLEV.GE.3) WRITE(OUTU,52) &
                      SEGID(ISEG)(1:idleng), &
                      RESID(IRES)(1:idleng), &
                      ATYPE(I)(1:idleng), WRD2(1:idleng)
52               FORMAT(' FOR SEGMENT ''',A,''' RESIDUE ''',A, &
                      ''', ATOM ''',A,''' IS RENAMED TO ''', &
                      A,'''')
                 IF(GOTIT) CALL WRNDIE(0,'<RENAME>', &
                      'DUPLICATE ATOMS ENTERED')
                 FOUND=.TRUE.
                 ATYPE(I)=WRD2
              ENDIF
              GOTIT=FOUND .OR. GOTIT
           ENDDO
        ENDDO
     ENDDO
  ELSE
     CALL WRNDIE(0,'<RENAME>','UNRECOGNIZED RENAME OPTION')
  ENDIF
  !
  call chmdealloc('charmm_main.src','CRENAME','islct',NATOM,intg=islct)
  RETURN
END SUBROUTINE CRENAME

SUBROUTINE JOINSG(COMLYN,COMLEN)
  !-----------------------------------------------------------------------
  !     THIS ROUTINE JOINS TWO ADJACENT SEGMENTS TOGETHER.
  !     ITS PRIMARY USE IS IN MODIFYING A PSF FOR USE WITH IMAGES.
  !     NO CHECK OF RESID'S IS MADE, BUT A RENUMBER OPTION IS AVAILABLE.
  !           BRB  10-DEC-1983
  !
  use dimens_fcm
  use stream
  use psf
  use string

  character(len=*) COMLYN
  INTEGER COMLEN
  !
  character(len=8) WRD
  LOGICAL LRENUM,OK
  INTEGER ISEG,I,IS,IQ,JUNK
  !
  IF(NSEG.NE.NSEGT) THEN
     CALL WRNDIE(-2,'<JOINSG>','CANT JOIN WITH IMAGES PRESENT')
     RETURN
  ENDIF
  !
  LRENUM=INDXA(COMLYN,COMLEN,'RENU').GT.0
  !
  WRD=NEXTA8(COMLYN,COMLEN)
  ISEG=-1
  DO I=1,NSEG
     IF(WRD.EQ.SEGID(I)) ISEG=I
  ENDDO
  IF(ISEG.LT.0) THEN
     CALL WRNDIE(-1,'<JOINSG>','CANT FIND FIRST SEGMENT')
     RETURN
  ENDIF
  !
  WRD=NEXTA8(COMLYN,COMLEN)
  OK=ISEG.LT.NSEG
  IF(OK) OK=SEGID(ISEG+1).EQ.WRD
  IF(.NOT.OK) THEN
     IF(LRENUM .AND. WRD.EQ.' ') THEN
        GOTO 100
     ELSE
        CALL WRNDIE(-1,'<JOINSG>', &
             'SECOND SEGMENT DOESNT FOLLOW FIRST')
     ENDIF
     RETURN
  ENDIF
  !
  !
  NSEG=NSEG-1
  NSEGT=NSEG
  DO I=ISEG+1,NSEG
     SEGID(I)=SEGID(I+1)
     NICTOT(I)=NICTOT(I+1)
  ENDDO
  NICTOT(NSEG+1)=NICTOT(NSEG+2)
  IF(PRNLEV.GE.2) WRITE(OUTU,22) SEGID(ISEG)(1:idleng),WRD(1:idleng)
22 FORMAT(' SEGMENTS "',A,'" AND "',A,'" HAVE BEEN JOINED.')
  !
100 CONTINUE
  IF(LRENUM) THEN
     IF(PRNLEV.GE.2) WRITE(OUTU,23)
23   FORMAT(' THE RESIDUE IDENTIFIERS HAVE BEEN RENUMBERED')
     IS=NICTOT(ISEG)+1
     IQ=NICTOT(ISEG+1)
     DO I=IS,IQ
        CALL ENCODI(I-IS+1,RESID(I),8,JUNK)
     ENDDO
  ENDIF
  !yw...09-May-97, set ?NSEG by calling PSFSUM
  CALL PSFSUM(OUTU)
  !
  RETURN
END SUBROUTINE JOINSG

end module modpsf

