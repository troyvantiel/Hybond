module qm1_diagonalization
  use chm_kinds
  use number
  use qm1_constant

  contains

#if KEY_MNDO97==1 /*mndo97*/

  subroutine fast_diag(FAO,VECTOR,EIG,WS,LM2,N,NOCC) ! FMO,
  !
  ! Fast diagonalization procedure.
  !
  ! NOTATION. I=INPUT, O=OUTPUT, S=SCRATCH.
  ! FAO       fock matrix in AO basis (I).
  ! VECTOR    MO vectors (I,O).
  ! EIG       MO energies (I).
  !!!! Not used:  FMO       part of Fock matrix in MO basis (O).
  ! WS        scratch array for intermediate results (S).
  ! LM2       leading dimension of all matrices (I).
  ! N         number of atomic orbitals (I)     ; norbs
  ! NOCC      number of occupied MO orbitals (I); numb
  !
  ! This is a pseudo-diagonalization procedure since the vectors generated by it
  ! are more nearly able to block-diagonalize the fock matrix over molecular
  ! orbitals than the starting vectors.  It must be considered Pseudo for
  ! several reasons:
  ! (A) it does not generate eigenvectors - the secular determinant is not
  !     diagolized, only the occupied-virtual intersection.
  ! (B) many small elements in the Sec.Det. are ignored as being too small
  !     compared with the largest element.
  ! (C) when elements are eliminated by rotation, the rest of the Sec. Det. is
  !     assumed not to change, i.e, elements created are ignored.
  ! (D) the rotation required to eliminate those elements considered significant
  !     is approximated by using the eigenvalues of the exact diagonalization
  !     throughout the rest of the iterative procedure.
  !
  ! In an iterative procedure all the approximations present in diag become
  ! valid at self-consisntency, self-consistency is not slowed down by use of
  ! these approximations.
  !
  ! REFERENCE:
  ! J.J.P.STEWART,P.CSASZAR AND P.PULAY, J.COMPUT.CHEM. 3,227(1982)
  !
#if KEY_PARALLEL==1
  use parallel
#endif
!#if KEY_MNDOOPENMP==1  /*OpenMP specific*/
!  use omp_lib
!#endif                 /*OpenMP specific*/

  implicit none

  integer :: LM2,N,NOCC
  real(chm_real):: FAO(LM2,LM2),VECTOR(LM2,LM2),EIG(LM2)
  real(chm_real):: WS(LM2,NOCC)                 ! FMO(LM2,NOCC),

  ! local variables
  integer :: i,j,ii,jj,m,L,k,i_old,nb2
  integer :: LUMO,NVIRT,IIMAX,JJMAX,IVIRT
  real(chm_real):: TINY,A,B,C,D,E,ALPHA,BETA,S_AUX,eig_i,eig_j,tiny_1,tiny_2
  real(chm_real),parameter :: CUTOFF=0.04D0
  !
  real(chm_real):: ddot_mn ! external function
  integer :: ier=0
  real(chm_real),save,dimension(:,:),allocatable :: fmo_local   !,vect_local(:)=>Null()
  integer :: nnumnod,ist,ift
  integer, save :: old_N = 0
  integer, save :: mstart,mstop,isize,kstart,kstop,ksize,fstart,fstop
#if KEY_PARALLEL==1
  integer      :: ISTRT_CHECK        ! external function
  integer,save :: JPARPT_local(0:MAXNODE),KPARPT_local(0:MAXNODE),LPARPT_local(0:MAXNODE)
  integer      :: isnd_node,irec_node,ID
#endif

  ! check memory size
  LUMO   = NOCC+1   ! 
  NVIRT  = N-NOCC

  ! check if memory need to be allocated.
  ! fmo_local is introduced for the ease of parallelization.
  if(allocated(fmo_local)) then
     if(size(fmo_local).ne.(nocc*nvirt)) deallocate(fmo_local)
  end if
  if(.not.allocated(fmo_local)) then
     if(NOCC < NVIRT) then
        allocate(fmo_local(nvirt,nocc),stat=ier)
     else
        allocate(fmo_local(nocc,nvirt),stat=ier)
     end if
  end if

  ! for parallelization
#if KEY_PARALLEL==1
  nnumnod = numnod
#else
  nnumnod = 1
#endif
  if(old_N .ne. n) then
     old_N  = n
     mstart = 1
     mstop  = n
     kstart = 1
     kstop  = nocc
     fstart = 1
     fstop  = nvirt
#if KEY_PARALLEL==1
     if(nnumnod>1) then
        !mstart = ISTRT_CHECK(mstop,n)

        ! prepare array for vector allgather calls using VDGBRE
        ! mapping for each node (Hard weird).
        JPARPT_local(0)=0
        LPARPT_local(0)=0
        KPARPT_local(0)=0
        do i=1,nnumnod
           JPARPT_local(i)= n*i/nnumnod ! for linear vector
           LPARPT_local(i)= nvirt*i/nnumnod
           KPARPT_local(i)= nocc*i/nnumnod
        end do

        ! for n
        mstart = JPARPT_local(mynod)+1
        mstop  = JPARPT_local(mynod+1)

        ! for nocc
        kstart = KPARPT_local(mynod)+1
        kstop  = KPARPT_local(mynod+1)

        ! for nvirt
        fstart = LPARPT_local(mynod)+1
        fstop  = LPARPT_local(mynod+1)

        if(nocc < nvirt) then
           KPARPT_local(0)=0
           do i=1,nnumnod
              KPARPT_local(i)= KPARPT_local(i)*nvirt
           end do
        else  ! nocc>=nvirt
           LPARPT_local(0)=0
           KPARPT_local(0)=0
           do i=1,nnumnod
              LPARPT_local(i)= LPARPT_local(i)*nocc
              KPARPT_local(i)= nvirt*i/nnumnod      ! reuse this for snd_recv.
           end do
        end if
     end if
#endif
     isize  = mstop-mstart+1
  end if

  !======================================================================
#if KEY_MNDOOPENMP==0  /*OpenMP specific*/
  !======================================================================
  ! This is pure MPI version.

  ! construct the fock MO interaction matrix between occupied and virtual MOS in
  ! fmo_local(nocc,nvirt). So, the buffer ws must hold LM2*nocc words.
  !
  ! in the following, dgemm routine calls are hard-weired here.
  if(NOCC < NVIRT) then
     ! ws:=fao*vector
     ! avoid is the same as do the following matrix multiplication.
     ! note that fao should be a symmetric matrix.
     !ws(1:n,1:nocc)=MATMUL(fao(1:n,1:n),vector(1:n,1:nocc))
     do j = kstart,kstop   ! 1,nocc
        do i=1,n
           ws(i,j) =ddot_mn(n,fao(1:n,i),1,vector(1:n,j),1) ! DOT_PRODUCT(fao(1:n,i),vector(1:n,j))
        end do
     !end do
     !! fmo:=vector'*ws  = v'*fao*v
     !do j = kstart,kstop   ! 1, nocc
        do i = 1, nvirt
           jj= lumo+i-1
           fmo_local(i,j) = ddot_mn(n,vector(1:n,jj),1,ws(1:n,j),1)
        end do       
     end do
#if KEY_PARALLEL==1
     if(nnumnod>1) call VDGBRE(fmo_local,KPARPT_local)
#endif
  else
     ! ws:=fao*vector
     ! above is the same as do the following matrix multiplication.
     ! note that fao should be a symmetric matrix.
     !ws(1:n,1:nvirt)=MATMUL(fao(1:n,1:n),vector(1:n,lumo:lumo+nvirt-1))
     do j = fstart,fstop   ! 1,nvirt
        jj= lumo+j-1
        do i=1,n
           ws(i,j) = ddot_mn(n,fao(1:n,i),1,vector(1:n,jj),1) ! DOT_PRODUCT(fao(1:n,i),vector(1:n,jj))
        end do
     !end do
     !! fmo:=ws'*vector = v'*fao'*v (?)
     !do j = fstart,fstop   ! 1, nvirt
        do i = 1, nocc
           fmo_local(i,j) = ddot_mn(n,ws(1:n,j),1,vector(1:n,i),1)
        end do
     end do
#if KEY_PARALLEL==1
     if(nnumnod>1) call VDGBRE(fmo_local,LPARPT_local)
#endif
  end if


  ! do a crude 2 by 2 rotation to eliminate significant elements.
  iimax  = MAX(NOCC,NVIRT)
  jjmax  = MIN(NOCC,NVIRT)
  ! find tiny value
  if(NOCC < NVIRT) then
     ! note that fmo_local(nvirt,nocc)
     TINY   = CUTOFF*find_tiny(nocc,nvirt)
  else
     ! note that fmo_local(nocc,nvirt)
     TINY   = CUTOFF*find_tiny(nvirt,nocc)
  end if
  !
  if(nocc < nvirt) then
     loopi1: do ii=1,iimax
        loopj1: do jj=1,jjmax
           i      = LUMO+MOD(ii+jj-2,iimax)
           j      = jj
           IVIRT  = i-NOCC
           !if(ABS(fmo_local(IVIRT,j)) < TINY) cycle loopj1
           if(ABS(fmo_local(IVIRT,j)) >= TINY) then
              C      = fmo_local(IVIRT,j)
              D      = EIG(j)-EIG(i)
              E      = (C/D)**2
              ALPHA  = ONE-E*PT5
              BETA   =-SIGN(SQRT(E-E*E*PT25),C)
              do m=1,n
                 A      = VECTOR(m,j)
                 B      = VECTOR(m,i)
                 VECTOR(m,j) = ALPHA*A+BETA*B
                 VECTOR(m,i) = ALPHA*B-BETA*A
              end do
           end if
        end do loopj1
     end do loopi1
     !
  else   ! nocc >= nvirt
     loopi2: do ii=1,iimax     ! = 1,nocc
        loopj2: do jj=1,jjmax  ! = 1,nvirt
           i      = jj+NOCC
           j      = 1+MOD(ii+jj-2,iimax)
           IVIRT  = i-NOCC
           !if(ABS(fmo_local(j,IVIRT)) < TINY) cycle loopj2
           if(ABS(fmo_local(j,IVIRT)) >= TINY) then
              C      = fmo_local(j,IVIRT)
              D      = EIG(j)-EIG(i)
              E      = (C/D)**2
              ALPHA  = ONE-E*PT5
              BETA   =-SIGN(SQRT(E-E*E*PT25),C)
              do m=1,n
                 A      = VECTOR(m,j)
                 B      = VECTOR(m,i)
                 VECTOR(m,j) = ALPHA*A+BETA*B
                 VECTOR(m,i) = ALPHA*B-BETA*A
              end do
           end if
        end do loopj2
     end do loopi2
  end if
  !======================================================================
#else                  /*OpenMP specific*/
  !======================================================================
  ! This is OpenMP/MPI version.

  ! some initializations.
  iimax  = MAX(NOCC,NVIRT)
  jjmax  = MIN(NOCC,NVIRT)
  nb2    = n/2

!$omp parallel private(ii,jj,i,j,ivirt,c,d,e,alpha,beta,m,a,b,k,S_AUX,ID,ist,ift) NUM_THREADS(2)
  id = OMP_get_thread_num()

  ! construct the fock MO interaction matrix between occupied and virtual MOS in
  ! fmo_local(nocc,nvirt). So, the buffer ws must hold LM2*nocc words.
  !
  ! in the following, dgemm routine calls are hard-weired here.
  if(NOCC < NVIRT) then
     ! ws:=fao*vector
     ! avoid is the same as do the following matrix multiplication.
     ! note that fao should be a symmetric matrix.
     !ws(1:n,1:nocc)=MATMUL(fao(1:n,1:n),vector(1:n,1:nocc))
!$omp do 
     do j = kstart,kstop   ! 1,nocc
        do i=1,n
           !ws(i,j) =ddot_mn(n,fao(1:n,i),1,vector(1:n,j),1) ! DOT_PRODUCT(fao(1:n,i),vector(1:n,j))
           S_AUX=zero
           do k=1,n
              S_AUX=S_AUX + fao(k,i)*vector(k,j)
           enddo
           ws(i,j) = S_AUX
        end do
     !end do
     !! fmo:=vector'*ws  = v'*fao*v
     !do j = kstart,kstop   ! 1, nocc
        do i = 1, nvirt
           jj= lumo+i-1
           !fmo_local(i,j) = ddot_mn(n,vector(1:n,jj),1,ws(1:n,j),1)
           S_AUX=zero
           do k=1,n
              S_AUX = S_AUX + ws(k,j)*vector(k,jj)
           enddo
           fmo_local(i,j) = S_AUX
        end do       
     end do
!$omp end do
!$omp single
#if KEY_PARALLEL==1
     if(nnumnod>1) call VDGBRE(fmo_local,KPARPT_local)
#endif
!$omp end single

  else
     ! ws:=fao*vector
     ! above is the same as do the following matrix multiplication.
     ! note that fao should be a symmetric matrix.
     !ws(1:n,1:nvirt)=MATMUL(fao(1:n,1:n),vector(1:n,lumo:lumo+nvirt-1))
!$omp do 
     do j = fstart,fstop   ! 1,nvirt
        jj= lumo+j-1
        do i=1,n
           !ws(i,j) = ddot_mn(n,fao(1:n,i),1,vector(1:n,jj),1) ! DOT_PRODUCT(fao(1:n,i),vector(1:n,jj))
           S_AUX=zero
           do k=1,n
              S_AUX=S_AUX + fao(k,i)*vector(k,jj) ! DOT_PRODUCT(fao(1:n,i),vector(1:n,jj))
           enddo
           ws(i,j) = S_AUX
        end do
     !end do
     !! fmo:=ws'*vector = v'*fao'*v (?)
     !do j = fstart,fstop   ! 1, nvirt
        do i = 1, nocc
           !fmo_local(i,j) = ddot_mn(n,ws(1:n,j),1,vector(1:n,i),1)
           S_AUX=zero
           do k=1,n
              S_AUX = S_AUX + ws(k,j)*vector(k,i)
           enddo
           fmo_local(i,j) = S_AUX
        end do
     end do
!$omp end do
!$omp single
#if KEY_PARALLEL==1
     if(nnumnod>1) call VDGBRE(fmo_local,LPARPT_local)
#endif
!$omp end single
  end if

  ! do a crude 2 by 2 rotation to eliminate significant elements.
  ! 1) find tiny value (find_tiny is hard wired.)
  ! 2) do a 2 by 2 rotation.
  if(nocc < nvirt) then
     ! note that fmo_local(nvirt,nocc)
     if(id==0) then
        ist    = 1
        ift    = nb2
        tiny_1 = zero
        do j=1,nocc/2
           do i=1,nvirt
              tiny_1 = max(abs(fmo_local(i,j)),tiny_1)
           end do
        end do
     else
        ist    = nb2+1
        ift    = n
        tiny_2 = zero
        do j=nocc/2+1,nocc
           do i=1,nvirt
              tiny_2 = max(abs(fmo_local(i,j)),tiny_2)
           end do
        end do
     end if
!$omp barrier
!$omp single
     TINY   = CUTOFF*max(tiny_1,tiny_2)  ! CUTOFF*find_tiny(nocc,nvirt)
!$omp end single
     !
     do ii=1,iimax
        do jj=1,jjmax
           i      = LUMO+MOD(ii+jj-2,iimax)
           j      = jj
           IVIRT  = i-NOCC
           if(ABS(fmo_local(IVIRT,j)) >= TINY) then
              C      = fmo_local(IVIRT,j)
              D      = EIG(j)-EIG(i)
              E      = (C/D)**2
              ALPHA  = ONE-E*PT5
              BETA   =-SIGN(SQRT(E-E*E*PT25),C)
              do m=ist,ift ! 1,n
                 A      = VECTOR(m,j)
                 B      = VECTOR(m,i)
                 VECTOR(m,j) = ALPHA*A+BETA*B
                 VECTOR(m,i) = ALPHA*B-BETA*A
              end do
           end if
        end do
     end do

  else   ! nocc >= nvirt
     ! note that fmo_local(nocc,nvirt)
     if(id==0) then
        ist    = 1
        ift    = nb2
        tiny_1 = zero
        do j=1,nvirt/2
           do i=1,nocc
              tiny_1 = max(abs(fmo_local(i,j)),tiny_1)
           end do
        end do
     else
        ist    = nb2+1
        ift    = n
        tiny_2 = zero
        do j=nvirt/2+1,nvirt
           do i=1,nocc
              tiny_2 = max(abs(fmo_local(i,j)),tiny_2)
           end do
        end do
     end if
!$omp barrier
!$omp single
     TINY   = CUTOFF*max(tiny_1,tiny_2)  ! CUTOFF*find_tiny(nvirt,nocc)
!$omp end single
     !
     do ii=1,iimax     ! = 1,nocc
        do jj=1,jjmax  ! = 1,nvirt
           i      = jj+NOCC
           j      = 1+MOD(ii+jj-2,iimax)
           IVIRT  = i-NOCC
           if(ABS(fmo_local(j,IVIRT)) >= TINY) then
              C      = fmo_local(j,IVIRT)
              D      = EIG(j)-EIG(i)
              E      = (C/D)**2
              ALPHA  = ONE-E*PT5
              BETA   =-SIGN(SQRT(E-E*E*PT25),C)
              do m=ist,ift  ! 1,n
                 A      = VECTOR(m,j)
                 B      = VECTOR(m,i)
                 VECTOR(m,j) = ALPHA*A+BETA*B
                 VECTOR(m,i) = ALPHA*B-BETA*A
              end do
           end if
        end do
     end do
     !
  end if
!$omp end parallel
  !======================================================================
#endif                 /*OpenMP specific*/
  !======================================================================

  return

#if KEY_MNDOOPENMP==0  /*OpenMP specific*/
  contains
     real(chm_real) function find_tiny(NVIRT_local,NOCC_local)
     !
     ! function to find tiny value to use below
     !
     integer :: NVIRT_local,NOCC_local,iinit,ifin
     integer :: i,j
     real(chm_real):: dmax,tiny_tmp

     tiny_tmp=zero
     do j=1,nvirt_local
        do i=1,nocc_local
           tiny_tmp=max(abs(fmo_local(i,j)),tiny_tmp)
           !dmax = abs(fmo_local(i,j))
           !if(dmax > tiny_tmp) tiny_tmp=dmax
        end do
     end do
     find_tiny = tiny_tmp
     !
     return
     end function find_tiny
#endif                 /*OpenMP specific*/
  !
  end subroutine fast_diag


  subroutine evvrsp(N,NVECT,NV,A,B,IWORK,ROOT,VECT,IERR,q_fast_r)
  !     *
  !     DIAGONALIZATION PROCEDURE USING EISPACK-BASED ROUTINES.
  !     *
  !     ORIGINAL AUTHOR:  S.T.ELBERT, AMES LABORATORY-USDOE, JUNE 1985.
  !     REVISED: MAY 1987.
  !     THE ORIGINAL ROUTINE REFERS TO A SYMMETRIC PACKED MATRIX.
  !     MODIFICATIONS BY WALTER THIEL IN JUNE 1990 AND JANUARY 1991
  !     FOR INTEGRATION INTO THE MNDO PROGRAM.
  !
  !     PURPOSE -
  !        FINDS (ALL) EIGENVALUES  AND  (SOME OR ALL) EIGENVECTORS
  !        OF A SYMMETRIC MATRIX.
  !
  !     METHOD -
  !        THE METHOD AS PRESENTED IN THIS ROUTINE CONSISTS OF FOUR STEPS:
  !        FIRST, THE INPUT MATRIX IS REDUCED TO TRIDIAGONAL FORM BY THE
  !        HOUSEHOLDER TECHNIQUE (ORTHOGONAL SIMILARITY TRANSFORMATIONS).
  !        SECOND, THE ROOTS ARE LOCATED USING THE RATIONAL QL METHOD.
  !        THIRD, THE VECTORS OF THE TRIDIAGONAL FORM ARE EVALUATED BY THE
  !        INVERSE ITERATION TECHNIQUE.  VECTORS FOR DEGENERATE OR NEAR-
  !        DEGENERATE ROOTS ARE FORCED TO BE ORTHOGONAL.
  !        FOURTH, THE TRIDIAGONAL VECTORS ARE ROTATED TO VECTORS OF THE
  !        ORIGINAL ARRAY.
  !
  !        THE ROUTINES USED ARE MODIFICATIONS OF THE EISPACK 3
  !        ROUTINES TRED1, TQLRAT, TINVIT AND TRBAK1
  !
  !     REFERENCE:
  !        STEPHEN T. ELBERT,
  !        THEOR. CHIM. ACTA (1987) 71:169-186.
  !
  !        FOR FURTHER DETAILS, SEE EISPACK USERS GUIDE, B. T. SMITH
  !        ET AL, SPRINGER-VERLAG, LECTURE NOTES IN COMPUTER SCIENCE,
  !        VOL. 6, 2-ND EDITION, 1976.  ANOTHER GOOD REFERENCE IS
  !        THE SYMMETRIC EIGENVALUE PROBLEM BY B. N. PARLETT
  !        PUBLISHED BY PRENTICE-HALL, INC., ENGLEWOOD CLIFFS, N.J. (1980)
  !
  !     ON ENTRY -
  !        N     - INTEGER
  !                ORDER OF MATRIX A.
  !        NVECT - INTEGER
  !                NUMBER OF VECTORS DESIRED.  0.LE.NVECT AND NVECT.LE.N
  !        NV    - INTEGER
  !                ROW DIMENSION OF A AND VECT IN CALLING ROUTINE. N.LE.NV
  !        A     - WORKING PRECISION (NV,NV)
  !                INPUT MATRIX, 2-D SYMMETRIC MATRIX
  !        B     - WORKING PRECISION (NV,9)
  !                SCRATCH ARRAY, 9*NV ELEMENTS
  !        IWORK - INTEGER
  !                SCRATCH ARRAY, NV ELEMENTS
  !
  !     ON EXIT  -
  !        A     - DESTROYED.  NOW HOLDS REFLECTION OPERATORS.
  !        ROOT  - WORKING PRECISION (N)
  !                ALL EIGENVALUES IN ASCENDING ORDER.
  !        VECT  - WORKING PRECISION (NV,NVECT)
  !                EIGENVECTORS FOR ROOT(1), ..., ROOT(NVECT).
  !        IERR  - INTEGER
  !                = 0 IF NO ERROR DETECTED,
  !                = K IF ITERATION FOR K-TH EIGENVALUE FAILED,
  !                =-K IF ITERATION FOR K-TH EIGENVECTOR FAILED.
  !
#if KEY_PARALLEL==1
  use parallel
#endif
  implicit none

  integer :: N,NVECT,NV,IERR
  integer :: IWORK(NV)
  real(chm_real):: A(NV,NV),B(NV,8),ROOT(NVECT),VECT(NV,NVECT)
  logical :: q_fast_r  ! flag for the fast routine.

  !
  ! *** CHECK FOR SIMPLE ERRORS
  IERR = N-1
  IF(N.LE.0) THEN
     WRITE(6,910)
     WRITE(6,900) N,NVECT,NV,IERR
     STOP 'EVVRSP'
  ENDIF
  IF(NV.LT.N) THEN
     WRITE(6,920)
     WRITE(6,900) N,NVECT,NV,IERR
     STOP 'EVVRSP'
  ENDIF
  IERR = N+1 
  ! *** REDUCE SYMMETRIC MATRIX A TO TRIDIAGONAL FORM
  CALL TRED1(NV,N,A,B(1,1),B(1,2),B(1,3),B(1,4),B(1,5))
  ! *** FIND ALL EIGENVALUES OF TRIDIAGONAL MATRIX
  CALL EQLRAT(N,B(1,1),B(1,2),B(1,3),ROOT,IWORK,IERR,B(1,4))
  IF(IERR.NE.0) THEN
     WRITE(6,930) IERR
     WRITE(6,900) N,NVECT,NV,IERR
     RETURN
  ENDIF
  IF(NVECT.LE.0) RETURN
  ! *** FIND EIGENVECTORS OF TRI-DIAGONAL MATRIX VIA INVERSE ITERATION
  IERR   = 6
  B(1,3) = zero
  CALL EINVIT(NV,N,B(1,1),B(1,2),B(1,3),NVECT,ROOT,IWORK,   &
              VECT,IERR,B(1,4),B(1,5),B(1,6),B(1,7),B(1,8))
  IF(IERR.NE.0) THEN
     WRITE(6,940) -IERR
     WRITE(6,900) N,NVECT,NV,IERR
     RETURN
  ENDIF
  ! *** FIND EIGENVECTORS OF SYMMETRIC MATRIX VIA BACK TRANSFORMATION
  CALL TRBAK1(NV,N,A,B(1,2),NVECT,VECT)

  900 FORMAT(/1X,'*** EVVRSP PARAMETERS ***',   &
             /1X,'***      N = ',I8,' ***',     &
             /1X,'***  NVECT = ',I8,' ***',     &
             /1X,'***     NV = ',I8,' ***',     &
             /1X,'***   IERR = ',I8,' ***')
  910 FORMAT(1X,'VALUE OF N IS LESS THAN OR EQUAL ZERO')
  920 FORMAT(1X,'NV IS LESS THAN N')
  930 FORMAT(1X,'EQLRAT HAS FAILED TO CONVERGE FOR ROOT',I5)
  940 FORMAT(1X,'EINVIT HAS FAILED TO CONVERGE FOR VECTOR',I5)

  return

  !contains
  end subroutine evvrsp

  !====================================================================!
  !=====================beginning of Private ==========================!

  subroutine tred1(NM,N,A,D,E,E2,Diag,work)
  !
#if KEY_PARALLEL==1
  use parallel,only : mynod,numnod,MAXNODE
#endif
  implicit none

  integer :: NM,N
  real(chm_real):: A(NM,N),D(N),E(N),E2(N),Diag(N),work(N)

  ! local variables
  INTEGER :: I,J,K,L,II,JP1
  real(chm_real):: F,G,H,SCALE,r_SCALE,r_H,sum_f,tmpD,tmpE,E_1,D_1
  integer :: mmynod,nnumnod
  !
  ! This subroutine is a translation of the ALGOL procedure TRED1,
  ! NUM. MATH. 11, 181-195(1968) by Martin, Reinsch, and Wilkinson.
  ! Handbook for Auto. Comp., Vol.II-Linear Algebra, 212-226(1971).
  !
  ! this subroutine reduced a real symmetrix matrix to a symmetrix
  ! tridiagonal matrix using orthogonal similarity transformations.
  !
  ! on input
  ! NM:  must be set to the row dimension of two-dimensional array parameters 
  !      as declared in the calling program dimension statement.
  ! N :  is the order of the matrix.
  ! A :  contains the real symmetric input matrix.  only the lower triangle
  !      of the matrix need be supplied.
  !
  ! on output
  ! A :  contains information about the orthogonal trans-formations used in 
  !      the reduction in its strict lower triangle.  The full upper triangle
  !      of A is unaltered.
  ! D :  contains the diagonal elements of the tridiagonal matrix.
  ! E :  contains the subdiagonal elements of the tridiagonal matrix in its
  !      last n-1 positions.  E(1) is set to zero.
  ! E2:  contains the squares of the corresponding elements of E. E2 may
  !      coincide with E if the squares are not needed.
  !
  ! THIS VERSION DATED AUGUST 1983.
  !

  ! for parallelization
#if KEY_PARALLEL==1
  nnumnod = numnod
  mmynod  = mynod
#else
  nnumnod = 1
  mmynod  = 0
#endif
  !
  do i = 1, n
     D(i)   = A(i,n)
     Diag(i)= A(i,i)   ! A(i,n) = A(i,i)  ! save diagonal elements to be used in the loop.

     ! initialization
     E(i)   = zero
     E2(i)  = zero
  end do
  ! for i=n setp -1 until 1 do
  loopII: do i=n,2,-1
     L = i - 1
     ! scale row 
     scale = ABS(D(1))
     do k = 2, L
        scale = scale + ABS(D(k))
     end do
     if (scale > zero) then
        r_scale= one/scale
        H      = zero
        do k = 1, L
           D(k) = D(k)*r_scale   !  / SCALE
           H    = H + D(k)*D(k)

           E(k)   = zero
           work(k)= zero
        end do
        E2(i)= scale * scale * H
        F    = D(L)
        G    =-SIGN(SQRT(H),F)
        E(i) = scale * G
        H    = H - F * G
        D(L) = F - G
        if (L > 1) then   ! i>2 (L=i-1>1) case.
           ! form A*U 
           r_H    = one/H
           ! form A*U and P
           if(L>100) then
              sum_f  = zero  ! initialization.
              !
!$omp parallel private(j,f,g,k,tmpD,tmpE) NUM_THREADS(2)
!$omp do reduction(+:work)
              do j = mmynod+1,L,nnumnod ! 1, L
                 F = D(j)
                 G = A(j,j)*D(j) ! G = E(j)
                 do k=j+1,L
                    G    = G    + A(k,j) * D(k)
                    !E(k) = E(k) + A(k,j) * F
                    work(k) = work(k) + A(k,j) * F
                 end do
                 E(j) = G
              end do
!$omp end do
!$omp do
              do j=1,L
                 E(j) = (E(j) + work(j))*r_H
                 !E(j) = E(j) + work(j)
              end do
!$omp end do
!$omp single
#if KEY_PARALLEL==1
              if(nnumnod>1) call gcomb(E(1:L),L)
#endif
!$omp end single
!$omp do reduction(+:sum_f)
              do j=1, L
                 !E(j) = E(j)*r_H
                 sum_f= sum_f + E(j)*D(j)
              end do
!$omp end do
!$omp single
              H = half*sum_f*r_H  ! F / (H + H)
!$omp end single

              ! form Q and reduced A
              ! do-loop is split into 3 loops to make it easy to see.
              ! which the original routines have.
!$omp do
              do j=1,L
                 E(j)   = E(j)   - H*D(j)
                 work(j)= zero
              end do
!$omp end do
!$omp do
              do j=mmynod+1,L,nnumnod ! 1,L
                 tmpD = D(j)
                 tmpE = E(j)
                 do k=j,L ! 1,L (if above sum is 1 to L.)
                    A(k,j) = A(k,j) - tmpD*E(k) - tmpE*D(k)  ! A(k,j)=A(k,j)-D(j)*E(k)-E(j)*D(k)
                 end do
                 !work(j) = A(L,j)
              end do
!$omp end do
!$omp single
              do j=mmynod+1,L,nnumnod ! 1,L
                 work(j) = A(L,j)
              end do
#if KEY_PARALLEL==1
              if(nnumnod>1) call gcomb(work(1:L),L)
#endif
!$omp end single
!$omp end parallel
           else
              do j = mmynod+1,L,nnumnod ! 1, L
                 F = D(j)
                 G = A(j,j)*D(j) ! G = E(j)
                 do k=j+1,L
                    G    = G    + A(k,j) * D(k)
                    E(k) = E(k) + A(k,j) * F
                 end do
                 E(j) = E(j) + G
              end do
#if KEY_PARALLEL==1
              if(nnumnod>1) call gcomb(E(1:L),L)
#endif
              sum_f  = zero
              do j=1, L
                 E(j) = E(j)*r_H
                 sum_f= sum_f + E(j)*D(j)
              end do
              H = half*sum_f*r_H  ! F / (H + H)

              ! form Q and reduced A
              ! do-loop is split into 3 loops to make it easy to see.
              ! which the original routines have.
              do j=1,L
                 E(j)   = E(j)   - H*D(j)
              end do
              do j=mmynod+1,L,nnumnod ! 1,L
                 tmpD = D(j)
                 tmpE = E(j)
                 do k=j,L ! 1,L (if above sum is 1 to L.)
                    A(k,j) = A(k,j) - tmpD*E(k) - tmpE*D(k)  ! A(k,j)=A(k,j)-D(j)*E(k)-E(j)*D(k)
                 end do
                 work(j) = A(L,j)
              end do
#if KEY_PARALLEL==1
              if(nnumnod>1) call gcomb(work(1:L),L)
#endif
           end if
        else
           ! L==1 case
           work(1) = A(L,L) ! A(1,1)
#if KEY_PARALLEL==1
           if(nnumnod>1) call PSND8(work(1:1),1)
#endif
        end if
     end if
     ! for the next step. (including scale==zero case.)
     do j=1,L
        F      = D(j)
        D(j)   = work(j)            ! D(j) = A(L,j) ! A(j,L)
        A(j,L) = Diag(j)            ! A(j,L) = A(j,i)
        A(j,i) = F * scale
     end do
  end do loopII

  return
  end subroutine tred1


  subroutine eqlrat(N,DIAG,E,E2IN,D,IND,IERR,E2)
  !
  !     AUTHORS -
  !        THIS IS A MODIFICATION OF ROUTINE TQLRAT FROM EISPACK EDITION 3
  !        DATED AUGUST 1983.
  !        TQLRAT IS A TRANSLATION OF THE ALGOL PROCEDURE TQLRAT,
  !        ALGORITHM 464, COMM. ACM 16, 689(1973) BY REINSCH.
  !        THIS VERSION IS BY S. T. ELBERT (AMES LABORATORY-USDOE).
  !        SOME MINOR MODIFICATIONS BY W. THIEL, JANUARY 1991.
  !
  !     PURPOSE -
  !        THIS ROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC
  !        TRIDIAGONAL MATRIX
  !
  !     METHOD -
  !        RATIONAL QL
  !
  !     ON ENTRY -
  !        N      - INTEGER
  !                 THE ORDER OF THE MATRIX.
  !        D      - W.P. REAL (N)
  !                 CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
  !        E2     - W.P. REAL (N)
  !                 CONTAINS THE SQUARES OF THE SUBDIAGONAL ELEMENTS OF
  !                 THE INPUT MATRIX IN ITS LAST N-1 POSITIONS.
  !                 E2(1) IS ARBITRARY.
  !
  !      ON EXIT -
  !        D      - W.P. REAL (N)
  !                 CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
  !                 ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT AND
  !                 ORDERED FOR INDICES 1,2,...IERR-1, BUT MAY NOT BE
  !                 THE SMALLEST EIGENVALUES.
  !        E2     - W.P. REAL (N)
  !                 DESTROYED.
  !        IERR   - INTEGER
  !                 0          FOR NORMAL RETURN,
  !                 J          IF THE J-TH EIGENVALUE HAS NOT BEEN
  !                            DETERMINED AFTER 30 ITERATIONS.
  !
  !     DIFFERENCES FROM EISPACK 3 - DUE TO S. T. ELBERT
  !        G=G+B INSTEAD OF IF(G.EQ.0) G=B ; B=B/64
  !        F77 BACKWARD LOOPS INSTEAD OF F66 CONSTRUCT
  !        GENERIC INTRINSIC FUNCTIONS
  !        ARRARY  IND  ADDED FOR USE BY EINVIT
  !
  !     EXTERNAL ROUTINES -
  !        EPSLON
  !        INTRINSIC--ABS, SIGN, SQRT
  !
  !     MODIFICATIONS BY WALTER THIEL, JANUARY 1991.
  !        REPLACE SOME GO-TO-CONSTRUCTS BY BLOCK-IF-CONSTRUCTS
  !        COSMETIC CHANGES IN COMMENTS ETC.
  !
  implicit none

  integer :: N,IERR
  integer :: IND(N)
  real(chm_real):: DIAG(N),E(N),E2IN(N),D(N),E2(N)

  INTEGER :: I,J,K,L,M,II,L1,itag
  real(chm_real):: B,C,F,G,H,P,R,S,T,r_R,r_G
  real(chm_real):: epslon_value

  integer,parameter :: imaxiter=30
  real(chm_real),parameter :: SCALE=one/64.0D0
  logical :: q_check
  !
  IERR   = 0
  D(1)   = DIAG(1)
  IND(1) = 1
  K      = 0
  ITAG   = 0
  if (n .eq. 1) return
  do i = 2, n
     D(i)    = DIAG(i)
     E2(i-1) = E2IN(i)
  end do
  F = ZERO
  T = ZERO
  B = EPSLON(ONE)
  epslon_value = B  ! to be used below.
  C = B *B
  B = B * SCALE
  E2(N) = ZERO
  ! main loop
  loopLL: do L = 1, N
     H = ABS(D(L)) + ABS(E(L))
     IF (T .LT. H) THEN
        T = H
        B = epslon_value * ABS(T)  ! EPSLON(T)
        C = B * B
        B = B * SCALE
     END IF
     ! look for small squared sub-diagonal element.
     !M = L - 1
     !do
     !   M = M + 1
     !   if(E2(M) <= C) exit
     !end do
     !
     M = L - 1
     do i = L,N
        if(E2(i) <= C) then
           M = i
           exit
        end if
     end do
     ! E2(n) is always zero, so there is an exist from the loop.
     if (M >  K) then
        if (M /= N) E2IN(M+1) = ZERO
        K    = M
        ITAG = ITAG + 1
     end if
     if (M /= L) then
        ! iterate
        q_check=.true.
        loopJJ: do J = 1, imaxiter ! 30
           ! form shift
           L1   = L + 1
           S    = SQRT(E2(L))
           G    = D(L)
           P    = (D(L1) - G) / (TWO * S)
           R    = SQRT(P*P+ONE)
           D(L) = S / (P + SIGN(R,P))
           H    = G - D(L)
           D(L1:N) = D(L1:N) - H
           F    = F + H
           ! rational QL transformation
           G = D(M) + B
           H = G
           S = ZERO
           do I = M-1,L,-1
              P       = G * H
              R       = P + E2(I)
              r_R     = one/R
              E2(I+1) = S*R
              S       = E2(I)*r_R
              D(I+1)  = H + S*(H + D(I))
              G       = D(I) - E2(I) / G   + B
              H       = G*P*r_R
           end do
           E2(L) = S * G
           D(L)  = H
           ! avoid underflow in convergence test
           if ((H .EQ. ZERO) .or. (ABS(E2(L)) .LE. ABS(C/H)) ) then
              q_check=.false.
              exit loopJJ
           end if
           E2(L) = H * E2(L)
           if (E2(L) .EQ. ZERO) then
              q_check=.false.
              exit loopJJ
           end if
        end do loopJJ
        ! set error: no convergecen to an eigenvalue after "imaxiter=30" iterations.
        if(q_check) then
           IERR = L
           exit loopLL
        end if
     end if
     ! converged
     P = D(L) + F
     ! order eigenvalues.
     I = 1
     if (L > 1) then
        if (P >= D(1)) then
           I = L
           ! loop to find ordered position
           !do
           !   I = I - 1
           !   if(P >= D(i)) exit
           !end do
           do II=L-1,1,-1
              if(P >= D(ii)) then
                 I = II
                 exit
              end if
           end do
           I = I + 1
           if(I /= L) then
              do II = L, I+1, -1
                 D(II)  = D(II-1)
                 IND(II)= IND(II-1)
              end do
           end if
        else
           do II = L, I+1, -1
              D(II)  = D(II-1)
              IND(II)= IND(II-1)
           end do
        end if
     end if
     D(I)   = P
     IND(I) = ITAG
  end do loopLL
  return
  end subroutine eqlrat


  subroutine einvit(NM,N,D,E,E2,M,W,IND,Z,IERR,RV1,RV2,RV3,RV4,RV6)
  !
  !     AUTHORS-
  !        THIS IS A MODIFICATION OF ROUTINE TINVIT FROM EISPACK EDITION 3
  !        DATED AUGUST 1983.
  !        TINVIT IS A TRANSLATION OF THE INVERSE ITERATION TECHNIQUE
  !        IN THE ALGOL PROCEDURE TRISTURM BY PETERS AND WILKINSON.
  !        HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 418-439(1971).
  !        THIS VERSION IS BY S. T. ELBERT (AMES LABORATORY-USDOE).
  !        SOME MINOR MODIFICATIONS BY W. THIEL, JANUARY 1991.
  !
  !     PURPOSE -
  !        THIS ROUTINE FINDS THOSE EIGENVECTORS OF A TRIDIAGONAL
  !        SYMMETRIC MATRIX CORRESPONDING TO SPECIFIED EIGENVALUES.
  !
  !     METHOD -
  !        INVERSE ITERATION.
  !
  !     ON ENTRY -
  !        NM     - INTEGER
  !                 MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
  !                 ARRAY PARAMETERS AS DECLARED IN THE CALLING ROUTINE
  !                 DIMENSION STATEMENT.
  !        N      - INTEGER
  !        D      - W.P. REAL (N)
  !                 CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
  !        E      - W.P. REAL (N)
  !                 CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
  !                 IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY.
  !        E2     - W.P. REAL (N)
  !                 CONTAINS THE SQUARES OF CORRESPONDING ELEMENTS OF E,
  !                 WITH ZEROS CORRESPONDING TO NEGLIGIBLE ELEMENTS OF E.
  !                 E(I) IS CONSIDERED NEGLIGIBLE IF IT IS NOT LARGER THAN
  !                 THE PRODUCT OF THE RELATIVE MACHINE PRECISION AND THE
  !                 SUM OF THE MAGNITUDES OF D(I) AND D(I-1).  E2(1) MUST
  !                 CONTAIN 0.0 IF THE EIGENVALUES ARE IN ASCENDING ORDER,
  !                 OR 2.0 IF THE EIGENVALUES ARE IN DESCENDING ORDER.
  !                 IF TQLRAT, BISECT, TRIDIB, OR IMTQLV
  !                 HAS BEEN USED TO FIND THE EIGENVALUES, THEIR
  !                 OUTPUT E2 ARRAY IS EXACTLY WHAT IS EXPECTED HERE.
  !        M      - INTEGER
  !                 THE NUMBER OF SPECIFIED EIGENVECTORS.
  !        W      - W.P. REAL (M)
  !                 CONTAINS THE M EIGENVALUES IN ASCENDING
  !                 OR DESCENDING ORDER.
  !        IND    - INTEGER (M)
  !                 CONTAINS IN FIRST M POSITIONS THE SUBMATRIX INDICES
  !                 ASSOCIATED WITH THE CORRESPONDING EIGENVALUES IN W --
  !                 1 FOR EIGENVALUES BELONGING TO THE FIRST SUBMATRIX
  !                 FROM THE TOP, 2 FOR THOSE BELONGING TO THE SECOND
  !                 SUBMATRIX, ETC.
  !        IERR   - INTEGER (LOGICAL UNIT NUMBER)
  !                 LOGICAL UNIT FOR ERROR MESSAGES
  !
  !     ON EXIT -
  !        ALL INPUT ARRAYS ARE UNALTERED.
  !        Z      - W.P. REAL (NM,M)
  !                 CONTAINS THE ASSOCIATED SET OF ORTHONORMAL
  !                 EIGENVECTORS. ANY VECTOR WHICH WHICH FAILS TO CONVERGE
  !                 IS LEFT AS IS (BUT NORMALIZED) WHEN ITERATING STOPPED.
  !        IERR   - INTEGER
  !                  0      FOR NORMAL RETURN,
  !                 -R      IF THE EIGENVECTOR CORRESPONDING TO THE R-TH
  !                         EIGENVALUE FAILS TO CONVERGE IN 5 ITERATIONS.
  !                         (ONLY LAST FAILURE TO CONVERGE IS REPORTED)
  !
  !        RV1, RV2, RV3, RV4, AND RV6 ARE TEMPORARY STORAGE ARRAYS.
  !
  !        RV1    - W.P. REAL (N)
  !                 DIAGONAL ELEMENTS OF U FROM LU DECOMPOSITION
  !        RV2    - W.P. REAL (N)
  !                 SUPER(1)-DIAGONAL ELEMENTS OF U FROM LU DECOMPOSITION
  !        RV3    - W.P. REAL (N)
  !                 SUPER(2)-DIAGONAL ELEMENTS OF U FROM LU DECOMPOSITION
  !        RV4    - W.P. REAL (N)
  !                 ELEMENTS DEFINING L IN LU DECOMPOSITION
  !        RV6    - W.P. REAL (N)
  !                 APPROXIMATE EIGENVECTOR
  !
  !     DIFFERENCES FROM EISPACK 3 -  DUE TO S. T. ELBERT
  !        EPS3 IS SCALED BY  EPSCAL  (ENHANCES CONVERGENCE, BUT
  !           LOWERS ACCURACY)!
  !        ONE MORE ITERATION (MINIMUM 2) IS PERFORMED AFTER CONVERGENCE
  !           (ENHANCES ACCURACY)!
  !        REPLACE LOOP WITH PYTHAG WITH SINGLE CALL TO DNRM2!
  !        IF NOT CONVERGED, USE PERFORMANCE INDEX TO DECIDE ON ERROR
  !           VALUE SETTING, BUT DO NOT STOP!
  !        L.U. FOR ERROR MESSAGES PASSED THROUGH IERR
  !        USE PARAMETER STATEMENTS AND GENERIC INTRINSIC FUNCTIONS
  !        USE LEVEL 1 BLAS
  !        USE IF-THEN-ELSE TO CLARIFY LOGIC
  !        LOOP OVER SUBSPACES MADE INTO DO LOOP.
  !        LOOP OVER INVERSE ITERATIONS MADE INTO DO LOOP
  !        ZERO ONLY REQUIRED PORTIONS OF OUTPUT VECTOR
  !
  !        EXTERNAL ROUTINES -
  !        EPSLON
  !        BLAS(1)--DASUM, DAXPY, DDOT, DNRM2, DSCAL
  !        INTRINSIC FUNCTIONS - ABS, MAX, SQRT
  !
  !     MODIFICATIONS BY WALTER THIEL, JANUARY 1991.
  !        REMOVE BLAS(1) REFERENCES--DASUM,DAXPY,DDOT,DSCAL
  !           AND REPLACE THEM BY FORTRAN CODE
  !           LOOK FOR 'CBLAS' TO SEE THE REPLACEMENTS
  !        COSMETIC CHANGES IN COMMENT CARDS ETC.
  !
  !
#if KEY_PARALLEL==1
  use parallel,only : mynod,numnod
#endif
  implicit none

  integer :: M,NM,N,IERR
  integer :: IND(M)
  real(chm_real):: D(N),E(N),E2(N),W(M),Z(NM,M)
  real(chm_real):: RV1(N),RV2(N),RV3(N),RV4(N),RV6(N)

  logical :: CONVGD, q_check
  integer :: GROUP,I,ITS,J,JJ,P,Q,R,S,SUBMAT,TAG,LUEMSG,k,jk
  real(chm_real):: ANORM,EPS2,EPS3,EPS4,NORM,ORDER,RHO,U,UK,V
  real(chm_real):: X0,X1,XU,xx0,xx1
  real(chm_real):: epslon_value,d_sum,d_xmax,absrv
  !
  real(chm_real):: DNRM2_mn,ddot_mn  ! external function

  real(chm_real),parameter :: GRPTOL = 0.001D0,EPSCAL = 0.5D0
  integer,parameter :: its_max=5
  integer :: ier=0
  real(chm_real),pointer,save :: r_rv1(:)=>Null()
  integer,pointer,save        :: j_cnt(:)=>Null()

#if KEY_PARALLEL==1
  ! parallelization
  integer :: mstart,mstop,nnumnod
  logical :: do_this_R
#endif

  !
 001 FORMAT(' EIGENVECTOR ROUTINE EINVIT DID NOT CONVERGE FOR VECTOR'  &
           ,I5,'.  NORM =',1PE10.2,' PERFORMANCE INDEX =',E10.2/       &
           ' (AN ERROR HALT WILL OCCUR IF THE PI IS GREATER THAN 100)')
  !-----------------------------------------------------------------------

  if(associated(r_rv1) .and. size(r_rv1)<n) deallocate(r_rv1)
  if(.not.associated(r_rv1)) allocate(r_rv1(N),stat=ier)

  if(associated(j_cnt) .and. size(j_cnt)<m) deallocate(j_cnt)
  if(.not.associated(j_cnt)) allocate(j_cnt(M),stat=ier)

#if KEY_PARALLEL==1
  nnumnod = numnod
  mstart = m*(mynod)/numnod + 1
  mstop  = m*(mynod+1)/numnod
#endif

  !
  !-----------------------------------------------------------------------
  !
  epslon_value = EPSLON(one)
  LUEMSG = IERR
  IERR = 0
  X0   = ZERO
  UK   = ZERO
  NORM = ZERO
  EPS2 = ZERO
  EPS3 = ZERO
  EPS4 = ZERO
  GROUP= 0
  TAG  = 0
  ORDER= ONE - E2(1)
  Q = 0
  loopSMAT: do SUBMAT = 1, N
     P = Q + 1
     ! .......... ESTABLISH AND PROCESS NEXT SUBMATRIX ..........
     q_check=.true.
     loopQ1: do Q = P, N-1
        if (E2(Q+1) == ZERO) then
           q_check=.false.
           exit loopQ1
        end if
     end do loopQ1
     if(q_check) Q = N
     ! .......... FIND VECTORS BY INVERSE ITERATION ..........
     TAG   = TAG + 1
     ANORM = ZERO
     S     = 0
     loopRR: do R = 1, M
        IF (IND(R) /= TAG) cycle loopRR
        ITS    = 1
        X1     = W(R)
        q_check=.true.
        if (S == 0) then
           ! .......... CHECK FOR ISOLATED ROOT ..........
           XU = ONE
           if (P == Q) then
              RV6(P) = ONE
              CONVGD =.TRUE.
              q_check=.false.
           else
              NORM = ABS(D(P))
              do I = P+1, Q
                 NORM = MAX( NORM, ABS(D(I)) + ABS(E(I)) )
              end do
              ! .......... EPS2 IS THE CRITERION FOR GROUPING,
              !            EPS3 REPLACES ZERO PIVOTS AND EQUAL
              !            ROOTS ARE MODIFIED BY EPS3,
              !            EPS4 IS TAKEN VERY SMALL TO AVOID OVERFLOW .........
              EPS2 = GRPTOL * NORM
              EPS3 = EPSCAL * epslon_value * NORM ! as NORM>0 ! EPSCAL*EPSLON(NORM)
              UK   = float(Q - P + 1)
              EPS4 = UK * EPS3
              UK   = EPS4 / SQRT(UK)
              S    = P
              GROUP= 0
           end if
        else    !  if S.ne.0
           ! .......... LOOK FOR CLOSE OR COINCIDENT ROOTS ..........
           IF (ABS(X1-X0) >= EPS2) THEN
              ! ROOTS ARE SEPARATE
              GROUP = 0
           ELSE
              ! ROOTS ARE CLOSE
              GROUP = GROUP + 1
              IF (ORDER*(X1-X0) <= EPS3) X1 = X0+ORDER*EPS3
           END IF
        end if
#if KEY_PARALLEL==1
        do_this_R =.true.
        !if((R<mstart .or. R>mstop) .and. group==0) then
        if(R<mstart .and. group==0) then
           do_this_R=.false.

           ! find the first next checked R column, which is degenerated to the current R.
           xx0 = X1
           do i=R+1,M
              if(ind(i) /= TAG) cycle
              xx1 = w(i)
              ! i (r+1) will be group>0
              if(abs(xx1-xx0) < EPS2) do_this_R =.true.
              exit
           end do
        end if
        if(do_this_R) then
#endif
        if(q_check) then
           !.......... ELIMINATION WITH INTERCHANGES AND INITIALIZATION OF VECTOR ..........
           U = D(P) - X1
           V = E(P+1)
           RV6(P) = UK
           do I = P+1, Q
              RV6(I) = UK
              if (ABS(E(I)) > ABS(U)) then
                 ! EXCHANGE ROWS BEFORE ELIMINATION
                 ! WARNING: A DIVIDE CHECK MAY OCCUR HERE IF E2 ARRAY HAS NOT BEEN SPECIFIED CORRECTLY
                 r_rv1(i-1) = one/E(I)
                 XU       = U *r_rv1(i-1) ! / E(I)
                 RV4(I)   = XU
                 RV1(I-1) = E(I)  ! so, r_rv1 is the inverse of rv1
                 RV2(I-1) = D(I) - X1
                 IF(I /= Q) RV3(I-1) = E(I+1)
                 U = V - XU * RV2(I-1)
                 V =-XU * RV3(I-1)
              else
                 ! STRAIGHT ELIMINATION
                 r_rv1(i-1) = one/U
                 XU       = E(I)*r_rv1(i-1) !  / U
                 RV4(I)   = XU
                 RV1(I-1) = U     ! so, r_rv1 is the inverse of rv1
                 RV2(I-1) = V
                 RV3(I-1) = ZERO
                 U        = D(I) - X1 - XU * V
                 IF(I /= Q) V = E(I+1)
              end if
           end do
           IF (ABS(U) <= EPS3) U = EPS3
           RV1(Q) = U
           RV2(Q) = ZERO
           RV3(Q) = ZERO
           r_rv1(Q)= one/U
           ! ........ DO INVERSE ITERATIONS
           CONVGD = .FALSE.
           if(group /=0) then
              j = R
              do jj=1,group
                 !loopllt: do
                 !   j = j - 1
                 !   if(ind(j) == TAG) exit loopllt
                 !end do loopllt

                 do k=j-1,1,-1
                    if(ind(k) == TAG) exit 
                 end do
                 j = k
                 j_cnt(jj) = j
              end do
           end if 
           loopITS: do ITS = 1,its_max  ! 1, 5
              if (ITS > 1) then
                 ! .......... FORWARD SUBSTITUTION ..........
                 if (NORM == ZERO) then
                    ! this is to avoid overflow.
                    RV6(S) = EPS4
                    S = S + 1
                    if (S > Q) S = P
                 else
                    XU = EPS4 / NORM
                    RV6(P:Q) = RV6(P:Q) * XU
                 end if
                 ! ... ELIMINATION OPERATIONS ON NEXT VECTOR
                 do I = P+1, Q
                    ! IF RV1(I-1) .EQ. E(I), A ROW INTERCHANGE WAS PERFORMED EARLIER IN THE
                    ! TRIANGULARIZATION PROCESS ..........
                    if (RV1(I-1) == E(I)) then
                       U        = RV6(I-1)
                       RV6(I-1) = RV6(I)
                       RV6(I)   = U - RV4(I)*RV6(I-1)
                    else
                       U        = RV6(I)
                       RV6(I)   = U - RV4(I)*RV6(I-1)
                    end if
                 end do
              end if
              ! .......... BACK SUBSTITUTION
              RV6(Q) = RV6(Q) * r_rv1(Q)  ! / RV1(Q)
              if(group == 0) then
                 V = U
                 U = RV6(Q)
                 NORM = ABS(U)
                 do I = Q-1, P, -1
                    RV6(I) = (RV6(I)-U*RV2(I)-V*RV3(I))*r_rv1(i)  ! / RV1(I)
                    V = U
                    U = RV6(I)
                    NORM = NORM + ABS(U)
                 end do
              else
                 V = U
                 U = RV6(Q)
                 do I = Q-1, P, -1
                    RV6(I) = (RV6(I)-U*RV2(I)-V*RV3(I))*r_rv1(i)  ! / RV1(I)
                    V = U
                    U = RV6(I)
                 end do
                 ! ....... ORTHOGONALIZE WITH RESPECT TO PREVIOUS MEMBERS OF GROUP ..........
                 !J = R
                 !do JJ = 1, GROUP
                 !   looplt: do
                 !      J = J - 1
                 !      if (IND(J) /= TAG) cycle looplt
                 !      exit looplt
                 !   end do looplt
                 !   XU = ZERO
                 !   do I = P, Q
                 !      XU = XU + RV6(I) * Z(I,J)
                 !   end do
                 !   RV6(P:Q) = RV6(P:Q) - XU * Z(P:Q,J)
                 !end do
                 do JJ = 1, GROUP
                    j = j_cnt(jj)
                    !XU = ddot_mn(Q-P+1,RV6(P:Q),1,Z(P:Q,j),1)
                    xu = zero
                    do i=P,Q
                       xu = xu + RV6(i)*Z(i,j)
                    end do
                    RV6(P:Q) = RV6(P:Q) - XU*Z(P:Q,J)
                 end do
                 NORM = ZERO
                 do I = P, Q
                    NORM = NORM + ABS(RV6(I))
                 end do
              end if
              if (CONVGD) exit loopITS
              if (NORM >= one) CONVGD = .TRUE.
           end do loopITS
           ! .......... NORMALIZE SO THAT SUM OF SQUARES IS 1 AND EXPAND TO FULL ORDER ..........
           !XU = ONE / DNRM2_mn(Q-P+1,RV6(P),1)
           ! do direct implentation of DNRM2_mn ...
           if(P==Q) then
              xu = one/abs(rv6(p))
           else
              d_xmax = zero
              d_sum  = one
              do i=P,Q
                 if(rv6(i) /= zero) then
                    absrv = abs(rv6(i))
                    if(d_xmax < absrv) then
                       d_sum = one + d_sum*(d_xmax/absrv)**2
                       d_xmax= absrv
                    else
                       d_sum = d_sum + (absrv/d_xmax)**2
                    end if
                 end if
              end do
              xu = one / (d_xmax*SQRT(d_sum))
           end if
        end if    ! q_check
        if(P==1 .and. Q==N) then
           Z(P:Q,R)   = RV6(P:Q) * XU
        else
           ! just in case.
           Z(1:P-1,R) = ZERO
           Z(P:Q,R)   = RV6(P:Q) * XU
           Z(Q+1:N,R) = ZERO
        end if
        IF (.NOT.CONVGD) THEN
           RHO = ESTPI1(Q-P+1,X1,D(P),E(P),Z(P,R),ANORM)
           IF (RHO .GE. TEN  .AND.  LUEMSG .GT. 0) WRITE(LUEMSG,001) R,NORM,RHO

           ! *** SET ERROR -- NON-CONVERGED EIGENVECTOR ..........
           IF (RHO .GT. HUNDRD) IERR = -R
        END IF
#if KEY_PARALLEL==1
        !
        end if  ! (GROUP/=0 .or. (R>=mstart .or. R<=mstop))
#endif
        X0 = X1
     end do loopRR
     IF (Q .EQ. N) EXIT loopSMAT
  end do loopSMAT
  return
  end subroutine einvit


  subroutine trbak1(NM,N,A,E,M,Z)
  !
  ! This subroutine is a translation of the ALGOL procedure TRBAK1, NUM.
  ! MATH. 11, 181-195(1968) 
  ! by Martin, Reinsch, and Wilkinson (handbook for Auto. Comp.,
  ! Vol.II-Linear Algebra, 212-226(1971)).
  !
  ! This subroutine forms the eigenvectors of a real symmetric matrix by back
  ! transforming those of the corresponding symmetric tridiagonal matrix 
  ! determined by TRED1.
  !
  ! on input
  ! NM:   must be set to the row dimension of two-dimensional array parameters 
  !       as declared in the calling program dimension statement.
  ! N :  is the order of the matrix.
  ! A :  contains information about the orthogonal trans-formations used in the 
  !      reduction by  TRED1 in its strict lower triangle.
  ! E :  contains the subdiagonal elements of the tridiagonal matrix in its
  !      last n-1 positions. E(1) ia arbitrary.
  ! M :  is the number of eignevectors to be back transformed.
  ! Z :  contains the eigenvectors to be back transformed in its first m columns.
  !
  ! on output
  ! Z :  contains the transformed eigenvectors in its first M columns.
  !
  ! Note that TRBAK1 preserves vector elucidean norms.
  !
  ! Modification by W. Thiel, Jan. 1991. 
  !    use upper triangle of matrix A in order to loop over columns.
  !
#if KEY_PARALLEL==1
  use parallel
!#if KEY_MNDOOPENMP==1  /*OpenMP specific*/
!  use omp_lib
!#endif                 /*OpenMP specific*/
#endif

  implicit none

  integer :: NM,N,M
  real(chm_real):: A(NM,N),E(N),Z(NM,M)

  integer :: i,j,k,l
  real(chm_real):: s, r_E
  !real(chm_real):: ddot_mn ! external function

  ! parallelization
  integer, save :: old_M = 0
  integer, save :: mstart,mstop
#if KEY_PARALLEL==1
  integer,save  :: JPARPT_local(0:MAXNODE)
#endif
  !
  if (m .eq. 0 .or. n .eq. 1) return
  ! for parallelization
  if(old_M /= M) then
     old_M  = m
     mstart = 1
     mstop  = m
#if KEY_PARALLEL==1
     if(numnod>1) then
        ! prepare array for vector allgather calls using VDGBRE
        JPARPT_local(0)=0
        do i=1,numnod
           JPARPT_local(i)= (m*i/numnod)*NM ! for linear vector
        end do
        mstart = m*(mynod)/numnod + 1
        mstop  = m*(mynod+1)/numnod
     end if
#endif
  end if
  !
!!  do i=2,n
!!     if(E(i) /= zero) then
!!        ! divisor below is negative of H formed in TRED1.
!!        ! double division avoids possible underflow.
!!        do j=mstart,mstop  ! 1,m
!!           s = zero
!!           do k=1,i-1
!!              s = s + A(k,i)*Z(k,j)
!!           end do
!!           s = s / A(i-1,i) / E(i)
!!           do k=1,i-1
!!              Z(k,j) = Z(k,j) + s*A(k,i)
!!           end do
!!        end do
!!     end if
!!  end do

!$omp parallel do private(i,k,s) NUM_THREADS(2)
  do j=mstart,mstop  ! 1,m
     do i=2,n
        if(E(i) /= zero) then
           ! divisor below is negative of H formed in TRED1.
           ! double division avoids possible underflow.
           s = zero
           do k=1,i-1
              s = s + A(k,i)*Z(k,j)
           end do
           s = s / A(i-1,i) / E(i)
           do k=1,i-1
              Z(k,j) = Z(k,j) + s*A(k,i)
           end do
        end if
     end do
  end do
!$omp end parallel do

#if KEY_PARALLEL==1
  if(numnod>1) call VDGBRE(Z(1:NM,1:M),JPARPT_local)
#endif

  !
  return
  end subroutine trbak1


  real(chm_real) function estpi1(N,EVAL,D,E,X,ANORM)
  !
  ! authors: Stephen T. Elbert (AMES laboratory), 5 Dec. 1986.
  !
  ! Evaluate symmetric tridiagonal matrix performance index for 1 Eigenvector.
  !
  ! This routine forms the 1-norm of the residual matrix A*X-X*Eval,
  ! where A is a symmetric tridiagonal matrix stored in the diagonal (D) and
  ! sub-diagonal (E) vectors, Eval is the eigenvalue of an eigenvectore of A,
  ! namely X.  This norm is scaled by machine accuracy for the problem size.
  ! All norms appearing in the comments below are 1-norms.
  !
  ! on input
  ! N        the order of the matrix A.
  ! Eval     the eigenvalue corresponding to vector X.
  ! D        the diagonal vector of A.
  ! E        the sub-diagonal vector of A.
  ! X        an eigenvector of A.
  ! Anorm    the norm of A if it has been previously computed.
  !
  ! on output
  ! Anorm    the norm of A, computed if initially zero.
  ! Estpi1   ||A*X-X*Eval|| / (Epslon(10*N)*||A||*||X||), where EPSLON(X)
  !          is the smallest number such that X+EPSLON(X).ne.X
  !          Estpi1 .lt. 1                == satisfactory performance
  !                 .ge. 1 .and. .le. 100 == marginal performance
  !                 .gt. 100              == poor performance
  !         (see Lect. Notes in Comp. Sci. Vol.6, pp 124-125).
  !
  implicit none

  integer :: N
  real(chm_real):: EVAL,D(N),E(N),X(N),ANORM

  ! local variables
  real(chm_real):: RNORM,SIZE,XNORM
  integer :: I

  ESTPI1 = zero
  if( n .le. 1 ) return
  size = 10*n
  if (anorm .eq. zero) then
     ! compute norm of A
     anorm = MAX(abs(D(1))+abs(E(2)),abs(D(n))+abs(E(n)))
     do i = 2, n-1
        anorm = MAX(anorm,abs(E(i))+abs(D(i))+abs(E(i+1)))
     end do
     if(anorm .eq. zero) anorm = one
  end if
  ! compute norms of residual and eigenvector
  xnorm = abs(X(1)) + abs(X(n))
  rnorm = abs((D(1)-EVAL)*X(1) + E(2)*X(2)) + abs((D(n)-EVAL)*X(n) + E(n)*X(n-1))
  do i = 2, n-1
     xnorm = xnorm + abs(X(i))
     rnorm = rnorm + abs(E(i)*X(i-1) + (D(i)-EVAL)*X(i) + E(i+1)*X(i+1))
  end do
  ESTPI1 = rnorm / (EPSLON(size)*anorm*xnorm)
  return
  end function estpi1


  real(chm_real) function epslon(X)
  !
  ! estimate unit round-off in quantities of size X.
  !
  ! Note: this routine should function properly on all systems satisfying the
  !       following two assumpltions:
  !       1. the base used in representing floating point numbers is not a power of three.
  !       2. the quantity "A" in statement 10 is represented to the accuracy used in
  !          floating point variables that are stored in memory.
  !       The do-loop is intened to force optimizing compliers to generate code satisfying
  !       assumption 2.  Under these assumptions, it should be true that:
  !       A    is not exactly equal to four/thirds,
  !       B    has a zero for its last bit or digit,
  !       C    is not exactly equal to one,
  !       EPS  measures the separation of 1.0 from the next larger floating point number.
  !
  ! This verion dated 4/6/83.
  !
  implicit none
  real(chm_real):: X

  ! local variables
  real(chm_real):: B,C
  real(chm_real),parameter :: A=FOUR/THREE
  logical, save :: q_first=.true.
  real(chm_real),save :: EPS=one

  if(q_first) then
     ! A = FOUR/THREE
     do
        B = A - ONE
        eps = abs(b+b+b-one)
        if(eps > zero) exit
        !   C = B + B + B
        !   EPS = ABS(C-ONE)
        !   IF (EPS .EQ. ZERO) cycle
        !   exit
     end do
     q_first=.false. ! eps is determined.
  end if
  EPSLON = EPS*ABS(X)
  return
  end function epslon

! moved to dblas.f
!     real(chm_real) function dnrm2_mn ( n, dx, incx)
!     !
!     ! euclidean norm of the n-vector stored in dx() with storage increment
!     ! incx.
!     ! if    n .le. 0 return with result = 0.
!     ! if n .ge. 1 then incx must be .ge. 1
!     !
!     ! DNRM2_mn := sqrt( x'*x )
!
!     integer :: incx, ix, n, icnt
!     real(chm_real):: dx(*), sum, xmax
!
!     ! first check.
!     if(n .le. 0 .or. incx.le.0) then
!        dnrm2_mn  = zero
!     else if(n.eq.1) then
!        dnrm2_mn  = dabs(dx(1))
!     else
!        xmax  = zero
!        sum   = one
!        do ix = 1, 1+(n-1)*incx, incx
!           if(dx(ix).ne.zero) then
!              absxi = dabs(dx(ix))
!              if(xmax.lt.absxi) then
!                 sum = one + sum*(xmax/absxi)**2
!                 xmax= absxi
!              else
!                 sum = sum + (absxi/xmax)**2
!              end if
!           end if
!         end do
!         dnrm2_mn = xmax * dSQRT(sum)
!     end if
!     return
!     end function dnrm2_mn
  !========================= end of Private ===========================!
  !====================================================================!

#endif /*mndo97*/
end module qm1_diagonalization
