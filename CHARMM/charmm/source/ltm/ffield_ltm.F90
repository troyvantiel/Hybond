module ffieldm
  use chm_kinds
  use dimens_fcm
  implicit none
  
  character(len=8) :: FFIELD_NAME(3)
  integer FFIELD ! force field type
  integer,parameter :: &
       CHARMM   = 1, &
       MMFF     = 2, &
       CFF      = 3, &
       amberffn = 4   !MFC I put the ffn on the end to avoid possible naming conflicts

#if KEY_MMFF==1 || KEY_CFF==1 /*ffield_fcm*/

  !     force fields...

  real(chm_real),allocatable,dimension(:) :: LTSD

  !   LTSD - keeps temporary SD array generated by MMFF;
  !          we need it because MMFF generates SD array
  !          as lower triangle whereas charmm needs
  !          upper triangle.


  ! Keeps track which MMFF parameter files have been read

  integer,parameter :: AnglFile=1,AromFile=2,BndkFile=3,BondFile=4,ChrgFile=5
  integer,parameter :: DefiFile=6,DfsbFile=7,HdefFile=8,OoplFile=9,PbciFile=10
  integer,parameter :: PropFile=11,StbnFile=12,SuppFile=13
  integer,parameter :: SymbFile=14,TorsFile=15,VdwFile=16
  integer,parameter :: NPFILES=16
  logical not_read(NPFILES)

  ! Parameter files names

  character(len=8) PARNAME(NPFILES)
#endif /* (ffield_fcm)*/

contains
  subroutine ffield_init(ucase)
    use consta
    logical,intent(out) :: ucase

    ffield=charmm
    ffield_name(charmm)='CHARMM'
    ucase=.false.
    ccelec=ccelec_charmm

#if KEY_MMFF==1 /*mmff_init*/
    ffield_name(mmff)='MMFF'
#endif /* (mmff_init)*/

#if KEY_CFF==1 /*cff_init*/
    ffield_name(cff)='CFF'
    UCASE=.TRUE.
#endif /* (cff_init)*/

    return
  end subroutine ffield_init


end module ffieldm

