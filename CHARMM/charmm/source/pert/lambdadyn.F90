module lambdam

  use chm_kinds
  use dimens_fcm
  use block_ltm
  implicit none

integer :: lambdam_dummy_var

#if KEY_BLOCK==1 /*ldm_mod*/

  !> Lambda dynamics.
  !> See block.doc and dynamc.doc for detailed description.
  !>
  !> Changed in 2009:
  !> - l-dynamics keywords in pert/block.src call subroutines in current module.
  !> - l-dynamics variables consolidated into lambda_ltm.src
  !>     - includes former blockappend.fcm (for simulated scaling method)
  !>       and rwlamb.fcm
  !> - l-dynamics variables updated to use dynamic memory allocation
  !>
  !> Multi-Site lambda-dynamics (MSLD) functionality added in 2010.
  !> - Invoked by BLOCK subcommand MSLD
  !> - Requires specifying QLDM THETA in BLOCK
  !> - Required subroutines incorporated into:
  !>     - dynamc/dcntrl.src
  !>     - dynamc/dynamc.src
  !>     - energy/enefscal.src
  !>     - energy/energy.src
  !>     - nbonds/enbaexp.src
  !>     - nbonds/enbfast.src
  !> - Added functionality to process lambda trajectories generated by MSLD \n
  !>   using command: traj lamb \n
  !>   Only accounts for biasing potentials invoked with LDIN.
  !> - Five functional forms of lambda have been implemented (default: FNExp):
  !>     - 2-substituents on each site:
  !>         - sin function (F2SIn) (essentially theta-dynamics) \n
  !>           lam(Site_a,sub_1) = sin(theta(Site_a))^2 \n
  !>           lam(Site_a,sub_2) = 1.0 - sin(theta(Site_a))^2
  !>         - logistic function (F2EXp) \n
  !>           lam(Site_a,sub_1) = exp(theta(Site_a)) / [ 1.0 + exp(theta(Site_a)) ] \n
  !>           lam(Site_a,sub_2) = 1.0 / [ 1.0 + exp(theta(Site_a)) ]
  !>     - N-substituents on each site:
  !>         - normalized sin function (FNSIn) \verbatim
  !> num(Site_a,sub_i) = sin(theta(Site_a,sub_i))^2
  !> lam(Site_a,sub_i) =    num(Site_a,sub_i)
  !>                     -----------------------------
  !>                           ----
  !>                           \
  !>                           /    num(Site_a,sub_j)
  !>                           ----
  !>                           all j \endverbatim
  !>         - normalized exponential (FNEXp) \verbatim
  !> num(Site_a,sub_i) = exp(c*sin(theta(Site_a,sub_i))
  !> lam(Site_a,sub_i) =    num(Site_a,sub_i)
  !>                     -----------------------------
  !>                           ----
  !>                           \
  !>                           /    num(Site_a,sub_j)
  !>                           ----
  !>                           all j \endverbatim
  !>         - fixed lambda (FFIX)
  !> - All functional forms of lambda are compatible with biasing potentials (lambdaF)
  !>            invoked with LDIN, LDBI, and LDBV.
  !>
  !> \author Jennifer L. Knight
  !> \author Charles L. Brooks III

  integer, save :: lstrt = 2

  ! Note that lambda-dynamics is implemented as a sub-command under the
  ! BLOCK command
  !
  ! Common for lambda dynamics method used in free energy calculations
  !
  !     QLDM      whether L-dynamics is in use
  !     QLDB      if biasing potentials are in use
  !     QNOBO     whether no-bond is in use
  !     QNOAN     whether no-angle is in use
  !     BIXLAM    coupling coefficent (lambdas) for each interaction
  !     BIVLAM    velocity of coefficent (lambdas) for each interaction
  !     BIMLAM    mass of coefficent (lambdas) for each interaction
  !     BIELAM    reference state energy for each interaction
  !     BIFLAM    force on coefficent (lambdas) for each interaction
  !     LAGMUL    lagrange multiplier for solving forces on lambdas
  ! clb3 changed
  !     BXLCOMP   array for integration of lambda variable dynamics (from dcntrl)
  !     RNORMXL   array for normalization of lambda during dynamics (from dcntrl)
  !     ********* biasing potential variables *******************
  !     IRREUP    equilibrium distances of upper-bound biasing potential
  !     IRRLOW    equilibrium distances of lower-bound biasing potential
  !     IKBIAS    equilibrium force constants of biasing potential
  !     IPBIAS    integer power of biasing potential
  !     IBCLAS    which class of biasing potentials are being used
  !     IBVIDI    first of a pair of lambdas with biasing potential
  !     IBVIDJ    second of a pair of lambdas with biasing potential
  !     NBIASV    total # of biasing potential
  !
  !     LSTRT     integer : THE BLOCK NUMBER of FIRST LIGAND (default : 2)
  !
  !     ILALDM    INTERACT with langevine heatbath which is the same as
  !               atoms' heatbath
  !     BIBLAM    ???
  !     IGAMMALD  ???
  !     ITEMPLD   FREQUENCY OF WRITING TEMPERATURE OF LAMBDA
  !     TBLD      temperature for lambda only
  !
  !     RSTP      whether restraining potential is in use
  !     NRST      type of restraining potential (1 ~ 3)
  !     ENVDX     additional terms for restraining potential (X)
  !     ENVDY     additional terms for restraining potential (Y)
  !     ENVDZ     additional terms for restraining potential (Z)
  !     BIPTNLAM  array giving the potential for each interaction
  !     BFRST     additional restraining potential
  !     LMDCOEF   real(chm_real) variable ; coefficient of the restraining potential
  !
  ! LMC
  !     QLMC      whether  hybrid MC/MD  is on or not
  !     MCRST     logical ; Ignore the effects of time dependent external force
  !                             MC/MD or lambda-dynamics by P. Kollman
  !     MCTEMP    Temperature for hybrid MC/MD
  !     IMC       integer ; every "IMC" step, CHARMM have a try of MC step.
  !
  !     MCMAX     MC/MD, coefficeinet of dominant ligand
  !     MCMIN     MC/MD, coefficeinet of non-dominant ligands
  !
  !     QMCIN     whether intermediate states are used in MC/MD or not
  !     NMCST     the number of states in MC/MD (only used if QMCIN)
  !     ISTLIG    number of ligands pair in MC/MD (only used if QMCIN)
  !     LMCST     lambda vaules of ligand pair in MC/MD (only used if QMCIN)
  !     MCDIV     logical ; discotinous movement of lambda in MC/MD
  !     STEPMC    real(chm_real)  : one step size in lambda square space in MC/MD
  !     DELTAE    real(chm_real) : value of deltae during MC steps
  !     BETAMC    real(chm_real) : value of betamc during MC steps

  !ss For simulated scaling (SS)
  !ss     QMCFR     Logical for turning on SS
  !ss     MCEXFR    Integer, frequency (time steps) to update probability in each lambda grid
  !ss     MCPRO     accumulated probablity
  !ss     MCCOUNT   lambda distribution
  !ss     MCBOXES   Integer, number of lambda grids
  !ss     MCLAMD    value of lambda at each grid
  !ss     WANGFI    Real, initial Wang-Landau modification factor (f factor)
  !ss     WANGFF    Real, final f factor
  !ss     WANGFLAT  Real, *100 percentage to judge flatness
  !ss     WANGF     Real, current f factor
  !cb3    wangstay  Integer, variable used between ldm_prop1_dynamc and 
  !cb3              ldm_prop2_dynamc

  real(chm_real),save :: lagmul
  real(chm_real),save :: lmdcoef
  real(chm_real),save :: tbld
  real(chm_real),save :: mctemp, mcmax, mcmin, stepmc, deltae, betamc
  real(chm_real),save :: wangfi, wangff, wangflat, wangf

  real(chm_real),allocatable,dimension(:),save :: ibvcrrt
  real(chm_real),allocatable,dimension(:),save :: &
          bixlam, bivlam, bimlam, bielam, biflam, bldold, BIGLAM, BIRLAM !GG pH-REX CPHMD
  real(chm_real),allocatable,dimension(:),save :: bxlcomp, rnormxl
  character(len=4),allocatable,dimension(:),save :: biilam !GG pH-REX CPHMD
  real(chm_real),allocatable,dimension(:,:),save :: &
          bielamtemp !GG Temp 2D array to hold pH-dependent biases for pH-REX CPHMD
  real(chm_real),allocatable,dimension(:),save:: irreup, irrlow, ikbias
  real(chm_real),allocatable,dimension(:),save :: igammald
  real(chm_real),allocatable,dimension(:),save :: biblam
  real(chm_real),allocatable,dimension(:),save :: &
       envdx, envdy, envdz, biptnlam, bfrst
  real(chm_real),allocatable,dimension(:),save :: lmcst
  real(chm_real),allocatable,dimension(:),save :: lmcktemp
  real(chm_real),allocatable,dimension(:),save :: mcpro, mclamd

  integer,allocatable,dimension(:),save:: ipbias
  integer,allocatable,dimension(:),save:: ibclas, ibvidi, ibvidj
  integer,allocatable,dimension(:),save :: istlig
  integer,allocatable,dimension(:),save :: mccount

  integer,save:: nbiasv
  integer,save :: nrst
  integer,save :: imc, imcs
  integer,save :: mcstep, nmcst
  integer,save :: mcexfr, mcboxes
  integer, save :: wangstay

  Logical,save :: ILALDM
  Logical,save :: rstp
  Logical,save :: Qldm, Qldb
  Logical,save :: Qlmc, Qmcin, MCRST, MCDIV
  Logical,save :: Qmcfr
  Logical,save :: QMSPHMD         !GG Flag to enable MSLD-based CPHMD
  Logical,save :: QTHEOLD
  Logical,save :: QNORAND

  !
  ! Appended for block interaction scheme used in free energy calculations
  !
  !     QADIN    flag for using adaptive integration method in LMC
  !     AVEDVDL  real array for dvdl at each lambda
  !     AVESTEP  number of steps used for dvdl average
  !ss   IUNWRFR   Integer, output unit for free energy

  real(chm_real),dimension(128),save :: avedvdl
  integer,dimension(128),save :: avestep
  integer,save :: iunwrfr    ! Css for SS
  Logical,save :: Qadin

  !     Variables for theta-dynamics
  !     QTHETADM flag for theta-dynamics
  !     THETA    lambda=sin(theta)**2
  !     THETAV   velocity of theta
  !     THETAM   mass of theta
  !     THETAF   force of theta
  !     THETABIB friction coefficient of theta
  !     GAMMATHETA GAMMA for Langevin dynamics

  real(chm_real),save:: THETA, THETAV, THETAM, THETAF, THETABIB
  real(chm_real), dimension(4),save :: gammatheta
  Logical,save :: Qthetadm

  integer,save :: NSAVL, IUNLDM, NTITLL, MAXTLD
  integer,save :: ILAPOT, ILAF, IRESD, ITEMPLD, NTEMPLD
  character(len=80),dimension(32),save:: titlel

! variables added for Multi-Site lambda-dynamics
!     QMLD     logical variable stating whether Multi-site L-dynamics is in use
!     NSITEMLD integer for total number of Sites in Multi-site L-dynamics
!     ISITEMLD dimensions of each Site in Multi-site L-dynamics
!     IQLDM_SOFTCORE whether to use Hayes et al JPC B (2017) soft cores - domdec only

  integer,save :: nsitemld, out_nsitemld, out_nblock
  integer,allocatable,dimension(:),save :: isitemld, out_firstisitemld, out_isitemld
  logical,allocatable,dimension(:,:),save :: blckmask
  integer,allocatable,dimension(:), save :: mldbondc, mldangc, mlddihc, mldimpc, &
     mldcmapc, mldureyc, mldnbc
  integer,allocatable,dimension(:), save :: mldbondi, mldangi, mlddihi, mldimpi, &
     mldcmapi, mldureyi, mldnbi
  integer,allocatable,dimension(:), save :: mldbondj, mldangj, mlddihj, mldimpj, &
     mldcmapj, mldureyj, mldnbj
  integer,allocatable,dimension(:), save :: mldcmapk
  integer,allocatable,dimension(:), save :: mldbonds, mldangs, mlddihs, mldimps, &
     mldcmaps, mldureys, mldnbs
  real(chm_real),allocatable,dimension(:,:),save :: fullblcoep
  real(chm_real),allocatable,dimension(:),save :: biflam2, bielam2
  real(chm_real),allocatable,dimension(:),save :: exp_table
  real(chm_real), save :: mldpe, mldke
  real(chm_real), save :: lamlimit = 0.001
  Logical,save :: Qmld
  Logical,save :: Qldm_ureybr
  integer,save :: iqldm_softcore
  integer,save :: iqldm_pme
  logical,save :: qldm_scalecons
  !     iblcks    the block number of each atom that is constrained using qldm_scalecons
  integer, allocatable, dimension(:) :: iblcks
  ! soft bond setup
  logical,save :: qsobo
  integer,save :: nsobo
  integer,allocatable,dimension(:),save :: soboi, soboj
  real(chm_real),save :: soboa, sobob, sobon
  

! Multi-Site lambda-dynamics using QTHETA dynamics
  logical, save :: qflagson
  character(len=4) :: fcnal_form
  integer, allocatable, dimension(:), save :: nsubmld, out_nsubmld
  integer, allocatable, dimension(:,:), save :: blckmld, out_blckmld
  real(chm_real), allocatable, dimension(:,:), save :: thetamld, thetamldold, thetavmld, thetafmld
  real(chm_real), save :: fnexp_factor, bicut, bicut2in
  real(chm_real), allocatable, dimension(:), save :: fnexp_factors
  real(chm_real) :: AN1REF, GN1REF, CN3REF, UN3REF, TN3REF, PN3REF    !GG MSLD pH-REX compatibility
  real(chm_real) :: ASPREF, GLUREF, LYSREF, HSEREF, HSDREF, CYTU, ADEU   !GG MSLD pH-REX compatibility
  real(chm_real) :: A111BIAS, A113BIAS, C111BIAS, C113BIAS            !GG MSLD pH-REX compatibility
  real(chm_real) :: A121BIAS, C121BIAS, ADEUBIAS, CYTUBIAS
  real(chm_real) :: ASP1BIAS, GLU1BIAS, LYS1BIAS
  real(chm_real) :: HSE1BIAS, HSD1BIAS, HSE2BIAS, HSD2BIAS            !GG MSLD pH-REX compatibility
  real(chm_real) :: PHVAL, PHTEMP, SPHVAL, MPHVAL, DPHVAL             !GG MSLD pH-REX compatibility
  real(chm_real) :: RLAMB0, REFBIAS, REFPKA

  !==========================================================================
contains
  subroutine ldm_init
    qldm = .false.
    qldb = .false.
    QMSPHMD = .FALSE.         ! GG Turn of PHMD by default
    nsavl = 0
    iunldm = -1
    qlmc = .false.
    mcdiv = .false.
    qmcin = .false.
    qmcfr=.false.              ! ss wy080131
    tbld =0.0
    lstrt = 2
    ilapot = 0
    rstp = .false.
    nrst = 0
    ilaf = 0
    iqldm_softcore = 0
    iqldm_pme = 0
    qldm_scalecons = .false.
    qsobo = .false.
    nsobo = 0
    return
  end subroutine ldm_init

  !==========================================================================
  !==========================================================================
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !    SUBROUTINES FOR SINGLE-SITE LDM from pert/block.src
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!> Allocates memory for QLDM if not already allocated.
!> Invoked after BLOCK command is read.
  subroutine ldm_blockin(nblock,ninter,nreplica)

    use memory

    implicit none
    integer, intent(in) :: nblock, ninter
    integer, intent(in) :: nreplica           !GG

    if(.not. qldm) then
       call chmalloc('lambda_ltm.src','ldm_blockin','BLDOLD',NBLOCK,crl=BLDOLD)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIXLAM',NBLOCK,crl=BIXLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIVLAM',NBLOCK,crl=BIVLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIMLAM',NBLOCK,crl=BIMLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIELAM',NBLOCK,crl=BIELAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIFLAM',NBLOCK,crl=BIFLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIBLAM',NBLOCK,crl=BIBLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIPTNLAM',NBLOCK,crl=BIPTNLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BFRST',NBLOCK,crl=BFRST)
       call chmalloc('lambda_ltm.src','ldm_blockin','IBVCRRT',NBLOCK,crl=IBVCRRT)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIILAM',NBLOCK,ch4=BIILAM)                  !GG Array to hold descriptors
       call chmalloc('lambda_ltm.src','ldm_blockin','BIRLAM',NBLOCK,crl=BIRLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIGLAM',NBLOCK,crl=BIGLAM)
       call chmalloc('lambda_ltm.src','ldm_blockin','BIELAMTEMP',NREPLICA,NBLOCK,crl=BIELAMTEMP) !GG Temp 2D array for pH biases (pH-REX)
       ! clb3, variables from dcntrl.src
       call chmalloc('lambda_ltm.src','ldm_blockin','BXLCOMP',NBLOCK,crl=BXLCOMP)
       call chmalloc('lambda_ltm.src','ldm_blockin','RNORMXL',NBLOCK,crl=RNORMXL)
    endif

  end subroutine ldm_blockin

!-----------------------------------------------------------------------
!> Sets up lambda-dynamics and allocates memory for GB arrays.
!> Invoked from BLOCK subcommand QLDM.
!> Required for Multi-Site lambda-dynamics.
  subroutine ldm_setup(nblock,comlyn,comlen,igentype,gb_lamb,gbldm)

    use memory
    use psf, only : natom
    use string

    implicit none
    integer, intent(in) :: nblock
    integer, intent(in) :: igentype
    real(chm_real), allocatable, dimension(:), intent(out) :: gb_lamb, gbldm
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    QLDM=.TRUE.
    QLMC=.FALSE.

    IF (IGenType .EQ. 1) THEN
       call chmalloc('lambda_ltm.src','ldm_setup','GB_LAMB',NATOM*NBLOCK,crl=GB_LAMB)
       call chmalloc('lambda_ltm.src','ldm_setup','GBLDM',NBLOCK,crl=GBLDM)
    ENDIF

    QTHETADM = INDXA(COMLYN,COMLEN,'THET') .GT. 0 !New THETA-DYNAMICS

  END subroutine ldm_setup

!-----------------------------------------------------------------------
!> Sets up langevin dynamics for lambda-dynamics.
!> Invoked by BLOCK subcommand LANG.
  subroutine ldm_lang(nblock,comlyn,comlen)

    use memory
    use number
    use string

    implicit none
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(in) :: COMLEN
    INTEGER, intent(in) :: nblock

    if (ilaldm) call chmdealloc('lambda_ltm.src','ldm_lang','IGAMMALD',4*NBLOCK,crl=IGAMMALD)
    ILALDM = .TRUE.
    TBLD = GTRMF(COMLYN,COMLEN,'TEMP',ZERO) !GG Assign temperature for langevin bath
    call chmalloc('lambda_ltm.src','ldm_lang','IGAMMALD',4*NBLOCK,crl=IGAMMALD)

  END subroutine ldm_lang

!-----------------------------------------------------------------------
!> Assigns unit number and print frequency for output of lambda values.
!> Invoked by BLOCK subcommand LDWR.
  subroutine ldm_write(comlyn,comlen)

    use string

    implicit none
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    IUNLDM=GTRMI(COMLYN,COMLEN,'IUNL',IUNLDM)
    NSAVL=GTRMI(COMLYN,COMLEN,'NSAVL',NSAVL)

  END subroutine ldm_write

!-----------------------------------------------------------------------
!> Turns msld soft cores with domdec on or off. (Not implemented outside domdec)
   subroutine ldm_scmsld_setup(comlyn,comlen)
      use stream
      use string
      implicit none
      character(len=*), intent(inout) :: comlyn
      integer, intent(inout) :: comlen
      
      if (INDXA(COMLYN,COMLEN,'ON').gt.0) then
         if( prnlev >= 2 ) then
            write(outu,'(a)') 'Turning on MSLD soft cores'
            write(outu,'(a)') 'Warning, soft cores only work with domdec'
            write(outu,'(a)') 'See Hayes et al JPC B (2017) for functional form'
            write(outu,'(a)') ''
         endif
         iqldm_softcore = 1
      elseif (INDXA(COMLYN,COMLEN,'W14').gt.0) then
         if( prnlev >= 2 ) then
            write(outu,'(a)') 'Turning on MSLD soft cores'
            write(outu,'(a)') 'Applying MSLD soft cores to nonbonded and 1-4 interactions'
            write(outu,'(a)') 'Warning, soft cores only work with domdec'
            write(outu,'(a)') 'See Hayes et al JPC B (2017) for functional form'
            write(outu,'(a)') ''
         endif
         iqldm_softcore = 2
      else
         if( prnlev >= 2 ) then
            write(outu,'(a)') 'Turning off MSLD soft cores'
            write(outu,'(a)') ''
         endif
         iqldm_softcore = 0
      endif
   end subroutine ldm_scmsld_setup

!-----------------------------------------------------------------------
!> Enable or disable pme with msld with domdec. (Not implemented outside domdec)
   subroutine ldm_pmemsld_setup(comlyn,comlen)
      use stream
      use string
      implicit none
      character(len=*), intent(inout) :: comlyn
      integer, intent(inout) :: comlen
      
      if (INDXA(COMLYN,COMLEN,'ON').gt.0) then
         iqldm_pme = 1
      else if (INDXA(COMLYN,COMLEN,'EX').gt.0) then
         iqldm_pme = 2
      else if (INDXA(COMLYN,COMLEN,'NN').gt.0) then
         iqldm_pme = 3
      else
         iqldm_pme = 0
      endif

      if( prnlev >= 2 ) then
         if (iqldm_pme.eq.0) then
            write(outu,'(a)') 'Disabling PME with MSLD'
            write(outu,'(a)') ''
         else
            write(outu,'(a)') 'Enabling PME with MSLD'
            write(outu,'(a)') 'Warning, only works with domdec'
            write(outu,'(a)') 'See Huang, Chen, Wallace, and Shen, JCTC (2016) for a description'
            write(outu,'(a)') ''
            if (iqldm_pme.eq.2) then
               write(outu,'(a)') 'Using second PME exclusions strategy.'
               write(outu,'(a)') ''
            else if (iqldm_pme.eq.3) then
               write(outu,'(a)') 'Using third PME exclusions strategy. Only excludes nearest neighbor image'
               write(outu,'(a)') ''
            else
               write(outu,'(a)') 'Using first PME exclusions strategy. Second strategy may give lower barriers'
               write(outu,'(a)') ''
            endif
         endif
      endif
   end subroutine ldm_pmemsld_setup

!-----------------------------------------------------------------------
!> Turns msld soft cores with domdec on or off. (Not implemented outside domdec)
   subroutine ldm_scatmsld_setup(comlyn,comlen)
      use memory
      use stream
      use string
      implicit none
      character(len=*), intent(inout) :: comlyn
      integer, intent(inout) :: comlen
      
      if (INDXA(COMLYN,COMLEN,'ON').gt.0) then
         if( prnlev >= 2 ) then
            write(outu,'(a)') 'Turning on MSLD scaling of constrained atoms'
            write(outu,'(a)') 'Constraints must be set up separately'
            write(outu,'(a)') 'Warning, only works with domdec'
            write(outu,'(a)') ''
         endif
         if (.not. qldm_scalecons) then
            call chmalloc('lambda_ltm.src','ldm_scatmsld_setup','iblcks',maxaim,intg=iblcks)
         endif
         iblcks = 1
         qldm_scalecons = .true.
      else
         if( prnlev >= 2 ) then
            write(outu,'(a)') 'Turning off MSLD scaling of constrained atoms'
            write(outu,'(a)') ''
         endif
         if (qldm_scalecons) then
            call chmdealloc('lambda_ltm.src','ldm_scatmsld_setup','iblcks',maxaim,intg=iblcks)
         endif
         qldm_scalecons = .false.
      endif
   end subroutine ldm_scatmsld_setup

  !---------------------------------------------------------------------------
  subroutine ldm_call_catsmsld_setup(comlyn,comlen)
    !         invoked by BLOCK subcommand "CATS"
    !---------------------------------------------------------------------------
  use chm_kinds
  use memory
  use stream
  use string
  use psf, only : natom
  ! use block_fcm, only : blasgn ! Circular dependency, use local msld_blasgn copy

    implicit none
    character(len=*), intent(inout) :: comlyn
    integer, intent(inout) :: comlen
    integer :: i
    integer, allocatable, dimension(:) :: itemp

    !     Procedure ASSIGN-A-BLOCK
    if (.not. qldm_scalecons) then
       CALL WRNDIE(-5,'<BLOCK>', &
            'Failed attempt to scale atoms.  Data structure iblcks not allocated.  Call "SCAT ON" before "CATS".')
    endif
    I=NEXTI(COMLYN,COMLEN)
    IF (I  <=  NBLOCK) THEN
       call chmalloc('block_ltm.src','BLOCK','ITEMP',NATOM,intg=ITEMP)
       CALL msld_blasgn(COMLYN,COMLEN,ITEMP,NATOM,IBLCKS,I)
       call chmdealloc('block_ltm.src','BLOCK','ITEMP',NATOM,intg=ITEMP)
       IF(PRNLEV >= 2) WRITE(OUTU,30) I
30     FORMAT(' The selected atoms have been designated as constrained in block', I4)
    ELSE
       CALL WRNDIE(-3,'<BLOCK>', &
            'Failed attempt to scale atoms.  Block number too high.')
    ENDIF

  END subroutine ldm_call_catsmsld_setup

  !-----------------------------------------------------------------------
  SUBROUTINE msld_blasgn(COMLYN,COMLEN,ITEMP,NATOM,IBLOCK,INDEX)
    !     THIS ROUTINE HANDLES THE SELECTION OF A SET OF ATOMS TO BE
    !     ASSIGNED AS BELONGING TO A SINGLE BLOCK; THAT BLOCK IS IDENTIFIED
    !     BY INDEX.
    !
    !yw...11-Aug-93, moved out of BLOCK code as it is used in other modules.
    !rlh..2018-07-25, copied blasgn from module block_fcm to remove circular
    !                 dependency
    !-----------------------------------------------------------------------
    use chm_kinds
    use dimens_fcm
    use coord
    use select
    use stream
    implicit none
    INTEGER ITEMP(*), IBLOCK(*)
    INTEGER NATOM, COMLEN, INDEX
    CHARACTER(len=*) COMLYN
    !     LOCAL
    INTEGER I
    !
    !     BEGIN
    CALL SELCTA(COMLYN,COMLEN,ITEMP,X,Y,Z,WMAIN,.TRUE.)
    DO I=1, NATOM
       IF (ITEMP(I)  ==  1) THEN
          IF (IBLOCK(I) /= 1 .AND. WRNLEV >= 2) WRITE(OUTU,20) &
               I, IBLOCK(I), INDEX
          IBLOCK(I)=INDEX
       ENDIF
    ENDDO
20  FORMAT('WARNING: Atom number ', I5, &
         ' has been identified as restrained in block',I4,' to block',I4,'.')

  END subroutine msld_blasgn

    !---------------------------------------------------------------------------
  subroutine ldm_nsoftbond(comlyn,comlen)
    !         invoked by BLOCK subcommand "NSOB"
    !---------------------------------------------------------------------------
    use memory
    use stream
    use string

    implicit none
    character(len=*), intent(inout) :: comlyn
    integer, intent(inout) :: comlen

    if(qsobo) then
       if(nsobo.gt.0) then
          call chmdealloc('lambda_ltm.src','ldm_softbond','soboi',nsobo,intg=soboi)
          call chmdealloc('lambda_ltm.src','ldm_softbond','soboj',nsobo,intg=soboj)
       endif
       qsobo=.false.
       nsobo=0
    endif

    nsobo = 0
    nsobo=nexti(comlyn,comlen)   ! read in new number of soft bonds
    if (prnlev >= 2) WRITE(OUTU,55) nsobo
55  FORMAT(' Total No. of soft bonds is ', I4)

    if (nsobo .gt. 0) then   ! allocate arrays for soft bonds
       if( prnlev >= 2 ) then
          write(outu,'(a)') 'Turning on MSLD soft bonds'
          write(outu,'(a)') 'Set up soft bonds with SOBO'
          write(outu,'(a)') 'Warning, only works with domdec'
          write(outu,'(a)') ''
       endif
       call chmalloc('lambda_ltm.src','ldm_softbond','soboi',nsobo,intg=soboi)
       call chmalloc('lambda_ltm.src','ldm_softbond','soboj',nsobo,intg=soboj)

       soboi=0
       soboj=0
       soboa=1 ! [Angstrom] - saturation radius of soft bond at lambda=0
       sobon=1 ! [dimensionless] - exponent of lambda scaling for soft bond
       sobob=1 ! [dimensionless] - exponent of lambda scaling for bonds and urey bradley specifically

       soboa = gtrmf(comlyn,comlen,'RALF',soboa) ! Last argument is default
       sobon = gtrmf(comlyn,comlen,'LEXP',sobon) ! Last argument is default
       sobob = gtrmf(comlyn,comlen,'BLEX',sobon) ! Default to match sobon

       ! Convert to ra^-2 so there's less multiplication and division in kernels
       if (soboa.le.0) then
          soboa=0 ! Use 0 or negative number to get infinity
       else
          soboa = 1 / (soboa*soboa)
       endif

       qsobo = .true.
    endif

  end subroutine ldm_nsoftbond

    !---------------------------------------------------------------------------
  subroutine ldm_softbond(comlyn,comlen)
    !         invoked by BLOCK subcommand "SOBO"
    !---------------------------------------------------------------------------
    use memory
    use stream
    use string
    use psf, only : natom
    use coord
    use select

    implicit none
    character(len=*), intent(inout) :: comlyn
    integer, intent(inout) :: comlen

    integer :: i,j,count
    integer, allocatable, dimension(:) :: itemp

    i = nexti(comlyn,comlen)
    if (qsobo .and. i.gt.0 .and. i.le.nsobo) then
       call chmalloc('block_ltm.src','BLOCK','ITEMP',natom,intg=itemp)

       count = 0
       call selcta(comlyn,comlen,itemp,x,y,z,wmain,.true.)
       do j=1, natom
          if (itemp(j)  ==  1) then
             soboi(i) = j
             count = count+1
          endif
       enddo
       if (count .ne. 1) then
          call wrndie(-3,'<BLOCK>', &
             'Wrong number of atoms in first selection for soft bond')
       endif

       count = 0
       call selcta(comlyn,comlen,itemp,x,y,z,wmain,.true.)
       do j=1, natom
          if (itemp(j)  ==  1) then
             soboj(i) = j
             count = count+1
          endif
       enddo
       if (count .ne. 1) then
          call wrndie(-3,'<BLOCK>', &
             'Wrong number of atoms in second selection for soft bond')
       endif

       call chmdealloc('block_ltm.src','BLOCK','ITEMP',natom,intg=itemp)

       IF(PRNLEV >= 2) WRITE(OUTU,30) soboi(i),soboj(i)
30     FORMAT(' The selected pair of atoms have been designated as a soft bond', I4, I4)
    else
       call wrndie(-3,'<BLOCK>', &
            'Failed attempt to add a soft bond. Insufficient number of soft bonds allocated with NSOB')
    endif

  end subroutine ldm_softbond

!-----------------------------------------------------------------------
!> Read the lambda force and save it to a given parameter token
   subroutine ldm_save_biflam(comlyn,comlen)
      use string
      use cmdpar
      implicit none
      character(len=*), intent(inout) :: comlyn
      integer, intent(inout) :: comlen
      integer :: i
      real(chm_real) :: r
      integer :: lentok, lenval
      character(len=mxtlen) :: toktmp
      character(len=mxvlen) :: valtmp
      integer :: ipar
      
      CALL NEXTWD(COMLYN,COMLEN,TOKTMP,MXTLEN,LENTOK)
      CALL TRIMA(COMLYN,COMLEN)

      I = NEXTI(COMLYN,COMLEN)
      r = biflam(i)+biflam2(i)
      call encodf(r,valtmp,mxvlen,lenval)
      ipar = parins(toktmp,lentok,valtmp,lenval)
      if (ipar < 0) then
         call WrnDie(0,'<LAMBDAM>','Failed to install biflam into parameter.')
      endif
   end subroutine ldm_save_biflam

!-----------------------------------------------------------------------
!> Sets up initial lambda values (coefficients and masses).
!> Invoked from BLOCK subcommand LDIN.
!> For use in LMC or LMD (whichever most recently selected).
  subroutine ldm_ldin_setup(nblock,comlyn,comlen)

    use memory
    use number
    use stream
    use string
    use consta !GG
    use parallel !GG

    implicit none

    integer, intent(in) :: nblock
    character(len=*), intent(inout) :: COMLYN
    character(len=6) :: ILAMB0                          !GG New MSLD pH-REX commands added
    INTEGER, intent(inout) :: COMLEN
    integer :: i
    real(chm_real) :: blamb0, xlamb0, vlamb0, mlamb0, elamb0

    IF (NBLOCK .GT. 0 .AND. .NOT.QLMC) QLDM=.TRUE.

    !     Procedure initialize lambda variables
    !     Now we input lambda**2 INSTEAD of lambda itself
    I      = NEXTI(COMLYN,COMLEN) !GG Assign 1st term as "i"
    XLAMB0 = NEXTF(COMLYN,COMLEN) !GG Assign 2nd term as coordinates of lambda**2
    VLAMB0 = NEXTF(COMLYN,COMLEN) !GG Assign 3rd term as velocity of lambda
    MLAMB0 = NEXTF(COMLYN,COMLEN) !GG Assign 4th term as mass of lambda
    ELAMB0 = NEXTF(COMLYN,COMLEN) !GG Assign 5th term as bias on lambda

    IF(QTHETADM) THEN     !New THETA-DYNAMICS
       THETA=asin(sqrt(XLAMB0))
       THETAV=VLAMB0
       THETAM=MLAMB0
       THETAF=0.0
    ENDIF                 !New THETA-DYNAMICS

    IF(ILALDM) THEN
       BLAMB0 = NEXTF(COMLYN,COMLEN)
       IF (BLAMB0 .LE. ZERO) THEN
          BLAMB0 = 50.d0
          IF (WRNLEV.GE.2) WRITE(OUTU,90)  I, blamb0
90        FORMAT('WARNING: frictional coefficient for', &
               ' lambda ',I4,' is not assigned. change to',F10.5)
       ENDIF
       BIBLAM(I) = BLAMB0
       IF(QTHETADM) THETABIB=BLAMB0 !New THETA-DYNAMICS
       !
       IF(QMSPHMD) THEN
          !GG Assign reference pKa values and Gbias values
          !GG: X111 - Normal CPHMD^MSLD
          !GG: X113 - pH-REX CPHMD^MSLD (slight mod from normal)
          !GG: X12? - Redone parameters using "proper" QM method
          AN1REF = 3.50D0                !GG Ref pKa for N1 of Adenine
          GN1REF = 9.25D0                !GG Ref pKa for N1 of Guanine
          CN3REF = 4.08D0                !GG Ref pKa for N3 of Cytosine
          UN3REF = 9.30D0                !GG Ref pKa for N3 of Uracil
          TN3REF = 9.79D0                !GG Ref pKa for N3 of Thymine
          PN3REF = 9.00D0                !GG Ref pKa for N3 of Pseudouridine
          ASPREF = 4.00D0
          GLUREF = 4.40D0
          LYSREF = 10.40D0
          HSDREF = 6.60D0
          HSEREF = 7.00D0
          A111BIAS = 19.39D0
          A113BIAS = 21.05D0
          A121BIAS = -67.21D0
          C111BIAS = 75.24D0
          C113BIAS = 75.35D0
          C121BIAS = 0.00D0
          ASP1BIAS = 43.80D0
          GLU1BIAS = 46.07D0
          LYS1BIAS = -23.02D0
          HSE1BIAS = -12.10D0
          HSD1BIAS = -3.46D0
          HSE2BIAS = -12.51D0
          HSD2BIAS = -3.87D0
          REFBIAS = 0D0
          REFPKA = 0D0
          !GG: Read in identity code of residue & calculate bias at specific pH condition
          ILAMB0 = NEXTA6(COMLYN,COMLEN) !GG Read in identity of residue
          !GG: 6-byte code of "AXYZ"
          !    where A is type of residue
          !    where X is identity set of residue
          !    where Y is parameter set of residue
          !    where Z is bias set of residue
          IF(ILAMB0 .EQ. 'A111') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-AN1REF)+A111BIAS
          ELSE IF(ILAMB0 .EQ. 'A113') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-AN1REF)+A113BIAS
          ELSE IF(ILAMB0 .EQ. 'A121') THEN
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-AN1REF)+A121BIAS
          ELSE IF(ILAMB0 .EQ. 'C111') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-CN3REF)+C111BIAS
          ELSE IF(ILAMB0 .EQ. 'C113') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-CN3REF)+C113BIAS
          ELSE IF(ILAMB0 .EQ. 'C121') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-CN3REF)+C121BIAS
          !GG: Start of Protein CPHMD
          ELSE IF(ILAMB0 .EQ. 'ASP1') THEN
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-ASPREF)+ASP1BIAS
          ELSE IF(ILAMB0 .EQ. 'GLU1') THEN
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-GLUREF)+GLU1BIAS
          ELSE IF(ILAMB0 .EQ. 'LYS1') THEN
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-LYSREF)+LYS1BIAS
          ELSE IF(ILAMB0 .EQ. 'HSE1') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-HSEREF)+HSE1BIAS
          ELSE IF(ILAMB0 .EQ. 'HSD1') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-HSDREF)+HSD1BIAS
          ELSE IF(ILAMB0 .EQ. 'HSE2') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-HSEREF)+HSE2BIAS
          ELSE IF(ILAMB0 .EQ. 'HSD2') THEN
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-HSDREF)+HSD2BIAS
          !GG: Will use user-specified bias value
          ELSE IF(ILAMB0 .EQ. 'ADEU') THEN
             ADEUBIAS = ELAMB0
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-AN1REF)+ADEUBIAS
          ELSE IF(ILAMB0 .EQ. 'CYTU') THEN
             CYTUBIAS = ELAMB0
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-CN3REF)+CYTUBIAS
          ELSE IF(ILAMB0 .EQ. 'UPOS') THEN
             RLAMB0 = NEXTF(COMLYN,COMLEN) !GG Assign 7th term as the ref pKa (for CPHMD)
             REFBIAS = ELAMB0
             REFPKA = RLAMB0
             ELAMB0 = LOG(TEN)*KBOLTZ*TBLD*(PHVAL-REFPKA)+REFBIAS
          ELSE IF(ILAMB0 .EQ. 'UNEG') THEN
             RLAMB0 = NEXTF(COMLYN,COMLEN) !GG Assign 7th term as the ref pKa (for CPHMD)
             REFBIAS = ELAMB0
             REFPKA = RLAMB0
             ELAMB0 = -LOG(TEN)*KBOLTZ*TBLD*(PHVAL-REFPKA)+REFBIAS
          ENDIF
          if (mynod == 0 ) write(outu,'(a20,f10.6)') 'PHMD flag for Gbias:', ELAMB0
       ENDIF !GG for IF(QMSPHMD) loop
    ElSE
       IF(QMSPHMD) THEN
          CALL WRNDIE(-5,'<LAMBDADYN>', &
          'MSLD CPHMD is currently only implemented in Langevin dynamics!')
       ENDIF !GG for IF(QMSPHMD) loop
    ENDIF

    XLAMB0 = SQRT(XLAMB0)
    !GG Assign lambda variables to BI?LAM arrays
    BIXLAM(I) = XLAMB0
    BIVLAM(I) = VLAMB0
    BIMLAM(I) = MLAMB0
    BIELAM(I) = ELAMB0
    BIILAM(I) = ILAMB0 !GG Identity array to hold 6-byte descriptors of residue
    BIGLAM(I) = REFBIAS !GG: Array to hold reference free energy
    BIRLAM(I) = REFPKA  !GG: Array to hold reference pKa

    !     INITIALIZE FORCES HERE OR LATER IN ENERGY SUBROUTINE
    BIFLAM(I) = ZERO   !GG Set force on lambda to zero (not used in MSLD)

  END subroutine ldm_ldin_setup

!-----------------------------------------------------------------------
!> Sets up pH value in MSLD for CPHMD
  subroutine msld_phmd(comlyn,comlen)

    use memory
    use number
    use stream
    use string

    implicit none

    character(len=*), intent(in) :: COMLYN
    INTEGER, intent(in) :: COMLEN

    QMSPHMD = .TRUE.

    IF(QMSPHMD)THEN
       PHVAL = GTRMF(COMLYN,COMLEN,'PH',SEVEN) !GG Assign pH specified or default to pH 7
    ELSE
       CALL WRNDIE(-5,'<LAMBDADYN>', &
       'PHMD incorrectly setup in BLOCK')
    ENDIF

  END subroutine msld_phmd

!-----------------------------------------------------------------------
!> Prints Gbias values from dcntrl.src
   subroutine print_gbias(nblock, irepdstr)
      use stream, only : outu, prnlev
      implicit none

      integer, intent(in) :: irepdstr, nblock

      integer :: crepdstr, i

      do i=lstrt,nblock     !gg: transfer pH-designed biases to bielam(i) array for each replica
         crepdstr = irepdstr + 1
         bielam(i)=bielamtemp(crepdstr,i)
      enddo
      if( prnlev >= 0 ) then
         write(outu,'(a)') 'CHARMM> Initial Gbias values'
         do i=lstrt,nblock     !gg print out initial gbias values
            write(outu,'(a5,i2,f12.6)') '        Gbias', i, bielam(i)
         enddo
      endif
   end subroutine print_gbias

!-----------------------------------------------------------------------
!> Initialize variables for dynamic integration (from dynamc)
   subroutine ldm_init_dynamc(nblock, finalt, jhstrt, istep, igvopt)
     use consta
     use stream, only : outu, prnlev
     use number
     use clcg_mod,only : random
     use rndnum
     use reawri, only : iseed
     implicit none

     integer, intent(in) :: nblock, igvopt, jhstrt, istep
     real(chm_real), intent(in) :: finalt

     integer :: i, j, ib
     real(chm_real) :: tempxla

     if (qlmc) then
        if(mctemp  <=  zero) mctemp = finalt
        betamc = one / (kboltz*mctemp)
        ! making initial condition for mc/md (generating  randomly)
        if(jhstrt  <  1 .and. igvopt == 2) then
           if(nrst == 2) bixlam(2) = zero
           if(prnlev > 5) &
                write (outu,'(a)')  &
                'Preparing the initial condition for hybrid MC/MD'
           imcs = 1000000

           if(mcdiv)then
              ! intermediate states (all ligands)
              do ib = lstrt, nblock
                 bixlam(ib) = zero
              enddo
              i = int(one/stepmc+0.5)
              do ib = 1, i
                 imcs = 1000000
                 do while(imcs  >  nblock)
                    imcs=int(random(iseed)*float(nblock-lstrt+1))+lstrt
                 enddo
                 bixlam(imcs) = bixlam(imcs) + stepmc
              enddo
              !ss for ss
              if(qmcfr) then
                 j=-1
                 do while(j < 1 .or. j > mcboxes)
                    j=int(random(iseed)*float(mcboxes))
                 enddo
                 bixlam(2)=one-mclamd(j)
                 bixlam(3)=mclamd(j)
                 call loadl(mclamd(j))
              endif
              !ss

              ! check total lambda square
              tempxla = zero
              do ib = lstrt, nblock
                 tempxla = tempxla + bixlam(ib)
              enddo
              if(tempxla < one-tenm5 &
                   .or. tempxla > one+1.d-6)then
                 call wrndie(-1,'<MC/MD>', &
                      'MC/MD condition error:total lambda sqaure not 1')
              endif
              ! change from lambda square to lambda
              do ib = lstrt, nblock
                 bixlam(ib) = sqrt(bixlam(ib))
              enddo

           else if(qmcin)then
              ! intermediate states (up to two ligands)
              do while(imcs  >  nmcst)
                 imcs = int(random(iseed)*float(nmcst) + one)
              enddo
              do ib = lstrt, nblock
                 bixlam(ib) = zero
              enddo
              bixlam(istlig(2*imcs-1))= lmcst(2*imcs-1)
              bixlam(istlig(2*imcs))= lmcst(2*imcs)
           else
              ! no intermadiate states, only one ligand is selected
              do while (imcs  >  nblock)
                 imcs = int(random(iseed)*float(nblock-lstrt+1))  &
                      + lstrt
              enddo
              if (prnlev  >=  2) write(outu,1600) imcs, istep
1600          format(/' DYNAMC>  MC/MD ligand selected',i5,' step',i5/)
              do ib = lstrt, nblock
                 if (ib  ==  imcs) then
                    bixlam(ib) = mcmax
                 else
                    bixlam(ib) = mcmin
                 endif
              enddo
           endif
        endif
        ! when restart, updata imcs
        if(igvopt >= 3)then
           if(qmcin)then
              ! search the pair
              imcs = 1000000
              do i=1,nmcst
                 if((bixlam(istlig(2*i-1)) == lmcst(2*i-1)).and. &
                      (bixlam(istlig(2*i)) == lmcst(2*i))) imcs=i
              enddo
              if(imcs  >  nmcst) then
                 call wrndie(-1,'<MC/MD>', &
                      'The mc pair can not detected in restart')
              endif
           else
              do ib = lstrt, nblock
                 if(bixlam(ib)  ==  mcmax) imcs = ib
              enddo
           endif
        endif
     endif
     !:    set blcoep = lambda*lambda before update the lambdas
     !:    lambda(1) == 1 by the design see block command
     call ldm_init_dynam(nblock)
   end subroutine ldm_init_dynamc

!-----------------------------------------------------------------------
!> Initialize variables for dynamic integration (from dynamvv)
   subroutine ldm_init_dynam(nblock)
     use number
     implicit none

     integer, intent(in) :: nblock
     integer :: i, j
     if(qldm .or. qlmc) then
        if(.not.qmcfr) then ! css for ss
           blcoep(1) = one
           blcoeb(1) = one
           blcoea(1) = one
           blcoed(1) = one
           blcoee(1) = one
           blcoev(1) = one
           do i = lstrt, nblock
              !:          first row elements
              j = 1 + i*(i-1)/2
              blcoep(j) = bixlam(i)*bixlam(i)
              
              if(qthetadm) then                !new theta-dynamics
                 if(i == 2) then                 !new theta-dynamics
                    blcoep(j)=one-(sin(theta))**2  !new theta-dynamics
                 else if (i == 3) then           !new theta-dynamics
                    blcoep(j)=(sin(theta))**2      !new theta-dynamics
                 endif                           !new theta-dynamics
              endif                            !new theta-dynamics
              
              blcoeb(j) = blcoep(j)
              blcoea(j) = blcoep(j)
              blcoed(j) = blcoep(j)
              blcoee(j) = blcoep(j)
              blcoev(j) = blcoep(j)
              !:          diagonal elements
              j = i + i*(i-1)/2
              blcoep(j) = bixlam(i)*bixlam(i)

              if(qthetadm) then                !new theta-dynamics
                 if(i == 2) then                 !new theta-dynamics
                    blcoep(j)=one-(sin(theta))**2  !new theta-dynamics
                 else if (i == 3) then           !new theta-dynamics
                    blcoep(j)=(sin(theta))**2      !new theta-dynamics
                 endif                           !new theta-dynamics
              endif                            !new theta-dynamics

              blcoeb(j) = blcoep(j)
              blcoea(j) = blcoep(j)
              blcoed(j) = blcoep(j)
              blcoee(j) = blcoep(j)
              blcoev(j) = blcoep(j)
           enddo
        endif !css for ss
     end if
   end subroutine ldm_init_dynam

   subroutine ldm_rstp_dynamc(natom, dx, dy, dz, nblock, iblock)
     use number
     use stream
     implicit none

     integer, intent(in) :: natom, nblock, iblock(:)
     real(chm_real), intent(inout) :: dx(:), dy(:), dz(:)

     integer :: i, ii

     ! add the restraining force
     if(nrst == 1)then
        do i = 1, natom
           if (iblock(i) == 1)then
              do ii=lstrt, nblock
                 dx(i)=dx(i)+envdx((ii-2)*natom+i)*lmdcoef &
                      *(one-bixlam(ii)**2)
                 dy(i)=dy(i)+envdy((ii-2)*natom+i)*lmdcoef &
                      *(one-bixlam(ii)**2)
                 dz(i)=dz(i)+envdz((ii-2)*natom+i)*lmdcoef &
                      *(one-bixlam(ii)**2)
              enddo
           else
              dx(i)=dx(i)+lmdcoef*envdx(i) &
                   *(one-bixlam(iblock(i))**2)
              dy(i)=dy(i)+lmdcoef*envdy(i) &
                   *(one-bixlam(iblock(i))**2)
              dz(i)=dz(i)+lmdcoef*envdz(i) &
                   *(one-bixlam(iblock(i))**2)
           endif
        enddo
     else
        do i=1,natom
           if(iblock(i) >= lstrt) then
              dx(i)=dx(i)+lmdcoef*envdx(i) &
                   *(one-bixlam(iblock(i))**2)
              dy(i)=dy(i)+lmdcoef*envdy(i) &
                   *(one-bixlam(iblock(i))**2)
              dz(i)=dz(i)+lmdcoef*envdz(i) &
                   *(one-bixlam(iblock(i))**2)
           endif
        enddo
     endif
   end subroutine ldm_rstp_dynamc
!-----------------------------------------------------------------------
!> Propagation of variables for dynamic integration (from dynamc)
   subroutine ldm_prop1_dynamc(nblock, istep, delta)
     use number
     use clcg_mod,only : random
     use rndnum
     use reawri, only : iseed
     use stream, only : prnlev, outu

     implicit none

     integer, intent(in) :: nblock, istep
     real(chm_real), intent(in) :: delta

     integer :: nblock2, nblock3
     integer :: imcsnew
     integer :: poslambda, poslambdan, itmp, i, j
     integer :: n1, n2, o1, o2, ib, ic, inmc
     real(chm_real) :: lambdacurrent, lambdanext, deltas, delta2
     real(chm_real) :: r, rrr, rt, pn, pc
     real(chm_real) :: tempxla, fact, alpha, rnormc, vnormc
     logical :: accept

     deltas = half * delta * delta
     delta2 = delta * delta
     tempxla = zero
     nblock2 = 2 * nblock
     nblock3 = 3 * nblock
     deltae = zero
     if(qldm) then
        if(qthetadm) then                                  !new theta-dynamics
           tempxla=theta                                    !new theta-dynamics
           if(ilaldm) then                                  !new theta-dynamics
              fact=deltas*gammatheta(3)/thetam              !new theta-dynamics
              alpha=2.0*gammatheta(3)*gammatheta(4)*delta   !new theta-dynamics
              !           update x from t to t + dt                     !new theta-dynamics
              theta=theta+thetav*alpha+thetaf*fact          !new theta-dynamics
           else                                             !new theta-dynamics
              theta=theta+thetav*delta+thetaf*deltas/thetam  !new theta-dynamics
           endif
           !           from leap-frog algorithm, update v from t to t + dt/2
           thetav=(theta-tempxla)/delta                     !new theta-dynamics
        else                                               !new theta-dynamics
           rnormc = zero
           vnormc = zero
           tempxla = zero
           do i = lstrt, nblock
              !           save current lambdas
              bxlcomp(i) = bixlam(i)
              !           update x from t to t + dt
              tempxla = bixlam(i)
              !           taylor's expansion to start the algorithm
              if(ilaldm) then
                 fact=deltas*igammald(i+nblock2)/bimlam(i)
                 alpha=2.0*igammald(i+nblock2)*igammald(i+nblock3)*delta
                 !             update x from t to t + dt
                 bixlam(i)=bixlam(i)+bivlam(i)*alpha+biflam(i)*fact
              else
                 bixlam(i) = bixlam(i) + bivlam(i)*delta + &
                      biflam(i)*deltas/bimlam(i)
              endif
              ibvcrrt(i)=bivlam(i)
              !           from leap-frog algorithm, update v from t to t + dt/2
              bivlam(i) = (bixlam(i) - tempxla)/delta
              !           to renormalize the lambdas to ensure that sum lambdas**2 = 1
              rnormc = rnormc + bixlam(i)*bixlam(i)
              vnormc = vnormc + bivlam(i)*bixlam(i)
              rnormxl(i) = bixlam(i)
           enddo
           !        renormalization
           rnormc = one/sqrt(rnormc)
           do i = lstrt, nblock
              bixlam(i) = bixlam(i)*rnormc
              bivlam(i) = -vnormc*rnormxl(i)*rnormc*rnormc*rnormc  &
                   + bivlam(i)*rnormc
           enddo
        endif                             !new theta-dynamics
     end if

     ! if mc/md is chosen, check if it is time to select another ligand.

     if (qlmc) then

        if (mod(istep,imc)  ==  0) then
           ! intermediate states (all ligands)
           if(mcdiv)then
              !ss for ss
              if(qmcfr) then
                 rrr=one-blcoep(2)
                 do i=1,mcboxes
                    if(abs(rrr-mclamd(i)) < 0.00001) ic=i
                 enddo
                 wangstay=ic
                 pc=mcpro(ic)
              endif
              !ss
              do i=1,mcstep
                 ! select increased ligand
120              imcsnew=int(random(iseed)*float(nblock-lstrt+1))+lstrt
                 if(imcsnew  >  nblock) goto 120

                 if(.not.qmcfr) then ! css for ss
                    if(bixlam(imcsnew) >=  0.99999) goto 120
                 endif ! css for ss

                 ! select decreased ligand
130              imcs = int(random(iseed)*float(nblock-lstrt+1)) + lstrt
                 if(imcs > nblock .or. imcs == imcsnew) goto 130

                 if(.not.qmcfr) then ! css for ss
                    if(bixlam(imcs) <=  1.0d-5) goto 130
                 endif ! css for ss

                 if(qadin) then                                  !new adin begin
                    lambdacurrent=bixlam(3)*bixlam(3)
                    poslambda=int(lambdacurrent/stepmc+0.5)+1
                    avedvdl(poslambda)=(avedvdl(poslambda) &
                         *avestep(poslambda)+(biptnlam(3)-biptnlam(2))) &
                         /(avestep(poslambda)+1.0)
                    avestep(poslambda)=avestep(poslambda)+1

                    if(lambdacurrent <= 1.0d-5) then
                       !lambda=0, must propose larger lambda
                       if(imcsnew < imcs) then
                          itmp=imcsnew
                          imcsnew=imcs
                          imcs=itmp
                       endif
                    else if(lambdacurrent > (1.0-1.0d-5)) then
                       ! lambda=1, must propose smaller lambda
                       if(imcsnew > imcs) then
                          itmp=imcsnew
                          imcsnew=imcs
                          imcs=itmp
                       endif
                    endif

                    if(imcsnew > imcs) then
                       lambdanext=lambdacurrent+stepmc
                    else
                       lambdanext=lambdacurrent-stepmc
                    endif
                    poslambdan=int(lambdanext/stepmc+0.5)+1
                 endif                                            !new adin end

                 ! calculate deltae
                 if(qmcfr) then ! css for ss
                    if(imcsnew == 2)r=-mclamd(ic)+mclamd(ic-1) ! css for ss
                    if(imcsnew == 3)r=mclamd(ic+1)-mclamd(ic) ! css for ss
                    deltae=r*(biflam(3)-biflam(2)) ! css for ss
                 else ! css for ss
                    deltae = stepmc*(biptnlam(imcsnew)-biptnlam(imcs))
                 endif ! css for ss

                 if(qadin) then                                   !new adin begin
                    deltae=deltae-0.5*(avedvdl(poslambda) &
                         +avedvdl(poslambdan))
                 endif                                            !new adin end

                 if(.not. mcrst)then
                    if(nrst  ==  2)then
                       deltae=deltae - lmdcoef*stepmc* &
                            ( bfrst(imcsnew)-bfrst(imcs) )
                    else
                       deltae=deltae - lmdcoef*stepmc* &
                            (biptnlam(imcsnew)-biptnlam(imcs))
                    endif
                 endif
                 !ss for ss
                 if(qmcfr) then
                    inmc=ic+1
                    if(imcsnew == 2) inmc=ic-1
                    if(inmc > mcboxes) then
                       inmc=ic-1
                    else if(inmc < 1) then
                       inmc=ic+1
                    endif

                    pn=mcpro(inmc)

                 endif
                 !ss
                 accept = .false.
                 if ( deltae  <=  zero .and. (.not. qmcfr)) then ! css for ss
                    accept = .true.
                 else
                    if(qmcfr) then  ! css for ss
                       rt=exp(-deltae*betamc)  ! css for ss
                       rt=rt*exp(pc-pn)  ! css for ss
                       accept = (rt  >  random(iseed))  ! css for ss
                    else  ! css for ss
                       accept = (exp(-deltae*betamc)  >  random(iseed))
                    endif  ! css for ss
                 end if

                 ! if the mc move is accepted, add stepmc to imcsnew,
                 ! substract stepmc from imcs
                 ! otherwise, retain
                 if (accept) then
                    if(qmcfr) then ! css for ss
                       call loadl(mclamd(inmc)) ! css for ss
                       bixlam(2)=sqrt(blcoep(2)) ! css for ss
                       bixlam(3)=sqrt(blcoep(4)) ! css for ss
                       ic=inmc
                       wangstay=inmc
                       pc=pn
                    else  ! css for ss
                       bixlam(imcsnew) = sqrt(bixlam(imcsnew)**2+stepmc)
                       if (bixlam(imcs)**2-stepmc  <  0.0) then
                          bixlam(imcs) =0.0
                       else
                          bixlam(imcs) = sqrt(bixlam(imcs)**2-stepmc)
                       end if
                    endif ! css for ss
                 endif
              enddo

              ! if intermediate states are permitted (just only two ligands)
           else if(qmcin)then
              do i=1,mcstep
                 imcsnew = 1000000
                 do while((imcsnew > nmcst) .or. (imcsnew == imcs))
                    imcsnew = int(random(iseed)*float(nmcst) + 1.0)
                 enddo
                 ! calculate de : de = e(new) - e(old)
                 !
                 ! e(new) = lambda^2(new1)*biptnlam(new1)+lambda^2(new2)*biptnlam(new2)
                 !        new1 = istlig(2*imcsnew-1),  new2 = istlig(2*imcsnew)
                 ! e(old) = lambda^2(old1)*biptnlam(old1)+lambda^2(old2)*biptnlam(old2)
                 !        old1 = istlig(2*imcs-1), old2 = istlig(2*imcs)

                 n1 = istlig(2*imcsnew-1)
                 n2 = istlig(2*imcsnew)
                 o1 = istlig(2*imcs-1)
                 o2 = istlig(2*imcs)

                 deltae=biptnlam(n1)*lmcst(2*imcsnew-1)**2 &
                      +biptnlam(n2)*lmcst(2*imcsnew)**2 &
                      -biptnlam(o1)*bixlam(o1)**2 &
                      -biptnlam(o2)*bixlam(o2)**2

                 if(.not. mcrst)then
                    if(nrst  ==  2)then
                       deltae=deltae+ lmdcoef*( &
                            -bfrst(n1)*lmcst(2*imcsnew-1)**2            &
                            -bfrst(n2)*lmcst(2*imcsnew)**2            &
                            +bfrst(o1)*bixlam(o1)**2            &
                            +bfrst(o2)*bixlam(o2)**2)
                    else
                       deltae=deltae+ lmdcoef*( &
                            -biptnlam(n1)*lmcst(2*imcsnew-1)**2            &
                            -biptnlam(n2)*lmcst(2*imcsnew)**2            &
                            +biptnlam(o1)*bixlam(o1)**2            &
                            +biptnlam(o2)*bixlam(o2)**2)
                    endif
                 endif

                 accept = .false.

                 if(deltae  <=  zero) then
                    accept = .true.
                 else
                    accept = (exp(-deltae*betamc)  >  random(iseed))
                 endif

                 if(accept) then
                    do ib = lstrt, nblock
                       bixlam(ib) = 0.0
                    enddo
                    bixlam(istlig(2*imcsnew-1))= lmcst(2*imcsnew-1)
                    bixlam(istlig(2*imcsnew))= lmcst(2*imcsnew)

                    write (*,'(a,i5,a,i5,a,f12.5,a,i7)') &
                         'ldm_prop1_dynamc> accept new=',imcsnew,' old=',imcs, &
                         ' delta-e=',deltae,'step=',istep
                    imcs = imcsnew
                 endif
              enddo
              ! only one dominant ligand
           else
              do i=1,mcstep
                 imcsnew = 1000000
                 do while ((imcsnew  >  nblock).or.(imcsnew  ==  imcs))
                    imcsnew = int(random(iseed)*float(nblock-lstrt+1))  &
                         + lstrt
                 enddo

                 ! evaluate the delta_e = ene(imcsnew) - ene(imcs) here ..

                 deltae=(mcmax**2-mcmin**2)* &
                      (biptnlam(imcsnew)-biptnlam(imcs))
                 if(.not. mcrst)then
                    if(nrst  ==  2)then
                       deltae=deltae -(mcmax**2-mcmin**2)*lmdcoef* &
                            (bfrst(imcsnew)-bfrst(imcs))
                    else
                       deltae=deltae -(mcmax**2-mcmin**2)*lmdcoef* &
                            (biptnlam(imcsnew)-biptnlam(imcs))
                    endif
                 endif

                 accept = .false.
                 if ( deltae  <=  zero) then
                    accept = .true.
                 else
                    accept = (exp(-deltae*betamc)  >  random(iseed))
                 end if
                 ! if the mc move is accepted, assign lambda=1.0 to the new ligand.
                 ! otherwise, retain
                 if (accept) then
                    do ib = lstrt, nblock
                       if (ib  ==  imcsnew) then
                          bixlam(ib) = mcmax
                       else
                          bixlam(ib) = mcmin
                       endif
                    enddo

                    if (prnlev  >=  2)  &
                         write(outu,1610)imcsnew, imcs, deltae
1610                format(/' ldm_prop2_dynamc>  mc/md move accept new=', &
                         i5,' old=',i5,' deltae=',f10.5/) 
                    imcs = imcsnew
                 endif
              enddo
           endif
           !ss for ss
           if(qmcfr) then
              mccount(ic)=mccount(ic)+1
           endif
           !ss
        endif
     endif
     call ldm_init_dynam(nblock)

   end subroutine ldm_prop1_dynamc

!-----------------------------------------------------------------------
!> First propagation of variables for dynamic integration (from dynamcv)
   subroutine ldm_prop2_dynamcv(nblock, delta)
     use number
     implicit none

     integer, intent(in) :: nblock
     real(chm_real), intent(in) :: delta

     integer :: i, j
     real(chm_real) :: rnormc, tempvla, delta2

     delta2 = delta * delta
     rnormc = zero
     do i = lstrt, nblock
        !           save current lambdas for reseting
        bxlcomp(i) = bixlam(i)
        !           update x from t to t + dt
        !           important note: we used bivlam(i) to store the bixlam at t-dt in
        !           verlet dynamics update scheme !!!
        tempvla = bixlam(i)
        bixlam(i) = bixlam(i) + bixlam(i) - bivlam(i) + &
             biflam(i)*delta2/bimlam(i)
        !           update bivlam (oldxlambda) from t-dt to t
        bivlam(i) = tempvla
        rnormc = rnormc + bixlam(i)*bixlam(i)
     enddo
     rnormc = one/sqrt(rnormc)
     do i = lstrt, nblock
        bixlam(i) = bixlam(i)*rnormc
     enddo
     !        update the coef before calling energy
     call ldm_init_dynam(nblock)
   end subroutine ldm_prop2_dynamcv

!> First propagation of variables for dynamic integration (from dynamcv)
   subroutine ldm_prop1_dynamcv(nblock, delta)
     use number
     implicit none

     integer, intent(in) :: nblock
     real(chm_real), intent(in) :: delta

     real(chm_real) :: rnormc, tempvla, deltas
     integer :: i, j

     deltas = half * delta * delta
     rnormc = zero
     do i = lstrt, nblock
        !           save current lambdas
        bxlcomp(i) = bixlam(i)
        !           update x from t to t + dt
        !           important note: we use bivlam(i) to store the bxoldlamb(i) in
        !           verlet dynamics update scheme !!!
        tempvla = bivlam(i)
        bivlam(i) = bixlam(i)
        !           taylor's expansion to start the algorithm
        bixlam(i) = bivlam(i) + tempvla*delta + &
             biflam(i)*deltas/bimlam(i)
        !           to renormalize the lambdas to ensure that sum lambdas = 1
        rnormc = rnormc + bixlam(i)*bixlam(i)
     enddo
     !        renormalization
     !        **:since verlet algorithm doesn't explicitly use velocity
     !           to propagate the dynamics, we didn't renormalize bivlam
     rnormc = one/sqrt(rnormc)
     do i = lstrt, nblock
        bixlam(i) = bixlam(i)*rnormc
     enddo
     !        update the coef before calling energy
     call ldm_init_dynam(nblock)
   end subroutine ldm_prop1_dynamcv

!-----------------------------------------------------------------------
!> First propagation of variables for dynamic integration (from dynamvv)
   subroutine ldm_prop1_dynamvv(nblock, delta)
     use number
     implicit none

     integer, intent(in) :: nblock
     real(chm_real), intent(in) :: delta
     real(chm_real) :: rnormc, deltas

     integer :: i,j, poslambdan

     rnormc = zero
     deltas = half * delta * delta
     do i = lstrt, nblock
        !           save current lambdas
        bxlcomp(i) = bixlam(i)
        !           update v from t to t + dt/2, x from t to t + dt
        bivlam(i) = bivlam(i) + deltas*biflam(i)/bimlam(i)
        bixlam(i) = bixlam(i) + delta*bivlam(i)
        rnormc = rnormc + bixlam(i)*bixlam(i)
        rnormxl(i) = bixlam(i)
     enddo
     !        renormalization
     rnormc = one/sqrt(rnormc)
     do i = lstrt, nblock
        bixlam(i) = bixlam(i)*rnormc
     enddo
     !        update the coef before calling energy
     call ldm_init_dynam(nblock)
   end subroutine ldm_prop1_dynamvv

!-----------------------------------------------------------------------
!> Propagation of variables for dynamic integration (from dynamc)
   subroutine ldm_prop2_dynamc(nblock, istep, delta)
     use number
     use consta
     use clcg_mod,only : random
     use rndnum
     use reawri, only : iseed
     use stream
     implicit none

     integer, intent(in) :: nblock, istep
     real(chm_real), intent(in) :: delta

     integer :: nblock2
     integer :: imcsnew, poslambda, poslambdan
     integer :: n1, n2, o1, o2, i, ib, ic, inmc, j, itmp, k, kk, pc
     real(chm_real) :: frough, facc, rnormc, vnormc, fact, alpha
     real(chm_real) :: lambdacurrent, lambdanext, rt, pn, r
     logical :: accept

      nblock2 = 2 * nblock
     if(qldm) then
        if(qthetadm) then                     !new theta-dynamics
           if(ilaldm) then
              fact=gammatheta(2)                 !new theta-dynamics
              alpha=gammatheta(3)                !new theta-dynamics
              !         update v from t-dt/2 to t + dt/2
              thetav=alpha*thetav+fact*thetaf    !new theta-dynamics
           else
              thetav=thetav+delta*thetaf/thetam  !new theta-dynamics
           endif
           theta=theta+thetav*delta             !new theta-dynamics
        else                                  !new theta-dynamics
           rnormc = zero
           vnormc = zero
           do i = lstrt, nblock
              !           save current lambdas
              bxlcomp(i) = bixlam(i)
              !           save velocty(t-dt/2)
              ibvcrrt(i)=bivlam(i)
              if(ilaldm) then
                 fact=igammald(i+nblock)
                 alpha=igammald(i+nblock2)
                 !             update v from t-dt/2 to t + dt/2
                 bivlam(i)=alpha*bivlam(i)+fact*biflam(i)
              else
                 !           update v from t-dt/2 to t + dt/2
                 bivlam(i) = bivlam(i) + delta*biflam(i)/bimlam(i)
              endif
              !           update x from t to t + dt
              bixlam(i) = bixlam(i) + bivlam(i)*delta
              rnormc = rnormc + bixlam(i)*bixlam(i)
              vnormc = vnormc + bivlam(i)*bixlam(i)
              rnormxl(i) = bixlam(i)
           enddo
           !        renormalization
           rnormc = one/sqrt(rnormc)
           do i = lstrt, nblock
              bixlam(i) = bixlam(i)*rnormc
              bivlam(i) = -vnormc*rnormxl(i)*rnormc*rnormc*rnormc  &
                   +  bivlam(i)*rnormc
           enddo
        endif !new theta-dynamics
     end if

     ! the previous block is done if the mc/md option is not selected
     ! if mc-md is chosen, check if it is time to select another ligand.
     ! in the case of mc-md, lambdas need be output every time a metropolis
     ! selection of the ligands is attempted. so we can use nsavl itself??

     if (qlmc) then

        !  make sure that you have all the ligand-protein (or env??) interactions here


        !ss for ss
        if(qmcfr) then
           if (mod(istep,mcexfr)  ==  0) then
              k=0
              do i=1,mcboxes
                 k=k+mccount(i)
              enddo
              kk=0
              do i=1,mcboxes
                 rt=real(mccount(i))*real(mcboxes)/wangflat
                 if(rt < real(k)) kk=1
              enddo

              frough=-kboltz*mctemp*(mcpro(mcboxes)-mcpro(1))
              facc=frough
              if(mccount(1) > 0 .and. mccount(mcboxes).gt.0) then
                 facc=facc+kboltz*mctemp*log(float(mccount(1))/ &
                      float(mccount(mcboxes)))
              endif
              ! report time step, rough and accurate free energy
              !            and wang-landau modification factor f
              if(iunwrfr > 0)  &
                   write(iunwrfr,739)istep, frough,facc,wangf
739           format(i10,1x,g13.5,1x,g13.5,1x,g13.5)

              if(kk == 0) then
                 if(wangf > wangff) then
                    wangf=sqrt(wangf)
                    do i=1,mcboxes
                       mccount(i)=0
                    enddo
                 else if(wangf > 1.0) then
                    wangf=1.0
                    do i=1,mcboxes
                       mccount(i)=0
                    enddo
                 endif
              endif

              mcpro(wangstay)=mcpro(wangstay)+log(wangf)
           endif
        endif
        !ss

        if (mod(istep,imc)  ==  0) then
           if(mcdiv)then

              !ss for ss
              if(qmcfr) then
                 r=one-blcoep(2)
                 ic=-103
                 do i=1,mcboxes
                    if(abs(r-mclamd(i)) < 0.00001) ic=i
                 enddo
                 if(ic == -103) then
                    if(prnlev > 2) write(outu,838) r
                 endif
                 wangstay=ic
                 pc=mcpro(ic)
              endif
838           format(' *****  warning  ***** lambda = ',g13.5)
              !ss

              ! intermediate states (all ligands)
              do i=1,mcstep
                 ! select increased ligand
220              imcsnew = int(random(iseed)*float(nblock-lstrt+1))  &
                      + lstrt
                 if (imcsnew > nblock) goto 220

                 if(.not.qmcfr) then ! css for ss
                    if(bixlam(imcsnew) >=  0.99999) goto 220
                 endif ! css for ss
                 ! select decreased ligand
230              imcs = int(random(iseed)*float(nblock-lstrt+1)) &
                      + lstrt
                 if (imcs > nblock .or. imcs == imcsnew) goto 230

                 if(.not.qmcfr) then ! css for ss
                    if(bixlam(imcs) <=  0.1d-3) goto 230
                 endif ! css for ss

                 if(qadin) then                                   !new adin begin
                    lambdacurrent=bixlam(3)*bixlam(3)
                    poslambda=int(lambdacurrent/stepmc+half)+1
                    avedvdl(poslambda)=(avedvdl(poslambda) &
                         *avestep(poslambda)+(biptnlam(3)-biptnlam(2))) &
                         /(avestep(poslambda)+one)
                    avestep(poslambda)=avestep(poslambda)+1

                    if(lambdacurrent <= 1.0d-5) then !lambda=0, must propose larger lambda
                       if(imcsnew < imcs) then
                          itmp=imcsnew
                          imcsnew=imcs
                          imcs=itmp
                       endif
                    else if(lambdacurrent > (1.0-1.0d-5)) then
                       ! lambda=1, must propose smaller lambda
                       if(imcsnew > imcs) then
                          itmp=imcsnew
                          imcsnew=imcs
                          imcs=itmp
                       endif
                    endif

                    if(imcsnew > imcs) then
                       lambdanext=lambdacurrent+stepmc
                    else
                       lambdanext=lambdacurrent-stepmc
                    endif
                    poslambdan=int(lambdanext/stepmc+half)+1
                 endif                                   !new adin end


                 ! calculate deltae
                 !ss for ss
                 if(qmcfr) then
                    if(imcsnew == 2) then
                       if(ic == 1) then
                          r=-mclamd(ic)+mclamd(ic+1)
                       else
                          r=-mclamd(ic)+mclamd(ic-1)
                       endif
                    endif

                    if(imcsnew == 3) then
                       if(ic == mcboxes) then
                          r=mclamd(ic-1)-mclamd(ic)
                       else
                          r=mclamd(ic+1)-mclamd(ic)
                       endif
                    endif
                    deltae=r*(biflam(3)-biflam(2))
                 else
                    deltae = stepmc*(biptnlam(imcsnew)-biptnlam(imcs)) ! original
                 endif
                 !ss

                 if(qadin) then                                   !new adin begin
                    deltae=deltae-0.5*(avedvdl(poslambda) &
                         +avedvdl(poslambdan))
                 endif                                   !new adin end

                 !
                 if(.not. mcrst)then
                    if(nrst  ==  2)then
                       deltae=deltae - stepmc*lmdcoef* &
                            (bfrst(imcsnew)-bfrst(imcs))
                    else
                       deltae=deltae -stepmc*lmdcoef* &
                            (biptnlam(imcsnew)-biptnlam(imcs))
                    endif
                 endif

                 !ss for ss
                 if(qmcfr) then
                    inmc=ic+1
                    if(imcsnew == 2) inmc=ic-1
                    if(inmc > mcboxes) then
                       inmc=ic-1
                    else if(inmc < 1) then
                       inmc=ic+1
                    endif
                    pn=mcpro(inmc)
                 endif
                 !ss

                 accept = .false.
                 if ( deltae  <=  zero .and. (.not.qmcfr)) then ! css for ss
                    accept = .true.
                 else
                    if(qmcfr) then ! css for ss
                       rt=exp(-deltae*betamc) ! css for ss
                       rt=rt*exp(pc-pn) ! css for ss
                       accept = (rt  >  random(iseed)) ! css for ss
                    else ! css for ss
                       accept = (exp(-deltae*betamc)  >  random(iseed))
                    endif ! css for ss
                 end if
                 ! if the mc move is accepted, add stepmc to imcsnew,
                 ! substract stepmc from imcs
                 ! otherwise, retain
                 if (accept) then
                    !ss for ss
                    if(qmcfr) then
                       call loadl(mclamd(inmc))
                       bixlam(2)=sqrt(blcoep(2))
                       bixlam(3)=sqrt(blcoep(4))
                       ic=inmc
                       wangstay=ic
                       pc=pn
                    else
                       !ss
                       bixlam(imcsnew) = sqrt(bixlam(imcsnew)**2+stepmc)
                       if (bixlam(imcs)**2-stepmc  <  0.0) then
                          bixlam(imcs) =0.0
                       else
                          bixlam(imcs) = sqrt(bixlam(imcs)**2-stepmc)
                       end if
                    endif ! css for ss
                 endif
              enddo
              ! intermediate states (only two ligands)
           else if(qmcin)then
              do i=1,mcstep
                 imcsnew = 1000000
                 do while((imcsnew > nmcst) .or. (imcsnew == imcs))
                    imcsnew = int(random(iseed)*float(nmcst) + 1.0)
                 enddo
                 ! calculate de : de = e(new) - e(old)
                 ! e(new) = lambda^2(new1)*biptnlam(new1)+lambda^2(new2)*biptnlam(new2)
                 ! e(old) = lambda^2(old1)*biptnlam(old1)+lambda^2(old2)*biptnlam(old2)

                 n1 = istlig(2*imcsnew-1)
                 n2 = istlig(2*imcsnew)
                 o1 = istlig(2*imcs-1)
                 o2 = istlig(2*imcs)
                 ! banba

                 deltae=biptnlam(n1)*lmcst(2*imcsnew-1)**2 &
                      +biptnlam(n2)*lmcst(2*imcsnew)**2 &
                      -biptnlam(o1)*bixlam(o1)**2 &
                      -biptnlam(o2)*bixlam(o2)**2

                 if(.not. mcrst)then
                    if(nrst  ==  2)then
                       deltae=deltae+ lmdcoef*( &
                            -bfrst(n1)*lmcst(2*imcsnew-1)**2            &
                            -bfrst(n2)*lmcst(2*imcsnew)**2            &
                            +bfrst(o1)*bixlam(o1)**2            &
                            +bfrst(o2)*bixlam(o2)**2)
                    else
                       deltae=deltae+ lmdcoef*( &
                            -biptnlam(n1)*lmcst(2*imcsnew-1)**2            &
                            -biptnlam(n2)*lmcst(2*imcsnew)**2            &
                            +biptnlam(o1)*bixlam(o1)**2            &
                            +biptnlam(o2)*bixlam(o2)**2)
                    endif
                 endif
                 ! check whether accept or not
                 accept = .false.
                 if(deltae  <  zero) then
                    accept = .true.
                 else
                    accept = (exp(-deltae*betamc)  >  random(iseed))
                 endif

                 if(accept) then
                    do ib = lstrt, nblock
                       bixlam(ib) = 0.0
                    enddo
                    bixlam(istlig(2*imcsnew-1))= lmcst(2*imcsnew-1)
                    bixlam(istlig(2*imcsnew))= lmcst(2*imcsnew)

                    if (prnlev  >=  2) &
                         write(outu,1610)imcsnew, imcs, deltae
                    imcs = imcsnew
                 endif
              enddo
           else
              ! only one ligand
              do i=1,mcstep
                 imcsnew = 1000000
                 do while ((imcsnew > nblock) .or. (imcsnew == imcs))
                    imcsnew = int(random(iseed) * float(nblock-lstrt+1))  &
                         + lstrt
                 enddo

                 ! evaluate the delta_e = ene(imcsnew) - ene() here ..

                 deltae=(mcmax**2-mcmin**2)*(biptnlam(imcsnew)- &
                      biptnlam(imcs))
                 if(.not. mcrst)then
                    if(nrst  ==  2)then
                       deltae=deltae - (mcmax**2-mcmin**2)*lmdcoef &
                            *(bfrst(imcsnew)-bfrst(imcs))
                    else
                       deltae=deltae -(mcmax**2-mcmin**2)*lmdcoef* &
                            (biptnlam(imcsnew)-biptnlam(imcs))
                    endif
                 endif
                 ! check whether accept or not
                 accept = .false.
                 if ( deltae  <  zero) then
                    accept = .true.
                 else
                    accept = (exp(-deltae*betamc)  >  random(iseed))
                 end if
                 ! if the mc move is accepted, eassign lambda=1.0 to the new ligand.
                 ! otherwise, retain
                 if (accept) then
                    do ib = lstrt, nblock
                       if (ib  ==  imcsnew) then
                          bixlam(ib) = mcmax
                       else
                          bixlam(ib) = mcmin
                       end if
                    enddo
                    ! the new ligand becomes the "old" one.
                    if (prnlev  >=  2) &
                         write(outu,1610)imcsnew, imcs, deltae
1610                format(/' ldm_prop2_dynamc>  mc/md move accept new=', &
                         i5,' old=',i5,' deltae=',f10.5/)
                    imcs = imcsnew
                 endif
              enddo
           endif
           !ss for ss
           if(qmcfr) then
              mccount(ic)=mccount(ic)+1
           endif
           !ss
        endif
     endif
     call ldm_init_dynam(nblock)
   end subroutine ldm_prop2_dynamc


!??????check whetehr rnormc is used before this
!-----------------------------------------------------------------------
!> Second propagation of variables for dynamic integration (from dynamvv)
   subroutine ldm_prop2_dynamvv(nblock, delta)
     use number
     implicit none

     integer, intent(in) :: nblock
     real(chm_real), intent(in) :: delta

     integer :: i,j
     real(chm_real) :: rnormc, vnormc, deltas

     deltas = half * delta * delta
     rnormc = zero
     vnormc = zero
     do i = lstrt, nblock
        !           update v from t + dt/2 to t + dt
        bivlam(i) = bivlam(i) + deltas*biflam(i)/bimlam(i)
        vnormc = vnormc + bivlam(i)*rnormxl(i)
     enddo
     !        renormalization
     ! !!!cb3 - this makes no sense, rnormc^3 and its 0?????
     do i = lstrt, nblock
        bivlam(i) = -vnormc*rnormxl(i)*rnormc*rnormc*rnormc + &
             bivlam(i)*rnormc
     enddo
   end subroutine ldm_prop2_dynamvv

!-----------------------------------------------------------------------
!> Second propagation of variables for dynamic integration (from dynamvv)
   subroutine ldm_reset_dynam(nblock)
     use number
     implicit none

     integer, intent(in) :: nblock

     integer :: i,j

     blcoep(1) = one
     blcoeb(1) = one
     blcoea(1) = one
     blcoed(1) = one
     blcoee(1) = one
     blcoev(1) = one
     bldold(1) = one
     do i = lstrt, nblock
        bldold(i) = bixlam(i)
        bixlam(i) = bxlcomp(i)
        !:          first row elements
        j = 1 + i*(i-1)/2
        blcoep(j) = bixlam(i)*bixlam(i)
        blcoeb(j) = blcoep(j)
        blcoea(j) = blcoep(j)
        blcoed(j) = blcoep(j)
        blcoee(j) = blcoep(j)
        blcoev(j) = blcoep(j)
        !:          diagonal elements
        j = i + i*(i-1)/2
        blcoep(j) = bixlam(i)*bixlam(i)
        blcoeb(j) = blcoep(j)
        blcoea(j) = blcoep(j)
        blcoed(j) = blcoep(j)
        blcoee(j) = blcoep(j)
        blcoev(j) = blcoep(j)
     enddo
   end subroutine ldm_reset_dynam

!-----------------------------------------------------------------------
!> Second propagation of variables for dynamic integration (from dynamc)
   subroutine ldm_reset_dynamc(nblock)
     use number
     implicit none

     integer, intent(in) :: nblock
     integer :: i,j

        do i = lstrt, nblock
           bixlam(i) = bldold(i)
        enddo

        blcoep(1) = one
        blcoeb(1) = one
        blcoea(1) = one
        blcoed(1) = one
        blcoee(1) = one
        blcoev(1) = one
        do i = lstrt, nblock
           !:           first row elements
           j = 1 + i*(i-1)/2
           blcoep(j) = bixlam(i)*bixlam(i)

           if(qthetadm) then                !new theta-dynamics
              if(i == 2) then                 !new theta-dynamics
                 blcoep(j)=one-(sin(theta))**2  !new theta-dynamics
              else if (i == 3) then           !new theta-dynamics
                 blcoep(j)=(sin(theta))**2      !new theta-dynamics
              endif                           !new theta-dynamics
           endif                            !new theta-dynamics

           blcoeb(j) = blcoep(j)
           blcoea(j) = blcoep(j)
           blcoed(j) = blcoep(j)
           blcoee(j) = blcoep(j)
           blcoev(j) = blcoep(j)
           !:           diagonal elements
           j = i + i*(i-1)/2
           blcoep(j) = bixlam(i)*bixlam(i)

           if(qthetadm) then                !new theta-dynamics
              if(i == 2) then                 !new theta-dynamics
                 blcoep(j)=one-(sin(theta))**2  !new theta-dynamics
              else if (i == 3) then           !new theta-dynamics
                 blcoep(j)=(sin(theta))**2      !new theta-dynamics
              endif                           !new theta-dynamics
           endif                            !new theta-dynamics

           blcoeb(j) = blcoep(j)
           blcoea(j) = blcoep(j)
           blcoed(j) = blcoep(j)
           blcoee(j) = blcoep(j)
           blcoev(j) = blcoep(j)
        enddo

      end subroutine ldm_reset_dynamc

!-----------------------------------------------------------------------
!> Second propagation of variables for dynamic integration (from dynamvv)
      subroutine ldm_reset2_dynamc(nblock)
        use number
        implicit none

        integer, intent(in) :: nblock
        integer :: i
        bldold(1) = one
        !              reset lambdas to time t and bldold to t + dt
        !              before writing restart file
        bldold(1) = one
        do i = lstrt, nblock
           bldold(i) = bixlam(i)
           if(qldm) bixlam(i) = bxlcomp(i)
        enddo
    end subroutine ldm_reset2_dynamc

!-----------------------------------------------------------------------
!> Second propagation of variables for dynamic integration (from dynamvv)
   subroutine ldm_reset3_dynamc(nblock)
     use number
     implicit none

     integer, intent(in) :: nblock
     integer :: i, j

     blcoep(1) = one
     blcoeb(1) = one
     blcoea(1) = one
     blcoed(1) = one
     blcoee(1) = one
     blcoev(1) = one
     bldold(1) = one
     do i = lstrt, nblock
        bldold(i) = bixlam(i)
        if(qldm) bixlam(i) = bxlcomp(i)
        !:          first row elements
        j = 1 + i*(i-1)/2
        blcoep(j) = bixlam(i)*bixlam(i)

        if(qthetadm) then                !new theta-dynamics
           if(i == 2) then                 !new theta-dynamics
              blcoep(j)=one-(sin(theta))**2  !new theta-dynamics
           else if (i == 3) then           !new theta-dynamics
              blcoep(j)=(sin(theta))**2      !new theta-dynamics
           endif                           !new theta-dynamics
        endif                            !new theta-dynamics

        blcoeb(j) = blcoep(j)
        blcoea(j) = blcoep(j)
        blcoed(j) = blcoep(j)
        blcoee(j) = blcoep(j)
        blcoev(j) = blcoep(j)
        !:          diagonal elements
        j = i + i*(i-1)/2
        blcoep(j) = bixlam(i)*bixlam(i)

        if(qthetadm) then                !new theta-dynamics
           if(i == 2) then                 !new theta-dynamics
              blcoep(j)=one-(sin(theta))**2  !new theta-dynamics
           else if (i == 3) then           !new theta-dynamics
              blcoep(j)=(sin(theta))**2      !new theta-dynamics
           endif                           !new theta-dynamics
        endif                            !new theta-dynamics

        blcoeb(j) = blcoep(j)
        blcoea(j) = blcoep(j)
        blcoed(j) = blcoep(j)
        blcoee(j) = blcoep(j)
        blcoev(j) = blcoep(j)
     enddo
   end subroutine ldm_reset3_dynamc

!-----------------------------------------------------------------------
!> Second propagation of variables for dynamic integration (from dynamvv)
   subroutine ldm_write_dynamc(nblock, ndegf, istep, tempi, eprop)
     use number
     use consta
     use stream
     implicit none

     integer, intent(in) :: nblock, istep, ndegf
     real(chm_real), intent(in) :: tempi, eprop

     integer :: ndegflam, nblock3, i
     real(chm_real) :: totkelam, totkelam2

     nblock3 = 3 * nblock
     if(ntempld > 0 .and. iolev.gt.0) then
        if(mod(istep,ntempld) == 0) then
           totkelam=0.0
           do i = lstrt, nblock
              if(ilaldm)then
                 ibvcrrt(i)=igammald(i+nblock3)*(ibvcrrt(i)+bivlam(i))
              else
                 ibvcrrt(i)=half*(ibvcrrt(i)+bivlam(i))
              endif
              totkelam=totkelam+bimlam(i)*ibvcrrt(i)**2
           enddo

           if(qthetadm) then           !new theta-dynamics
              totkelam=thetam*thetav**2 !new theta-dynamics
           endif                       !new theta-dynamics

           ndegflam=float(nblock-2)
           totkelam2=(totkelam+tempi)/kboltz/(ndegf+ndegflam)
           totkelam=totkelam/ndegflam/kboltz
           write (itempld,'(i7,3x,3(f12.5,1x))')istep, &
                totkelam2,eprop,totkelam
        endif
     endif
   end subroutine ldm_write_dynamc


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      subroutines FOR BIASING POTENTIALS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!-----------------------------------------------------------------------
!> Sets up N bias potentials for blocks using parameters specified in
!> subsequent LDBV commands.
!> Invoked from BLOCK subcommand LDBI.\n
!> Usage: LDBI N
  subroutine ldm_biasin(comlyn,comlen)
    use memory
    use stream
    use string

    implicit none
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    IF (QLDB) THEN   ! Qldb assigned after call to this subroutine
       IF(NBIASV.GT.0) THEN   ! deallocate arrays for old biasing potentials
          call chmdealloc('lambda_ltm.src','ldm_biasin','IRREUP',NBIASV,crl=IRREUP)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IRRLOW',NBIASV,crl=IRRLOW)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IKBIAS',NBIASV,crl=IKBIAS)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IPBIAS',NBIASV,intg=IPBIAS)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IBCLAS',NBIASV,intg=IBCLAS)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IBVIDI',NBIASV,intg=IBVIDI)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IBVIDJ',NBIASV,intg=IBVIDJ)
       ELSE IF(NBIASV.EQ.0) THEN
          call chmdealloc('lambda_ltm.src','ldm_biasin','IRREUP',1,crl=IRREUP)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IRRLOW',1,crl=IRRLOW)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IKBIAS',1,crl=IKBIAS)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IPBIAS',1,intg=IPBIAS)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IBCLAS',1,intg=IBCLAS)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IBVIDI',1,intg=IBVIDI)
          call chmdealloc('lambda_ltm.src','ldm_biasin','IBVIDJ',1,intg=IBVIDJ)
       ENDIF
    ENDIF
    NBIASV = 0
    NBIASV=NEXTI(COMLYN,COMLEN)   ! read in new number of biasing potentials
    if (prnlev >= 2) WRITE(OUTU,55) NBIASV
55  FORMAT(' Total No. of biasing potentials is ', I4)

    IF (NBIASV .GT. 0) THEN   ! allocate arrays for new biasing potentials
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IRREUP',NBIASV,crl=IRREUP)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IRRLOW',NBIASV,crl=IRRLOW)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IKBIAS',NBIASV,crl=IKBIAS)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IPBIAS',NBIASV,intg=IPBIAS)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IBCLAS',NBIASV,intg=IBCLAS)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IBVIDI',NBIASV,intg=IBVIDI)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IBVIDJ',NBIASV,intg=IBVIDJ)
    ELSE IF (NBIASV .EQ. 0) THEN
       !        to prevent any problem in dynio.src where these arrays are
       !        used to write out the biasing potentials, we default them to 1.
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IRREUP',1,crl=IRREUP)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IRRLOW',1,crl=IRRLOW)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IKBIAS',1,crl=IKBIAS)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IPBIAS',1,intg=IPBIAS)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IBCLAS',1,intg=IBCLAS)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IBVIDI',1,intg=IBVIDI)
       call chmalloc('lambda_ltm.src','ldm_BIASIN','IBVIDJ',1,intg=IBVIDJ)
    ENDIF

    !     ZERO ALL FORCE CONSTANTS
    IRREUP = 0.0
    IRRLOW = 0.0
    IKBIAS = 0.0
    QLDB = .TRUE.

  END subroutine ldm_biasin

!-----------------------------------------------------------------------
!> Initializes biasing potentials lambdaF(i).
!> Invoked by BLOCK subcommand LDBV.
!>\verbatim
!> Biasing potentials of the form:
!> CLASS 1: V = CFORCE*(lambda - REF)**NPOWER  if lambda < REF
!> CLASS 2: V = CFORCE*(lambda - REF)**NPOWER  if lambda > REF
!> CLASS 3: V = CFORCE*(lambda - REF)**NPOWER
!> Usage: LDBV INDEX  I   J  CLASS  REF  CFORCE NPOWER
!> e.g.:  LDBV   2    2   3    3    0.0   50.0   4
!>\endverbatim
  subroutine ldm_biaspot(comlyn,comlen)

    use memory !GG
    use stream
    use string
    use parallel !GG

    implicit none
    character(len=*), intent(inout) :: COMLYN
    character(len=6) IIBIAS                  !GG New MSLD pH-REX commands added
    INTEGER, intent(inout) :: COMLEN
    integer :: ldcnt, ldcls

    LDCNT = NEXTI(COMLYN,COMLEN)
    IBVIDI(LDCNT) = NEXTI(COMLYN,COMLEN)
    IBVIDJ(LDCNT) = NEXTI(COMLYN,COMLEN)
    LDCLS = NEXTI(COMLYN,COMLEN)
    IBCLAS(LDCNT) = LDCLS

    IF(LDCLS.EQ.1) THEN
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    ELSE IF(LDCLS.EQ.2) THEN
       IRRLOW(LDCNT) = NEXTF(COMLYN,COMLEN)
    ELSE IF(LDCLS.EQ.3) THEN
       !        store the equilibrium value in irreup
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.4) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.5) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.6) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.7) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.8) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.9) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    else if (ldcls.eq.10) then
       IRREUP(LDCNT) = NEXTF(COMLYN,COMLEN)
    ENDIF
    IKBIAS(LDCNT) = NEXTF(COMLYN,COMLEN)
    IPBIAS(LDCNT) = NEXTI(COMLYN,COMLEN)

    IF(QMSPHMD) THEN
       IIBIAS = NEXTA6(COMLYN,COMLEN) !GG Read in identity of residue
       IF(IIBIAS .EQ. 'A111') THEN
          IKBIAS(LDCNT) = 29.75D0
       ELSE IF (IIBIAS .EQ. 'A113') THEN
          IKBIAS(LDCNT) = 29.75D0
       ELSE IF (IIBIAS .EQ. 'A121') THEN
          IKBIAS(LDCNT) = 27.50D0
       ELSE IF (IIBIAS .EQ. 'C111') THEN
          IKBIAS(LDCNT) = 27.75D0
       ELSE IF (IIBIAS .EQ. 'C113') THEN
          IKBIAS(LDCNT) = 26.75D0
       ELSE IF (IIBIAS .EQ. 'C121') THEN
          IKBIAS(LDCNT) = 27.50D0
       ELSE
       !GG: Will use user-specified bias value
       ENDIF
       if (mynod == 0 ) write(outu,'(a20,f10.6)') 'PHMD flag for kbias:', IKBIAS(LDCNT)
    ENDIF !GG for IF(QMSPHMD) loop

  END subroutine ldm_biaspot

!-----------------------------------------------------------------------
!> RSTP adds restraining potential.
!> Invoked by BLOCK subcommand RSTP.\n
!> RSTP adds the restraining potential for the unbound states ligands
!> in lambda-dynamics and hybrid-MC/MD method to keep the physical low energy
!> states.
!>\verbatim
!> The type of the restraining potential used with RSTP is:
!> R = alpha *(1 - lambda^2)*  ( V - F )
!>  i                    i        i   i
!>\endverbatim
!> It disappears when this ligands is in bound state (lambda=1).
  subroutine ldm_rstp(nblock,comlyn,comlen)

    use memory
    use psf, only : natom
    use dimens_fcm, only : maxaim
    use string

    implicit none
    integer, intent(in) :: nblock
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    if(rstp) then
       if(nrst.eq.1) then
          call chmdealloc('lambda_ltm.src','ldm_rstp','ENVDX',NATOM*(NBLOCK-1),crl=ENVDX)
          call chmdealloc('lambda_ltm.src','ldm_rstp','ENVDY',NATOM*(NBLOCK-1),crl=ENVDY)
          call chmdealloc('lambda_ltm.src','ldm_rstp','ENVDZ',NATOM*(NBLOCK-1),crl=ENVDZ)
       else
          call chmdealloc('lambda_ltm.src','ldm_rstp','ENVDX',MAXAIM,crl=ENVDX)
          call chmdealloc('lambda_ltm.src','ldm_rstp','ENVDY',MAXAIM,crl=ENVDY)
          call chmdealloc('lambda_ltm.src','ldm_rstp','ENVDZ',MAXAIM,crl=ENVDZ)
       endif
    endif
    nrst = 0

    RSTP = .TRUE.
    NRST = NEXTI(COMLYN,COMLEN)
    LMDCOEF = NEXTF(COMLYN,COMLEN)
    ! TYPE OF RESTRAINING POTENTIAL IS ONE, THE FORCE IN PROTEIN
    ! ATOMS SHOULD BE RESCALED
    IF(NRST.EQ.1) THEN
       call chmalloc('lambda_ltm.src','ldm_rstp','ENVDX',NATOM*(NBLOCK-1),crl=ENVDX)
       call chmalloc('lambda_ltm.src','ldm_rstp','ENVDY',NATOM*(NBLOCK-1),crl=ENVDY)
       call chmalloc('lambda_ltm.src','ldm_rstp','ENVDZ',NATOM*(NBLOCK-1),crl=ENVDZ)
    ELSE
       call chmalloc('lambda_ltm.src','ldm_rstp','ENVDX',MAXAIM,crl=ENVDX)
       call chmalloc('lambda_ltm.src','ldm_rstp','ENVDY',MAXAIM,crl=ENVDY)
       call chmalloc('lambda_ltm.src','ldm_rstp','ENVDZ',MAXAIM,crl=ENVDZ)
    ENDIF

  END subroutine ldm_rstp

  !=================================================================================
  !   SUBROUTINES FOR SETTING UP Hybrid MC/MD l-dynamics in BLOCK
  !=================================================================================
!-----------------------------------------------------------------------
!> Turns on LMC.
!> Invoked from BLOCK subcommand QLMC.
  subroutine ldm_mc_setup(nblock,comlyn,comlen)

    use memory
    use stream
    use string
    use number

    implicit none
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN
    integer, intent(in) :: nblock

! required for GB
    QLDM=.FALSE.
    QLMC=.TRUE.
    MCTEMP = GTRMF(COMLYN,COMLEN,'MCTE',ZERO)
    IMC = GTRMI(COMLYN,COMLEN,'FREQ',1)
    MCSTEP = GTRMI(COMLYN,COMLEN,'MCST',1)
    MCMAX = GTRMF(COMLYN,COMLEN,'MAX',ONE)
    IF(MCSTEP.EQ.0)THEN
       write (outu,*)'Warning in block and l-dynamics QLMC MCSTEP=',MCSTEP
       MCSTEP=1
       write (outu,*)'Changing  MCSTEP=',MCSTEP
    ENDIF
    IF(MCMAX.EQ.0.0)THEN
       write (outu,*)'Warning in block and l-dynamics QLMC MCMAX=',MCMAX
       MCMAX=1.0
       write (outu,*)'Changing  MCMAX=',MCMAX
    ENDIF
    MCMIN = SQRT((1.0-MCMAX)/FLOAT(NBLOCK-2))
    MCMAX = SQRT(MCMAX)

    QADIN = INDXA(COMLYN,COMLEN,'ADIN') .GT. 0  !New ADIN
    IF(QADIN) THEN                              !New ADIN
       AVEDVDL = 0.0
       AVESTEP = 0.0
    ENDIF                                       !New ADIN

  END subroutine ldm_mc_setup

!-----------------------------------------------------------------------
!> Sets up LMC in which more than 2 ligands can have intermediate states.
!> Invoked by BLOCK subcommand MCDI.
!> Step size is a fixed interval (STEPMC)
  subroutine ldm_mc_increment(comlyn,comlen)

    use memory
    use stream
    use string
    use number

    implicit none
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    MCDIV = .TRUE.
    STEPMC = NEXTF(COMLYN,COMLEN)
    IF (STEPMC .LE. ZERO) THEN
       STEPMC = PT25
       IF (WRNLEV.GE.2) WRITE(OUTU,92)  STEPMC
92     FORMAT('WARNING: StepMC for hybrid MC/MD', &
            ' should be larger than 0.0. Re-assigned to ',F10.5)
    ENDIF

    ! clear old conditions (QMCIN & MCDIV is exclusive)
    IF (QMCIN) THEN
       QMCIN = .FALSE.
       call chmdealloc('lambda_ltm.src','ldm_mc_increment','ISTLIG',NMCST*2,intg=ISTLIG)
       call chmdealloc('lambda_ltm.src','ldm_mc_increment','LMCST',NMCST*2,crl=LMCST)
    ENDIF

  END subroutine ldm_mc_increment

!-----------------------------------------------------------------------
!> Sets up LMC in which ONLY 2 ligands can have intermediate states.
!> Invoked by BLOCK subcommand MCIN.
!> Non-uniform intervals can be specified.
  subroutine ldm_mc_2intermediate(nblock,comlyn,comlen,ltemp)

    use memory
    use string

    implicit none
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN
    integer, intent(in) :: nblock
    integer :: j
    integer, intent(out) :: ltemp
    real(chm_real) :: r

    ! clear old condition (QMCIN & MCDIV is exclusive)
    MCDIV=.FALSE.
    QMCIN=.TRUE.
    LTEMP=NEXTI(COMLYN,COMLEN)
    call chmalloc('lambda_ltm.src','ldm_mc_2intermediate','lmcktemp',LTEMP,crl=lmcktemp)
    ! read lambda^2 values of intermediate states
    DO J=1,LTEMP
       lmcktemp(J) = NEXTF(COMLYN,COMLEN)
    ENDDO

  END subroutine ldm_mc_2intermediate

!-----------------------------------------------------------------------
!> Clears LMC arrays.
!> Invoked from BLOCK subcommand MCLE
  subroutine ldm_mc_clear

    use memory

    implicit none

    MCRST = .FALSE.
    MCDIV = .FALSE.
    IF (QMCIN) THEN
       QMCIN = .FALSE.
       call chmdealloc('lambda_ltm.src','ldm_mc_clear','ISTLIG',NMCST*2,intg=ISTLIG)
       call chmdealloc('lambda_ltm.src','ldm_mc_clear','LMCST',NMCST*2,crl=LMCST)
    ENDIF

  END subroutine ldm_mc_clear

!-----------------------------------------------------------------------
!> Remove the duplicated intermediates states in MC/MD method.
!> by shinichi banba
  subroutine prepmcstate(jint,kint,iit,ltemp,nblock)

    use stream

    implicit none
    integer :: i, j, k, n
    integer, intent(in) :: nblock, iit, ltemp
    integer, dimension(iit), intent(inout) :: jint
    real(chm_real), dimension(iit), intent(inout) :: kint
    real(chm_real) :: R1, R2
    LOGICAL IFLG

    NMCST=0
    DO I=LSTRT, NBLOCK-1
       DO J=1, LTEMP
          DO K=I+1, NBLOCK
             IF(K.NE.I)THEN
                R1 = lmcktemp(J)
                R2 = 1.d0 - R1
                IFLG=.TRUE.
                DO N=1, NMCST
                   IF(jint(2*N-1).EQ.I.AND.jint(2*N).EQ.K)THEN
                      IF(kint(2*N-1).EQ.R1) IFLG = .FALSE.
                   ENDIF
                   IF(jint(2*N).EQ.I.AND.jint(2*N-1).EQ.K)THEN
                      IF(kint(2*N).EQ.R1) IFLG = .FALSE.
                   ENDIF
                   IF(R1.EQ.1.0)THEN
                      IF((kint(2*N-1).EQ.R1).AND.(jint(2*N-1).EQ.I)) &
                           IFLG=.FALSE.
                      IF((kint(2*N).EQ.R1).AND.(jint(2*N).EQ.I)) &
                           IFLG=.FALSE.
                   ENDIF
                   IF(R2.EQ.1.0)THEN
                      IF((kint(2*N-1).EQ.R2).AND.(jint(2*N-1).EQ.K)) &
                           IFLG=.FALSE.
                      IF((kint(2*N).EQ.R2).AND.(jint(2*N).EQ.K)) &
                           IFLG=.FALSE.
                   ENDIF
                ENDDO
                IF(IFLG)THEN
                   NMCST=NMCST+1
                   jint(2*NMCST-1)=I
                   jint(2*NMCST)=K
                   kint(2*NMCST-1)=R1
                   kint(2*NMCST)=R2
                ENDIF
             ENDIF
          ENDDO
       ENDDO
    ENDDO
    DO I=1, NMCST
       WRITE (outu,'(A8,I5,I5,I5,2F12.5)') &
            'MC STATE',I,jint(2*I-1),jint(2*I),kint(2*I-1),kint(2*I)
    ENDDO
    DO I=1, NMCST
       kint(2*I-1) = SQRT(kint(2*I-1))
       kint(2*I)   = SQRT(kint(2*I))
    ENDDO

  END subroutine PREPMCSTATE

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      SUBROUTINES FOR SIMULATED SCALING IN LMC
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!-----------------------------------------------------------------------
!> Sets up simulated scaling for LMC.
!> Invoked from BLOCK subcommand MCFR.
  subroutine ldm_ss_setup(comlyn,comlen)

    use chm_kinds
    use number
    use string

    implicit none

    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    QMCFR=.true.
    MCEXFR = GTRMI(COMLYN,COMLEN,'EXFR',1)
    WANGFI=GTRMF(COMLYN,COMLEN,'FINI',2.71828_chm_real)
    WANGFF=GTRMF(COMLYN,COMLEN,'FFIN',1.0_chm_real)
    WANGFLAT=GTRMF(COMLYN,COMLEN,'FLAT',0.8_chm_real)

  END subroutine ldm_ss_setup

!-----------------------------------------------------------------------
!> Sets up lambda values for simulated scaling for LMC.
!> Invoked from MCLA.
  subroutine ldm_ss_lambda(comlyn,comlen)

    use memory
    use number
    use string

    implicit none
    integer :: i
    character(len=*), intent(inout) :: COMLYN
    INTEGER, intent(inout) :: COMLEN

    MCDIV = .TRUE.
    MCBOXES = NEXTI(COMLYN,COMLEN)

    call chmalloc('lambda_ltm.src','ldm_ss_lambda','MCPRO',MCBOXES,crl=MCPRO)
    call chmalloc('lambda_ltm.src','ldm_ss_lambda','MCCOUNT',MCBOXES,intg=MCCOUNT)
    call chmalloc('lambda_ltm.src','ldm_ss_lambda','MCLAMD',MCBOXES,crl=MCLAMD)

    DO I = 1, MCBOXES
       MCLAMD(I) = GTRMF(COMLYN,COMLEN,'LAMD',-ONE)
    ENDDO

  END subroutine ldm_ss_lambda

  !==============================================================================
  !    SUBROUTINES CALLED FROM GENERAL BLOCK SUBCOMMANDS
  !==============================================================================
!-----------------------------------------------------------------------
!> Deallocates GB memory for LDM.
!> Invoked from BLOCK subcommand CLEA
  subroutine ldm_clear_gb(nblock,gb_lamb,gbldm)

    use memory
    use psf,only: natom

    implicit none
    integer, intent(in) :: nblock
    real(chm_real),allocatable,dimension(:),intent(inout) :: gb_lamb, gbldm

    if (qldm) then
       call chmdealloc('lambda_ltm.src','ldm_clear_gb','gb_lamb',natom*nblock,crl=gb_lamb)
       call chmdealloc('lambda_ltm.src','ldm_clear_gb','gbldm',nblock,crl=gbldm)
    endif

  END subroutine ldm_clear_gb
!-----------------------------------------------------------------------
!> Deallocates memory for LDM.
!> Invoked from BLOCK subcommand CLEA
  subroutine ldm_block_clear(nblock,nreplica)

    use memory
    use psf, only : natom
    use dimens_fcm, only : maxaim

    implicit none
    integer, intent(in) :: nblock
    integer, intent(in) :: nreplica           !GG

    call chmdealloc('lambda_ltm.src','ldm_block_clear','BLDOLD',NBLOCK,crl=BLDOLD)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIXLAM',NBLOCK,crl=BIXLAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIVLAM',NBLOCK,crl=BIVLAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIMLAM',NBLOCK,crl=BIMLAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIELAM',NBLOCK,crl=BIELAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIFLAM',NBLOCK,crl=BIFLAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIBLAM',NBLOCK,crl=BIBLAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIILAM',NBLOCK,ch4=BIILAM) !GG
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIPTNLAM',NBLOCK,crl=BIPTNLAM)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIGLAM',NBLOCK,crl=BIGLAM) !GG
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIRLAM',NBLOCK,crl=BIRLAM) !GG
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BFRST',NBLOCK,crl=BFRST)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','IBVCRRT',NBLOCK,crl=IBVCRRT)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BIELAMTEMP',NREPLICA,NBLOCK,crl=BIELAMTEMP) !GG

    ! clb3, variables from dcntrl.src
    call chmdealloc('lambda_ltm.src','ldm_block_clear','BXLCOMP',NBLOCK,crl=BXLCOMP)
    call chmdealloc('lambda_ltm.src','ldm_block_clear','RNORMXL',NBLOCK,crl=RNORMXL)

    IF(RSTP)THEN
       IF(NRST.EQ.1)THEN
          call chmdealloc('lambda_ltm.src','ldm_block_clear','ENVDX',NATOM*(NBLOCK-1),crl=ENVDX)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','ENVDY',NATOM*(NBLOCK-1),crl=ENVDY)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','ENVDZ',NATOM*(NBLOCK-1),crl=ENVDZ)
       ELSE
          call chmdealloc('lambda_ltm.src','ldm_block_clear','ENVDX',MAXAIM,crl=ENVDX)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','ENVDY',MAXAIM,crl=ENVDY)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','ENVDZ',MAXAIM,crl=ENVDZ)
       ENDIF
    ENDIF

    if(qldb) then
       IF(NBIASV.GT.0) THEN
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IRREUP',NBIASV,crl=IRREUP)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IRRLOW',NBIASV,crl=IRRLOW)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IKBIAS',NBIASV,crl=IKBIAS)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IPBIAS',NBIASV,intg=IPBIAS)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IBCLAS',NBIASV,intg=IBCLAS)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IBVIDI',NBIASV,intg=IBVIDI)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IBVIDJ',NBIASV,intg=IBVIDJ)
       ELSE IF (NBIASV.EQ.0) THEN
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IRREUP',1,crl=IRREUP)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IRRLOW',1,crl=IRRLOW)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IKBIAS',1,crl=IKBIAS)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IPBIAS',1,intg=IPBIAS)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IBCLAS',1,intg=IBCLAS)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IBVIDI',1,intg=IBVIDI)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','IBVIDJ',1,intg=IBVIDJ)
       ENDIF
    endif

    if(qsobo) then
       if(nsobo.gt.0) then
          call chmdealloc('lambda_ltm.src','ldm_block_clear','soboi',nsobo,intg=soboi)
          call chmdealloc('lambda_ltm.src','ldm_block_clear','soboj',nsobo,intg=soboj)
       endif
       qsobo=.false.
       nsobo=0
    endif

    IF(ILALDM) THEN
       call chmdealloc('lambda_ltm.src','ldm_block_clear','IGAMMALD',NBLOCK*4,crl=IGAMMALD)
       ilaldm = .false.
    ENDIF

    if (qmld) then
       call chmdealloc('lambda_ltm.src','ldm_block_clear','ISITEMLD',nblock,intg=ISITEMLD)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','BIFLAM2',nblock,crl=BIFLAM2)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','BIELAM2',nblock,crl=BIELAM2)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','nsubmld',nblock,intg=nsubmld)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','thetamld',nsitemld,nblock,crl=thetamld)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','thetamldold',nsitemld,nblock,crl=thetamldold)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','thetavmld',nsitemld,nblock,crl=thetavmld)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','thetafmld',nsitemld,nblock,crl=thetafmld)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','blckmld',nsitemld,nblock,intg=blckmld)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','blckmask',nblock,nblock,log=blckmask)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','fullblcoep',nblock,nblock,crl=fullblcoep)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','fnexp_factors',nsitemld,crl=fnexp_factors)
       call msld_deallocate_flags
       call msld_deallocate_lookup_tables
       qmld = .false.
    endif

    iqldm_softcore = 0
    iqldm_pme = 0
    if (qldm_scalecons) then
       call chmdealloc('lambda_ltm.src','ldm_block_clear','iblcks',maxaim,intg=iblcks)
    endif
    qldm_scalecons = .false.

    QLMC = .FALSE.
    MCDIV = .FALSE.
    MCRST = .FALSE.
    IF (QMCIN) THEN
       QMCIN = .FALSE.
       call chmdealloc('lambda_ltm.src','ldm_block_clear','ISTLIG',NMCST*2,intg=ISTLIG)
       call chmdealloc('lambda_ltm.src','ldm_block_clear','LMCST',NMCST*2,crl=LMCST)
    ENDIF
    QLDM =.FALSE.
    QLDB =.FALSE.
    RSTP = .FALSE.

  END subroutine ldm_block_clear

!-----------------------------------------------------------------------
!> Runs after BLOCK END.
  subroutine ldm_mc_endblock(nblock,ltemp)

    use memory
    use stream

    implicit none
    integer :: i, iit
    integer, intent(in) :: nblock, ltemp
    integer, allocatable, dimension(:) :: jint
    real(chm_real), allocatable, dimension(:) :: kint

    !      IF (NRST.EQ.2)THEN
    !         LSTRT=3
    !         call LDMATRIX(.TRUE., NBLOCK, BIXLAM, BLCOEP, BLCOEB, &
    !         BLCOEA, BLCOED,BLCOEE, BLCOEV,LSTRT)
    !         WRITE (OUTU,200)
    ! 200     FORMAT('>>> BLOCK MATRIX WAS REBUILT ')
    !         IF ((PRNLEV.GE.2).AND.QBLOCK) CALL PINTMAT(OUTU)
    !      ENDIF

    IF (QMCIN) THEN
       ! allocate temporay stack array
       call chmalloc('lambda_ltm.src','ldm_mc_endblock','JINT',LTEMP*NBLOCK**2,intg=JINT)
       call chmalloc('lambda_ltm.src','ldm_mc_endblock','KINT',LTEMP*NBLOCK**2,crl=KINT)
       ! preparing the undulpicated mixed states
       iit = ltemp*nblock*nblock
       call PREPMCSTATE(JINT,KINT,iit,ltemp,NBLOCK)
       WRITE(outu,*) 'BLOCK NUMBER OF STATES OF MC/MD =', NMCST
       ! for safety
       IF (NMCST .LE. 0) CALL WRNDIE(-5,'<BLOCK>', &
            'NMCST(Number of lambda states) should be more than zero')
       ! move stack to heap and old array in stack are deleted
       call chmalloc('lambda_ltm.src','ldm_mc_endblock','ISTLIG',NMCST*2,intg=ISTLIG)
       call chmalloc('lambda_ltm.src','ldm_mc_endblock','LMCST',NMCST*2,crl=LMCST)

       !made explicit, only used once--call MVMCSTATE(NMCST,JINT,NINT,ISTLIG,LMCST)
       ! move temporary stack array to heap small array
       do i = 1, 2*nmcst
          istlig(i) = jint(i)
          lmcst(i) = kint(i)
       enddo

       ! clear temporay used stack array
       call chmdealloc('lambda_ltm.src','ldm_mc_endblock','JINT',LTEMP*NBLOCK**2,intg=JINT)
       call chmdealloc('lambda_ltm.src','ldm_mc_endblock','KINT',LTEMP*NBLOCK**2,crl=KINT)
       call chmdealloc('lambda_ltm.src','ldm_mc_endblock','lmcktemp',LTEMP,crl=lmcktemp)
    ENDIF

  END subroutine ldm_mc_endblock

!-----------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    SUBROUTINES FOR MULTI-SITE LDM  added 04/2009 jlk and clbiii
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!-----------------------------------------------------------------------
!> Sets up Multi-Site lambda-dynamics parameters and arrays.
!> Invoked from BLOCK subcommand MSLD.\n
!> MSLD is the keyword that invokes Multi-Site lambda-dynamics. The
!> integers which follow the keyword indicate the "Site" to which atoms within
!> each block are assigned. The first block must be assigned to Site 0 (the
!> "environment" atoms). Currently, QLDM THETA must be specified prior to
!> invoking MSLD.
!>\verbatim
!> Usage: MSLD int_1 int_2 ... int_nblocks { FNEXponential [real] }
!>                                         { FNXS [real_1 ... real_nsites] }
!>                                         { FNSIn }
!>                                         { F2Exponential }
!>                                         { F2Sin }
!>                                         { FFIX }
!>                               default = { FNEX 5.5 }
!>\endverbatim
!> e.g. with the first block being the environment (Site 0) (required),
!>      the next 2 blocks defined as substituents on Site 1 and
!>      the remaining 4 blocks defined as substituents on Site 2:\n
!>       msld 0 1 1 2 2 2 2 fnex 5.5
! Environment atoms = Block 1 = Site 0
! All other Blocks must be assigned to Site N, N > 0
! Within the code, Site number for Block i (isitemld(i)) is
! one more than the Site number assigned in the inputfile.
   subroutine msld_setup(nblock,comlyn,comlen)

      use stream
      use memory
      use string
      use parallel

      implicit none
      character(len=*), intent(inout) :: COMLYN
      INTEGER, intent(inout) :: comlen
      INTEGER, intent(in) :: nblock
      integer :: i, j, max
      integer, dimension(nblock) :: count
      real(chm_real) :: def_fnexp_factor
      logical :: multi_fnexp

! Check for incompatibilities [more than three blocks, qtheta previously read in]
      if (nblock .le. 2) call wrndie(-3,'<lambdadyn>', &
          'At least three blocks must be used with this command.')

      if (.not.qthetadm) call wrndie(-3,'<lambdadyn>', &
          'qtheta must be previously assigned with this command.')

! (Re)Initialize  ISITEMLD for Sites
      if (qmld) then
         call chmdealloc('lambda_ltm.src','msld_setup','ISITEMLD',nblock,intg=ISITEMLD)
         call chmdealloc('lambda_ltm.src','msld_setup','BIFLAM2',nblock,crl=BIFLAM2)
         call chmdealloc('lambda_ltm.src','msld_setup','BIELAM2',nblock,crl=BIELAM2)
         call chmdealloc('lambda_ltm.src','msld_setup','nsubmld',nblock,intg=nsubmld)
         call chmdealloc('lambda_ltm.src','msld_setup','thetamld',nsitemld,nblock,crl=thetamld)
         call chmdealloc('lambda_ltm.src','msld_setup','thetamldold',nsitemld,nblock,crl=thetamldold)
         call chmdealloc('lambda_ltm.src','msld_setup','thetavmld',nsitemld,nblock,crl=thetavmld)
         call chmdealloc('lambda_ltm.src','msld_setup','thetafmld',nsitemld,nblock,crl=thetafmld)
         call chmdealloc('lambda_ltm.src','msld_setup','blckmld',nsitemld,nblock,intg=blckmld)
         call chmdealloc('lambda_ltm.src','msld_setup','blckmask',nblock,nblock,log=blckmask)
         call chmdealloc('lambda_ltm.src','msld_setup','fullblcoep',nblock,nblock,crl=fullblcoep)
         call chmdealloc('lambda_ltm.src','msld_setup','fnexp_factors',nsitemld,crl=fnexp_factors)
         call msld_deallocate_lookup_tables
      endif
      qmld = .true.
      qldm = .false.
      call chmalloc('lambda_ltm.src','msld_setup','ISITEMLD',NBLOCK,intg=ISITEMLD)
      call chmalloc('lambda_ltm.src','msld_setup','BIFLAM2',nblock,crl=BIFLAM2)
      call chmalloc('lambda_ltm.src','msld_setup','BIELAM2',nblock,crl=BIELAM2)

! Assign "Call" designations to Sites in Multi-site LD
! Read in SITE assignments for each BLOCK
      max = 0
      max = gtrmi(comlyn,comlen,'NSIT',max)
      if (max == 0) then
         do i = 1, nblock
            j = nexti(comlyn,comlen)
            if (j.gt.max) max=j
            if (i.eq.1 .and. j.ne.0) then
               j = 0
               if (mynod == 0 ) write(outu,30)
 30            FORMAT('WARNING: invalid attempt to assign BLOCK 1 to a non-zero SITE. &
&                    BLOCK 1 re-assigned to SITE 0')
            elseif (i.ne.1 .and. j.eq.0) then
               if (mynod == 0 ) write(outu,31) i, j
 31            FORMAT('WARNING: invalid attempt to assign BLOCK ', I4, ' to SITE 0. &
&                    SITE 0 is reserved for BLOCK 1 only.')
               call wrndie(-3,'<lambda_ltm>', 'Failed attempt to assign blocks to sites.')
            endif
            if(prnlev.ge.2) write(outu,32) i, j
 32         FORMAT( ' BLOCK ', I4, ' has been assigned to SITE ', I4)
! increment site assignment by 1 relative to input file designations
            isitemld(i) = j + 1
         enddo
      else
         if (mynod == 0 ) write(outu,*) "WARNING: MSLD NSITe detected, assign blocks to sites later with BLASsign"
         isitemld = 2 ! Assign all blocks to site 1
         isitemld(1) = 1 ! Except environment
      endif

! increment total site numbers by 1 relative to input file designations
      nsitemld = max + 1

      call chmalloc('lambda_ltm.src','msld_setup','nsubmld',nblock,intg=nsubmld)
      call chmalloc('lambda_ltm.src','msld_setup','thetamld',nsitemld,nblock,crl=thetamld)
      call chmalloc('lambda_ltm.src','msld_setup','thetamldold',nsitemld,nblock,crl=thetamldold)
      call chmalloc('lambda_ltm.src','msld_setup','thetavmld',nsitemld,nblock,crl=thetavmld)
      call chmalloc('lambda_ltm.src','msld_setup','thetafmld',nsitemld,nblock,crl=thetafmld)
      call chmalloc('lambda_ltm.src','msld_setup','blckmld',nsitemld,nblock,intg=blckmld)
      call chmalloc('lambda_ltm.src','msld_setup','blckmask',nblock,nblock,log=blckmask)
      call chmalloc('lambda_ltm.src','msld_setup','fullblcoep',nblock,nblock,crl=fullblcoep)
      call chmalloc('lambda_ltm.src','msld_setup','fnexp_factors',nsitemld,crl=fnexp_factors)
      count = 0
      do i = lstrt, nblock
          count(isitemld(i)) = count(isitemld(i)) + 1
          blckmld(isitemld(i),count(isitemld(i))) = i
      enddo
      do i = 2, nsitemld
         nsubmld(i) = count(i)
      enddo

      if(prnlev.ge.2) write(outu,33) nsitemld
 33   FORMAT( I4, ' SITES have been assigned for Multi-site Lambda-dynamics')

! setup default cutoff for fixed biases (assigned in ldin lines)
      bicut = 0.8
      bicut2in = 1.0/(bicut*bicut)

! Check for alternative functions:
      fcnal_form = 'nexp'
      def_fnexp_factor = 5.5
      multi_fnexp = .false.

      IF(INDXA(COMLYN,COMLEN,'F2EX').GT.0) THEN
         fcnal_form = '2exp'
         if (mynod == 0 ) write(outu,*) "EXPONENTIAL FUNCTION selected FOR 2-sites for MSLD simulations"
      endif

      IF(INDXA(COMLYN,COMLEN,'F2SI').GT.0) THEN
         fcnal_form = '2sin'
         if (mynod == 0 ) write(outu,*) "SIN FUNCTION selected for 2-site for MSLD simulations"
      endif

      IF(INDXA(COMLYN,COMLEN,'FNSI').GT.0) THEN
         fcnal_form = 'nsin'
         if (mynod == 0 ) write(outu,*) "SUM OF SIN-SQUARED RENORMALIZING function selected for MSLD simulations"
      endif

      IF(INDXA(COMLYN,COMLEN,'FNOR').GT.0) THEN
         fcnal_form = 'norm'
         if (mynod == 0 ) write(outu,*) "RENORMALIZING function selected for MSLD simulations"
      endif

      IF(INDXA(COMLYN,COMLEN,'FFIX').GT.0) THEN
         fcnal_form = 'fixd'
         if (mynod == 0 ) write(outu,*) "FIXED function selected for MSLD simulations"
      endif

      IF(INDXA(COMLYN,COMLEN,'FNXS').GT.0) THEN
         multi_fnexp=.true.
         fcnal_form = 'nexp'
         if (mynod == 0 ) write(outu,*) "FNXS function (Site specific FNEX) selected for MSLD simulations"
         do i=2,nsitemld
            fnexp_factor = nextf(comlyn,comlen)
            if (mynod == 0 ) write(outu,110) i-1,fnexp_factor
            fnexp_factors(i) = fnexp_factor
         enddo
      endif

      if (fcnal_form == 'nexp' .and. (.not. multi_fnexp)) then
         fnexp_factor = gtrmf(comlyn,comlen,'FNEX',def_fnexp_factor)
         if (mynod == 0 ) then
            write(outu,*) "EXP function selected for MSLD simulations"
            write(outu,100) fnexp_factor
         endif
         do i=2,nsitemld
            fnexp_factors(i) = fnexp_factor
         enddo
      endif

      if (fcnal_form == '2exp' .or. fcnal_form == '2sin') then
         call msld_check_sitenum(fcnal_form)
      endif

! setup exp lookup table
      if (fcnal_form /= '2sin' .and. fcnal_form /= 'nsin') then
         call setup_exp_table
      endif

100 format(" FNEXP_FACTOR: ",f10.5)
110 format(" SITE ",i4," FNEXP_FACTOR: ",f10.5)

   END subroutine msld_setup

!> Assign sites after the fact for msld setup
!> Example: assign blocks 2 and 3 to site 1, assign blocks 4 and 5 to site 2
!>
!> BLAS 2 1
!> BLAS 3 1
!> BLAS 4 2
!> BLAS 5 2
   subroutine msld_setup_assign_site(nblock,comlyn,comlen)

      use stream
      use memory
      use string
      use parallel

      implicit none
      character(len=*), intent(inout) :: COMLYN
      INTEGER, intent(inout) :: comlen
      INTEGER, intent(in) :: nblock
      integer :: i, j
      integer, dimension(nblock) :: count

      if (.not.qmld) then
         call wrndie(-3,'<lambda_ltm>', 'Error: BLASsign can only be invoked after MSLD is invoked.')
      endif

      i = nexti(comlyn,comlen) ! Block index
      j = nexti(comlyn,comlen) ! Site index
      if (i<1 .or. i>nblock) then
         call wrndie(-3,'<lambda_ltm>', 'Invalid block selection in BLASsign.')
      endif
      if (j<0 .or. j>=nsitemld) then
         call wrndie(-3,'<lambda_ltm>', 'Invalid site assignment in BLASsign.')
      endif
      if (i.eq.1 .and. j.ne.0) then
         j = 0
         if (mynod == 0 ) write(outu,30)
 30      FORMAT('WARNING: invalid attempt to assign BLOCK 1 to a non-zero SITE. &
&              BLOCK 1 re-assigned to SITE 0')
      elseif (i.ne.1 .and. j.eq.0) then
         if (mynod == 0 ) write(outu,31) i, j
 31      FORMAT('WARNING: invalid attempt to assign BLOCK ', I4, ' to SITE 0. &
&              SITE 0 is reserved for BLOCK 1 only.')
         call wrndie(-3,'<lambda_ltm>', 'Failed attempt to assign blocks to sites.')
      endif
      if(prnlev.ge.2) write(outu,32) i, j
 32   FORMAT( ' BLOCK ', I4, ' has been assigned to SITE ', I4)
! increment site assignment by 1 relative to input file designations
      isitemld(i) = j + 1

      ! Technically this only needs to be done once, but it needs to be done
      ! after the last BLAS so just do it every time.
      count = 0
      blckmld = 0 ! Reset to 0
      do i = lstrt, nblock
          count(isitemld(i)) = count(isitemld(i)) + 1
          blckmld(isitemld(i),count(isitemld(i))) = i
      enddo
      do i = 2, nsitemld
         nsubmld(i) = count(i)
      enddo
   END subroutine msld_setup_assign_site

!-----------------------------------------------------------------------
!> Subroutine for setting up replicas for pH-REX.
   subroutine msld_phrex(comlyn,comlen,nrepdstr,nrepx,nblock)

      use stream
      use memory
      use number
      use string
      use parallel
      use consta

      implicit none
      character(len=*), intent(in) :: COMLYN
      INTEGER, intent(in) :: COMLEN
      integer, intent(in) :: nrepdstr,nrepx,nblock
      integer i,j,k,nrepy

      if (mynod == 0) write(outu,*) 'PH-REX flag recognized, recalculating Gbias values...'
      SPHVAL=GTRMF(COMLYN,COMLEN,'SPH',ONE)
      DPHVAL=GTRMF(COMLYN,COMLEN,'DPH',ONE)
      IF(DPHVAL.LT.ZERO) CALL WRNDIE(-5,'<REPDSTR>', &
                                     'replica EXCHange needs interval between pH.')
      NREPY = NREPDSTR / NREPX
      !GG: NREPY = pH, NREPX = 2nd-order parameter
      DO J=1,NREPY
         DO I=lstrt,nblock
            BIELAMTEMP(J,I)=BIELAM(I)
            !!GG: START of Nucleic Acid CPHMD^MSLD
            IF(BIILAM(I).EQ.'A111') THEN   !GG Create a temp 2D array for transferring new pH biases
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-AN1REF)+A111BIAS)
            ELSE IF(BIILAM(I).EQ.'A113') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-AN1REF)+A113BIAS)
            ELSE IF(BIILAM(I).EQ.'A121') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-AN1REF)+A121BIAS)
            ELSE IF(BIILAM(I).EQ.'C111') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-CN3REF)+C111BIAS)
            ELSE IF(BIILAM(I).EQ.'C113') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-CN3REF)+C113BIAS)
            ELSE IF(BIILAM(I).EQ.'C121') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-CN3REF)+C121BIAS)
            !
            ELSE IF(BIILAM(I).EQ.'ADEU') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-AN1REF)+ADEUBIAS)
            ELSE IF(BIILAM(I).EQ.'CYTU') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-CN3REF)+CYTUBIAS)
            ELSE IF(BIILAM(I).EQ.'UPOS') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-BIRLAM(I))+BIGLAM(I))
            ELSE IF(BIILAM(I).EQ.'UNEG') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-BIRLAM(I))+BIGLAM(I))
            !
            !!GG: START of Protein CPHMD^MSLD
            ELSE IF(BIILAM(I).EQ.'ASP1') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-ASPREF)+ASP1BIAS)
            ELSE IF(BIILAM(I).EQ.'GLU1') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-GLUREF)+GLU1BIAS)
            ELSE IF(BIILAM(I).EQ.'LYS1') THEN
               BIELAMTEMP(J,I)=(-LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-LYSREF)+LYS1BIAS)
            ELSE IF(BIILAM(I).EQ.'HSD1') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-HSDREF)+HSD1BIAS)
            ELSE IF(BIILAM(I).EQ.'HSE1') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-HSEREF)+HSE1BIAS)
            ELSE IF(BIILAM(I).EQ.'HSD2') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-HSDREF)+HSD2BIAS)
            ELSE IF(BIILAM(I).EQ.'HSE2') THEN
               BIELAMTEMP(J,I)=(LOG(TEN)*KBOLTZ*TBLD*((SPHVAL+(DPHVAL*(J-1)))-HSEREF)+HSE2BIAS)
            ELSE IF(BIILAM(I).EQ.'NONE') THEN
               BIELAMTEMP(J,I)=0D0
            ELSE IF(BIILAM(I).EQ.'FIX') THEN
               BIELAMTEMP(J,I)=BIELAM(I)
            ELSE
               CALL WRNDIE(-5,'<LAMBDADYN>', &
                           'Residue not recognized in current version of MSLD CPHMD')
            ENDIF
         ENDDO
         PHVAL=SPHVAL+(DPHVAL*(J-1))
         if (mynod == 0 ) write(outu,*) 'PH value assigned =', PHVAL, 'NREP', J
      ENDDO
      !!GG: Make copies of BIELAMTEMP array for NREPX of replicas for the 2nd order parameter
      IF(NREPX.GT.ONE) THEN
         DO J=1,NREPY
            DO K=J+NREPY,NREPDSTR,NREPY
               DO I=lstrt,nblock
                  BIELAMTEMP(K,I)=BIELAMTEMP(J,I)
               ENDDO
            ENDDO
         ENDDO
      ENDIF
      IF (PRNLEV.ge.5) THEN  !GG Change this a higher number after debug is done!!!!!!!!
         DO J=1,NREPDSTR      !GG Print out recalculated Gbias values for all replicas
            DO I=lstrt,nblock
               write(outu,*) 'NREP,SUB', j, i, 'Gbias', BIELAMTEMP(J,I)
            ENDDO
         ENDDO
      ENDIF
   END subroutine msld_phrex

!-----------------------------------------------------------------------
!> Checks for maximum of 2 substituents per Site for F2SIn and F2Exp functional forms.
!> Terminates with error message if more than 2 substituents are assigned
!> to a given Site.
   subroutine msld_check_sitenum(form)

     use stream

     implicit none
     integer :: i
     character(len=4) :: form

     do i = 2, nsitemld
        if (nsubmld(i).gt.2) then
           write(outu,100) nsubmld(i), i, form
           call wrndie(-2,'<lambdadyn>','Too many substituents assigned per Site.')
        endif
     enddo

100 format("WARNING: ", i4, " substituents assigned for Site ", i4, &
           ". Functional form of lambda ", a4, " can only monitor 2 substituents per Site.")

   END subroutine msld_check_sitenum

!-----------------------------------------------------------------------
!> Sets up look-up table for FNEX functional form of lambda.
!> Invoked from msld_setup
   SUBROUTINE setup_exp_table

      use memory
      use stream
      use consta

      implicit none
      integer :: x

      ! allocate an extra entry on the end in case of rounding errors - probably unnecessary
      allocate(exp_table(0:5001))
      do x = 0, 5001
         exp_table(x) = exp(fnexp_factor*sin(pi*x/2500))
      enddo

   END subroutine setup_exp_table

!-----------------------------------------------------------------------
!> Deallocates lookup tables for sine-based functional
!>    forms of lambda (FNSI and F2SI).
!> Invoked after BLOCK subcommand CLEAR.
   SUBROUTINE msld_deallocate_lookup_tables

      use memory

      implicit none
      integer :: status

      if (fcnal_form /= '2sin' .and. fcnal_form /= 'nsin') then
         deallocate(exp_table,stat=status)
      endif

   END subroutine msld_deallocate_lookup_tables

!-----------------------------------------------------------------------
!> Maps the input lambda values onto the coefficient matrix.
!> Invoked from BLOCK subcommand MSMA.
!> The MSMA keyword is the Multi-Site lambda-dynamics equivalent to the LDMAtrix command
!> and will automatically map the input lambda values onto the coefficient matrix of the
!> interaction energies (and forces) between blocks.
  subroutine msld_matrix(nblock,ninter,blcop)

    use stream

    implicit none
    integer, intent(in) :: nblock, ninter
    integer :: i
    real(chm_real), dimension(nsitemld) :: lnorm
    real(chm_real), dimension(ninter), intent(inout) :: BLCOP

    if(qmld) then
       lnorm = 0.0
#if KEY_DEBUG==1
       if (prnlev.gt.10) write(outu,100) (bixlam(i), i=lstrt,nblock)  
#endif
       do i = lstrt, nblock
          bixlam(i) = bixlam(i)*bixlam(i)
          lnorm(isitemld(i)) = lnorm(isitemld(i)) + bixlam(i)
       enddo
       do i = lstrt, nblock
          bixlam(i)=bixlam(i)/lnorm(isitemld(i))
       enddo
#if KEY_DEBUG==1
       if (prnlev.gt.10) write(outu,100) (bixlam(i), i=lstrt,nblock) 
#endif
       call msld_settheta(nblock,bixlam)

       bldold = 0.0
       bldold(1) = 1.0
       BLCOP = 0.0
       call msld_setblckmask(nblock)
       call msld_setup_blcoef(nblock,ninter,bixlam,blcop)

#if KEY_DEBUG==1
       if (prnlev.gt.10) write(outu,100) (bixlam(i), i=lstrt,nblock) 
#endif
       if (prnlev >= 2) WRITE (OUTU,200)
    else
       IF (WRNLEV.GE.2) WRITE(OUTU,201)
    endif

100    format("BIXLAM: ",12f15.5)
200    FORMAT('>>> BLOCK MATRIX WAS REBUILT ')
201    FORMAT('WARNING: MLMA command ignored. MLMA must be invoked after MDLM.')

  END subroutine msld_matrix

!-----------------------------------------------------------------------
!> Sets up coefficient matrix.
!>\verbatim
!> Lambda(block 1) = 1.0
!> Coefficient(i,j) = 1,  i=j
!> Coefficient(i,j) = 0,  i and j on the same Site
!> Coefficient(i,j) = lambda(i)*lambda(j), i and j on different Sites
!>\endverbatim
  subroutine msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

    implicit none
    integer, intent(in) :: nblock, ninter
    integer :: i, j, k
    real(chm_real), dimension(nblock), intent(in) :: bxlamb
    real(chm_real), dimension(ninter), intent(out) :: BLCOP

    if (nsitemld.gt.2) then
       k = 0
       DO I = 1, NBLOCK                          !(rows)
          DO J = 1, I                            !(columns)
             k = k + 1
             IF (J.EQ.1) THEN                    !(1st column)
                BLCOP(K) = BXLAMB(I)
             ELSE IF (J.EQ.I) THEN              !(diagonal)
                BLCOP(K) = BXLAMB(I)
             ELSE IF (ISITEMLD(I).NE.ISITEMLD(J)) THEN  !(diff SITES)
                BLCOP(K) = BXLAMB(I)*BXLAMB(J)
             ENDIF
          ENDDO
       ENDDO
    else
       k = 0
       DO I = 1, NBLOCK                          !(rows)
          DO J = 1, I                            !(columns)
             k = k + 1
             IF (J.EQ.1) THEN                    !(1st column)
                BLCOP(K) = BXLAMB(I)
             ELSE IF (J.EQ.I) THEN              !(diagonal)
                BLCOP(K) = BXLAMB(I)
             ENDIF
          ENDDO
       ENDDO
    endif

    call msld_setfullblcoef(nblock,bxlamb)

  END subroutine msld_setup_blcoef

!-----------------------------------------------------------------------
!> Prepares the mask of the coefficient matrix.
!> All off-diagonal elements are set to false.
  subroutine msld_setblckmask(nblock)

    implicit none
    integer, intent(in) :: nblock
    integer :: i, j

    blckmask = .true.

    if (nsitemld.gt.2) then
       DO I = lstrt, NBLOCK
          DO J = i+1, nblock
             IF (ISITEMLD(I).eq.ISITEMLD(J)) THEN  !(diff SITES)
                blckmask(i,j) = .false.
                blckmask(j,i) = .false.
             ENDIF
          ENDDO
       ENDDO
    else
       DO I = lstrt, NBLOCK                !(rows)
          DO J = i+1, nblock               !(columns)
             blckmask(i,j) = .false.       !(off-diagonal sites)
             blckmask(j,i) = .false.       !(off-diagonal sites)
          ENDDO
       ENDDO
    endif

  END subroutine msld_setblckmask

!-----------------------------------------------------------------------
!> Constructs symmetric coefficient matrix from one-sided matrix.
!> Invoked from msld_matrix and msld_setblcoef_FORM.
  subroutine msld_setfullblcoef(nblock,bxlamb)

    implicit none
    integer, intent(in) :: nblock
    integer :: i, j
    real(chm_real), dimension(nblock), intent(in) :: bxlamb
    real(chm_real), dimension(nblock,nblock) :: zeromatrix
    real(chm_real) :: coef

    zeromatrix = 0
    do i = 1, nblock
! diagonal elements
       fullblcoep(i,i) = BXLAMB(I)
       do j = i+1, nblock
! all off-diagonal elements
          coef = BXLAMB(I)*BXLAMB(J)
          fullblcoep(i,j) = coef
          fullblcoep(j,i) = coef
       enddo
    enddo

! delete all interactions between different blocks within a given site
    fullblcoep = merge(fullblcoep,zeromatrix,blckmask)

  END subroutine msld_setfullblcoef

!-----------------------------------------------------------------------
!> Sanity check for intramolecular interactions.
!> Invoked after END BLOCK.\n
!> Checks that all intramolecular interactions include
!> contributions from (a) different blocks on the same site or
!> (b) more than two non-environment (site 1) sites.
   subroutine msld_blchek(iblock)

      use memory
      use psf
      use stream

      implicit none
      integer :: i, j, k, count, check
      integer, dimension(natom), intent(in) :: iblock
      integer, dimension(4) :: bl

! check and assign ANGLES
      bl(4) = 0
      do i = 1, ntheta
         bl(1) = iblock(it(i))
         bl(2) = iblock(jt(i))
         bl(3) = iblock(kt(i))
         count = 0
         do j = 1, 2
            do k = j, 3
               if (bl(j).ne.bl(k)) then
                  if (isitemld(bl(j)).eq.isitemld(bl(k))) then
                     call wrndie(-3,'<msld_blchek>','ILLEGAL BLOCKING.')
                  else
                     count = count + 1
                  endif
              endif
            enddo
         enddo
         if (count.eq.3) then
            check = min(bl(1), bl(2), bl(3))
            if (check.ne.1) call wrndie(-3,'<msld_blchek>','ILLEGAL BLOCKING.')
         endif
      enddo

! check and assign DIHDERALS
      do i = 1, nphi
         bl(1) = iblock(ip(i))
         bl(2) = iblock(jp(i))
         bl(3) = iblock(kp(i))
         bl(4) = iblock(lp(i))
         count = 0
         do j = 1, 3
            do k = j, 4
               if (bl(j).ne.bl(k)) then
                  if (isitemld(bl(j)).eq.isitemld(bl(k))) then
                     call wrndie(-3,'<msld_blchek>','ILLEGAL BLOCKING.')
                  else
                     count = count + 1
                  endif
              endif
            enddo
         enddo
         if (count.ge.5) then
            check = min(bl(1),bl(2),bl(3),bl(4))
            if (count.eq.6 .or. check.ne.1) call wrndie(-3,'<msld_blchek>','ILLEGAL BLOCKING.')
         endif
      enddo

! check and assign IMPROPERS
      do i = 1, nimphi
         bl(1) = iblock(im(i))
         bl(2) = iblock(jm(i))
         bl(3) = iblock(km(i))
         bl(4) = iblock(lm(i))
         count = 0
         do j = 1, 3
            do k = j, 4
               if (bl(j).ne.bl(k)) then
                  if (isitemld(bl(j)).eq.isitemld(bl(k))) then
                     call wrndie(-3,'<msld_blchek>','ILLEGAL BLOCKING.')
                  else
                     count = count + 1
                  endif
              endif
            enddo
         enddo
         if (count.ge.5) then
            check = min(bl(1),bl(2),bl(3),bl(4))
            if (count.eq.6 .or. check.ne.1) call wrndie(-3,'<msld_blchek>','ILLEGAL BLOCKING.')
         endif
      enddo

   END subroutine msld_blchek

!-----------------------------------------------------------------------
!> Assigns flags to indicate whether or not bonded interactions should be scaled.
!> Invoked at the end of BLOCK.
!> 1) allocate arrays and
!> 2) assign arrays
   subroutine msld_assign_flags(iblock,qnobo,qnoub,qnoan,qnoph,qnoim,qnoct)

      use memory
      use psf
      use stream

      implicit none
      integer :: i, ibl, jbl, kbl, sbl, checkmin
      integer, dimension(8) :: atmp
      integer, dimension(natom), intent(in) :: iblock
      logical, intent(in) :: qnobo, qnoub, qnoan, qnoph, qnoim, qnoct

! initialize msld arrays
! (note: these arrays are deallocated when BLOCK CLEAR is invoked)
      if (.not.qflagson) call msld_allocate_flags

! fill bonded arrays
!assign BONDS
      do i = 1, nbond
         atmp(1) = ib(i)
         atmp(2) = jb(i)
         call msld_assign_bonded(2,atmp,qnobo,2,iblock,ibl,jbl,kbl,sbl)
         mldbondc(i) = ibl+jbl*(jbl-1)/2
         mldbondj(i) = jbl
         mldbondi(i) = ibl
         mldbonds(i) = sbl
         if(prnlev.gt.5) write(outu,40) i,ib(i),jb(i),ibl,jbl,sbl
40       format('bond: i: ',i5,'  1st:',i5,'  2nd:',i5,' coefi:',i5,' coefj:',i5, 'soft:',i5)
      enddo

!assign UREY-BRADLEY TERMS
      do i = 1, ntheta
         ! ! Old method doesn't make sense
         ! ibl = min(iblock(it(i)),iblock(kt(i)))
         ! jbl = max(iblock(it(i)),iblock(kt(i)))
         ! if (ibl.eq.jbl .and. ibl.ne.iblock(jt(i))) then
         !     ibl = min(iblock(it(i)),iblock(jt(i)))
         !     jbl = max(iblock(it(i)),iblock(jt(i)))
         ! endif
         atmp(1) = it(i)
         atmp(2) = jt(i)
         atmp(3) = kt(i)
         call msld_assign_bonded(3,atmp,qnoub,2,iblock,ibl,jbl,kbl,sbl)
         mldureyc(i) = ibl+jbl*(jbl-1)/2
         mldureyj(i) = jbl
         mldureyi(i) = ibl
         mldureys(i) = sbl
         if(prnlev.gt.5) write(outu,46) i,it(i),jt(i),kt(i),ibl,jbl,sbl
46       format('UBterm: i: ',i5,'  1st:',i5,'  2nd:',i5,' 3rd:' i5, ' coefi:',i5,' coefj:',i5,' soft:',i5)
      enddo

! check and assign ANGLES
      do i = 1, ntheta
         ! ! Old method doesn't make sense
         ! ibl = min(iblock(it(i)),iblock(jt(i)),iblock(kt(i)))
         ! jbl = max(iblock(it(i)),iblock(jt(i)),iblock(kt(i)))
         atmp(1) = it(i)
         atmp(2) = jt(i)
         atmp(3) = kt(i)
         call msld_assign_bonded(3,atmp,qnoan,2,iblock,ibl,jbl,kbl,sbl)
         mldangc(i) = ibl+jbl*(jbl-1)/2
         mldangj(i) = jbl
         mldangi(i) = ibl
         mldangs(i) = sbl
         if(prnlev.gt.5) write(outu,25) i,it(i),jt(i),kt(i),ibl,jbl,sbl
25       format('angle: i: ',i5,'  1st:',i5,'  2nd:',i5,'  3rd:',i5,' coefi:',i5,' coefj:',i5,' soft:',i5)
      enddo

! check and assign DIHDERALS
      do i = 1, nphi
         atmp(1) = ip(i)
         atmp(2) = jp(i)
         atmp(3) = kp(i)
         atmp(4) = lp(i)
         call msld_assign_bonded(4,atmp,qnoph,2,iblock,ibl,jbl,kbl,sbl)
         mlddihc(i) = ibl+jbl*(jbl-1)/2
         mlddihj(i) = jbl
         mlddihi(i) = ibl
         mlddihs(i) = sbl
         if(prnlev.gt.5) write(outu,35) i,ip(i),jp(i),kp(i),lp(i),ibl,jbl,sbl
35       format('dihedral: i: ',i5,'  1st:',i5,'  2nd:',i5,'  3rd:',i5,'  4th:',i5,' coefi:',i5,' coefj:',i5,' soft:',i5)
      enddo

! check and assign IMPROPERS
      do i = 1, nimphi
         atmp(1) = im(i)
         atmp(2) = jm(i)
         atmp(3) = km(i)
         atmp(4) = lm(i)
         call msld_assign_bonded(4,atmp,qnoim,2,iblock,ibl,jbl,kbl,sbl)
         mldimpc(i) = ibl+jbl*(jbl-1)/2
         mldimpj(i) = jbl
         mldimpi(i) = ibl
         mldimps(i) = sbl
         if(prnlev.gt.5) write(outu,45) i,im(i),jm(i),km(i),lm(i),ibl,jbl,sbl
45       format('improper: i: ',i5,'  1st:',i5,'  2nd:',i5,'  3rd:',i5,'  4th:',i5,' coefi:',i5,' coefj:',i5,' soft:',i5)
      enddo

! check and assign CMAP
      do i = 1, ncrterm
         atmp(1) = i1ct(i)
         atmp(2) = j1ct(i)
         atmp(3) = k1ct(i)
         atmp(4) = l1ct(i)
         atmp(5) = i2ct(i)
         atmp(6) = j2ct(i)
         atmp(7) = k2ct(i)
         atmp(8) = l2ct(i)
         call msld_assign_bonded(8,atmp,qnoct,3,iblock,ibl,jbl,kbl,sbl)
         if (sbl.eq.1) call wrndie(-3,'<msld_assign_flags>', &
            'I AM NOT WRITING SOFT CMAP INTERACTIONS. YOU SHOULD SET UP YOUR SYSTEM DIFFERENTLY. IF YOU LOVE SUFFERING ENOUGH TO WRITE IT YOURSELF, YOU CAN START IN SOURCE/ENERGY/ECMAP.SRC')
         mldcmapc(i) = IBL+JBL*(JBL-1)/2 ! Meaningless since cmap is 3-way
         mldcmapk(i) = kbl
         mldcmapj(i) = jbl
         mldcmapi(i) = ibl
         mldcmaps(i) = sbl
         if(prnlev.gt.5) write(outu,55) i,i1ct(i),j1ct(i),k1ct(i),l1ct(i),i2ct(i),j2ct(i),k2ct(i),l2ct(i),ibl,jbl,kbl,sbl
55       format('cmap: i: ',i5,'  1st:',i5,'  2nd:',i5,'  3rd:',i5,'  4th:',i5,'  1st:',i5,'  2nd:',i5,'  3rd:',i5,'  4th:',i5,' coefi:',i5,' coefj:',i5,' coefk:',i5,' soft:',i5)
      enddo

!jlk---add CMAP and MMFF
!rlh---added CMAP, no MMFF yet

   END subroutine msld_assign_flags

!-----------------------------------------------------------------------
!> Assigns flags to indicate whether or not bonded interactions should be scaled.
   subroutine msld_assign_bonded(natmp,atmp,qnoflag,nlam,iblock,ibl,jbl,kbl,sbl)
      use psf
      use stream

      implicit none
      integer, intent(in) :: natmp
      integer, dimension(8), intent(in) :: atmp
      logical, intent(in) :: qnoflag
      integer, intent(in) :: nlam ! write out either 2 or 3 lambdas into ibl, jbl, and kbl
      integer, dimension(natom), intent(in) :: iblock

      integer, intent(out) :: ibl, jbl, kbl, sbl

      integer :: hbl
      integer :: i, j, k, l
      integer, dimension(8) :: bl,bls

      hbl = 1
      ibl = 1
      jbl = 1
      kbl = 1
      do i=1,natmp
         bl(i) = iblock(atmp(i))
         if (qldm_scalecons) then
            bls(i) = iblcks(atmp(i))
         else
            bls(i) = 0
         endif
         if (jbl.lt.bl(i)) jbl = bl(i)
      enddo
      do i=1,natmp
         if (ibl.lt.bl(i) .and. bl(i).lt.jbl) ibl = bl(i)
      enddo
! off diagonal elements
      if (ibl.ne.jbl .and. isitemld(ibl).eq.isitemld(jbl)) then
         call wrndie(-3,'<msld_assign_bonded>','ILLEGAL BOND BLOCKING.')
      endif
      if (nlam.gt.2) then
         kbl = jbl
         jbl = ibl
         ibl = 1
         do i=1,natmp
            if (ibl.lt.bl(i) .and. bl(i).lt.jbl) ibl = bl(i)
         enddo
! off diagonal elements
         if (ibl.ne.jbl .and. isitemld(ibl).eq.isitemld(jbl)) then
            call wrndie(-3,'<msld_assign_bonded>','ILLEGAL BOND BLOCKING.')
         endif
         if (ibl.ne.kbl .and. isitemld(ibl).eq.isitemld(kbl)) then
            call wrndie(-3,'<msld_assign_bonded>','ILLEGAL BOND BLOCKING.')
         endif
      endif
      do i=1,natmp
         if (hbl.lt.bl(i) .and. bl(i).lt.ibl) hbl = bl(i)
      enddo
      if (hbl.gt.1) then
         call wrndie(-3,'<msld_assign_bonded>','ILLEGAL BOND BLOCKING.')
      endif
      sbl = 0
      if (qsobo) then
         do i = 1,nsobo
            do j = 1,natmp
               do k = j+1,natmp
                  if (atmp(j).eq.soboi(i) .and. atmp(k).eq.soboj(i)) sbl = 1
                  if (atmp(j).eq.soboj(i) .and. atmp(k).eq.soboi(i)) sbl = 1
               enddo
            enddo
         enddo
      endif
      if (qnoflag .and. sbl.eq.0) then
! override block coefficients
         if (qldm_scalecons) then
            do j = 1,natmp
               if (bls(j).ne.bl(j)) then
                  if (ibl.eq.bl(j)) then
                     ibl = 1
                  endif
                  if (jbl.eq.bl(j)) then
                     jbl = ibl
                     ibl = 1
                  endif
                  if (nlam.gt.2 .and. kbl.eq.bl(j)) then
                     kbl = jbl
                     jbl = ibl
                     ibl = 1
                  endif
               endif
            enddo
         else
            ibl = 1
            jbl = 1
            kbl = 1
         endif
      endif
   end subroutine msld_assign_bonded

!-----------------------------------------------------------------------
!> Initializes arrays required in subroutine msld_assign_flags.
   subroutine msld_allocate_flags

      use memory
      use psf

      implicit none

! initialize bonded arrays
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldbondc',nbond,intg=mldbondc)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldangc',ntheta,intg=mldangc)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mlddihc',nphi,intg=mlddihc)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldimpc',nimphi,intg=mldimpc)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldcmapc',ncrterm,intg=mldcmapc)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldureyc',ntheta,intg=mldureyc)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldbondi',nbond,intg=mldbondi)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldangi',ntheta,intg=mldangi)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mlddihi',nphi,intg=mlddihi)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldimpi',nimphi,intg=mldimpi)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldcmapi',ncrterm,intg=mldcmapi)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldureyi',ntheta,intg=mldureyi)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldbondj',nbond,intg=mldbondj)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldangj',ntheta,intg=mldangj)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mlddihj',nphi,intg=mlddihj)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldimpj',nimphi,intg=mldimpj)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldcmapj',ncrterm,intg=mldcmapj)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldureyj',ntheta,intg=mldureyj)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldbonds',nbond,intg=mldbonds)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldangs',ntheta,intg=mldangs)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mlddihs',nphi,intg=mlddihs)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldimps',nimphi,intg=mldimps)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldcmaps',ncrterm,intg=mldcmaps)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldureys',ntheta,intg=mldureys)
      call chmalloc('lambda_ltm.src','msld_allocate_flags','mldcmapk',ncrterm,intg=mldcmapk)
      qflagson = .true.

   END subroutine msld_allocate_flags

!-----------------------------------------------------------------------
!> Deallocates arrays used in subroutine msld_assign_flags.
!> Invoked from BLOCK subcommand CLEAR.
   subroutine msld_deallocate_flags

      use memory
      use psf

      implicit none

      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldbondc',nbond,intg=mldbondc)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldangc',ntheta,intg=mldangc)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mlddihc',nphi,intg=mlddihc)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldimpc',nimphi,intg=mldimpc)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldcmapc',ncrterm,intg=mldcmapc)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldureyc',ntheta,intg=mldureyc)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldbondi',nbond,intg=mldbondi)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldangi',ntheta,intg=mldangi)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mlddihi',nphi,intg=mlddihi)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldimpi',nimphi,intg=mldimpi)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldcmapi',ncrterm,intg=mldcmapi)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldureyi',ntheta,intg=mldureyi)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldbondj',nbond,intg=mldbondj)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldangj',ntheta,intg=mldangj)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mlddihj',nphi,intg=mlddihj)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldimpj',nimphi,intg=mldimpj)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldcmapj',ncrterm,intg=mldcmapj)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldureyj',ntheta,intg=mldureyj)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldbonds',nbond,intg=mldbonds)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldangs',ntheta,intg=mldangs)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mlddihs',nphi,intg=mlddihs)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldimps',nimphi,intg=mldimps)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldcmaps',ncrterm,intg=mldcmaps)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldureys',ntheta,intg=mldureys)
      call chmdealloc('lambda_ltm.src','msld_deallocate_flags','mldcmapk',ncrterm,intg=mldcmapk)
      qflagson = .false.

   END subroutine msld_deallocate_flags

!-----------------------------------------------------------------------
!> Deallocates memory for MSLD routines.
!> Invoked from BLOCK subcommand CLEAR.\n
!>  from subroutine ldm_block_clear when QMLD (set by MSLD) is active
   subroutine msld_deallocate_multisiteparams(nblock)

      use memory
      use psf

      implicit none
      integer, intent(in) :: nblock

      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','nsubmld',nblock,intg=nsubmld)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','thetamld',nsitemld,nblock,crl=thetamld)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','thetamldold',nsitemld,nblock,crl=thetamldold)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','thetavmld',nsitemld,nblock,crl=thetavmld)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','thetafmld',nsitemld,nblock,crl=thetafmld)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','blckmld',nsitemld,nblock,intg=blckmld)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','blckmask',nblock,nblock,log=blckmask)
      call chmdealloc('lambdadyn.src','msld_deallocate_multisiteparams','fullblcoep',nblock,nblock,crl=fullblcoep)

   END subroutine msld_deallocate_multisiteparams

!-----------------------------------------------------------------------
!> Accumulates forces on theta values associated with each block.
!> Invoked from mlmd2_scale routines from energy call routines when QMLD is active.
!> APH Jan 2015: Optional arguments for "local" versions of biflam and biflam2 added.
!>               The local biflam, biflam2 are used in threaded versions of code to avoid
!>               race condition.
   subroutine msld_lambdaforce(ibl,jbl,energy,biflam_loc,biflam2_loc)

      use stream
      use number

      implicit none
      integer, intent(in) :: ibl, jbl
      real(chm_real), intent(in) :: energy
      real(chm_real), intent(inout), optional :: biflam_loc(:), biflam2_loc(:)

      if (present(biflam_loc) .and. present(biflam2_loc)) then
         if (ibl.eq.jbl) then
            biflam_loc(ibl) = biflam_loc(ibl) + energy
         elseif (ibl.eq.1) then
            biflam_loc(jbl) = biflam_loc(jbl) + energy
         elseif (jbl.eq.1) then
            biflam_loc(ibl) = biflam_loc(ibl) + energy
         elseif (isitemld(ibl).ne.isitemld(jbl)) then
            biflam2_loc(jbl) = biflam2_loc(jbl) + bixlam(ibl)*energy
            biflam2_loc(ibl) = biflam2_loc(ibl) + bixlam(jbl)*energy
         endif
      else
         if (ibl.eq.jbl) then
            biflam(ibl) = biflam(ibl) + energy
         elseif (ibl.eq.1) then
            biflam(jbl) = biflam(jbl) + energy
         elseif (jbl.eq.1) then
            biflam(ibl) = biflam(ibl) + energy
         elseif (isitemld(ibl).ne.isitemld(jbl)) then
            biflam2(jbl) = biflam2(jbl) + bixlam(ibl)*energy
            biflam2(ibl) = biflam2(ibl) + bixlam(jbl)*energy
         endif
      endif
      
   END subroutine msld_lambdaforce

!-----------------------------------------------------------------------
!> Accumulates forces on theta values associated with each block for a three way interaction
!> Currently assumes ibl, jbl, and kbl are in ascending order and all in different blocks
!> Reasonable assumption when function was written because it is only used by cmap interactions
   subroutine msld_lambdaforce3(ibl,jbl,kbl,energy,coef)

      use stream
      use number

      implicit none
      integer, intent(in) :: ibl, jbl, kbl
      real(chm_real), intent(in) :: energy
      ! real(chm_real), intent(inout), optional :: biflam_loc(:), biflam2_loc(:)
      real(chm_real), intent(out) :: coef

      if (kbl.eq.1) then
         coef = 1
      elseif (jbl.eq.1) then
         biflam(kbl) = biflam(kbl) + energy
         coef = bixlam(kbl)
      elseif (ibl.eq.1) then
         biflam2(jbl) = biflam2(jbl) + bixlam(kbl)*energy
         biflam2(kbl) = biflam2(kbl) + bixlam(jbl)*energy
         coef = bixlam(jbl)*bixlam(kbl)
      else
         biflam2(ibl) = biflam2(ibl) + bixlam(jbl)*bixlam(kbl)*energy
         biflam2(jbl) = biflam2(jbl) + bixlam(ibl)*bixlam(kbl)*energy
         biflam2(kbl) = biflam2(kbl) + bixlam(ibl)*bixlam(jbl)*energy
         coef = bixlam(ibl)*bixlam(jbl)*bixlam(kbl)
      endif

   END subroutine msld_lambdaforce3

!-----------------------------------------------------------------------
!> Scales Urey-Bradley and Angle forces by block coefficients.
!> Invoked from EANGLFS and EBONDFS for use in qldm_ureybr(blcop,nblock,mm,df,da)
!>    in energy subroutines when QMLD is active.
!> Energies are accumulated in the energy subroutines by force*factor,
!>   so scaling the forces by the appropriate lambda coefficient is sufficient.
   subroutine msld_scale_force(compute,ibl,jbl,blcop,force,energy)

      use stream
      use number

      implicit none
      integer, intent(in) :: compute, ibl, jbl
      real(chm_real), intent(in) :: blcop, energy
      real(chm_real), intent(inout) :: force

      if (compute.ne.1) then
         if (compute.gt.1) then
            call msld_lambdaforce(ibl,jbl,energy)
            force = force*blcop
#if KEY_DEBUG==1
            if (prnlev.gt.12) then
               write(outu,100) ibl, biflam(ibl), biflam2(ibl), jbl, biflam(jbl), biflam2(jbl)
            endif
#endif 
         else
            force = zero
         endif
      endif

100 format("msld_scale_force> ", i5, 2f15.5, i5, 2f15.5)

   END subroutine msld_scale_force

!-----------------------------------------------------------------------
!> Scales BOND forces by block coefficients.
!> Invoked from EBONDFS for use in qldm_bonds
!>    in energy subroutines when QMLD is active.
   subroutine msld_bond_scale_force(qnobo,ibl,jbl,force,energy)

      use stream
      use number

      implicit none
      logical, intent(in) :: qnobo
      integer, intent(in) :: ibl, jbl
      real(chm_real), intent(in) :: energy
      real(chm_real), intent(inout) :: force
      real(chm_real) :: scale

      scale = fullblcoep(ibl,jbl)
      if (scale.ne.1) then
         if (scale.gt.0) then
            if (.not.qnobo) then
               call msld_lambdaforce(ibl,jbl,energy)
#if KEY_DEBUG==1
               if (prnlev.gt.12) then
                  write(outu,100) ibl, biflam(ibl), biflam2(ibl), jbl, biflam(jbl), biflam2(jbl)
               endif
#endif 
               force = force*scale
            endif
         else
            force = zero
         endif
      endif

100 format("msld_bond_scale_force> ", i5, 2f15.5, i5, 2f15.5)

   END subroutine msld_bond_scale_force

   ! *
   ! * Returns scaling factor between block ibl and jbl
   ! * APH 11/7/2013
   ! *
   subroutine msld_get_scale(ibl,jbl,scale)
     use stream
     use number
     implicit none
     integer, intent(in) :: ibl, jbl
     real(chm_real), intent(out) :: scale

     scale = fullblcoep(ibl,jbl)
     if (scale < zero) scale = zero

     return
   END subroutine msld_get_scale

!-----------------------------------------------------------------------
!> Scales energies and forces by block coefficents.
!>  Invoked from ENBA and ENBFS8 for use in nonbonded energy subroutines
!>     when QMLD is active.
!> APH Jan 2015: Optional arguments for "local" versions of biflam and biflam2 added.
!>               The local biflam, biflam2 are used in threaded versions of code to avoid
!>               race condition.
   SUBROUTINE msld_nb_scale_enerforce(iblck,jblck,force1,energy1,force2,energy2,&
        biflam_loc,biflam2_loc)

      use stream
      use number

      implicit none
      integer, intent(in) :: iblck, jblck
      integer :: ibl, jbl
      real(chm_real), intent(inout) :: force1, energy1, force2, energy2
      real(chm_real) :: scale
      real(chm_real), intent(inout), optional :: biflam_loc(:), biflam2_loc(:)

      ibl=iblck
      jbl=jblck
      scale = fullblcoep(ibl,jbl)
      if (scale /= 1) then
         if (scale.gt.0) then
            if (present(biflam_loc) .and. present(biflam2_loc)) then
               call msld_lambdaforce(ibl,jbl,energy1,biflam_loc,biflam2_loc)
               call msld_lambdaforce(ibl,jbl,energy2,biflam_loc,biflam2_loc)
            else
               call msld_lambdaforce(ibl,jbl,energy1)
               call msld_lambdaforce(ibl,jbl,energy2)
            endif
#if KEY_DEBUG==1
            if (prnlev.gt.12) then
               write(outu,100) ibl, biflam(ibl), biflam2(ibl), jbl, biflam(jbl), biflam2(jbl)
            endif
#endif
            force1 = force1*scale
            energy1 = energy1*scale
            force2 = force2*scale
            energy2 = energy2*scale
         else
            force1 = zero
            energy1 = zero
            force2 = zero
            energy2 = zero
         endif
      endif

100 format("msld_nb_scale_enerforce> ", i5, 2f15.5, i5, 2f15.5)

   END subroutine msld_nb_scale_enerforce

!-----------------------------------------------------------------------
!> Scales energies and forces by block coefficents.
!>  Invoked from ENBA and ENBFS8 for use in nonbonded energy subroutines
!>     when QMLD is active.
!> APH Jan 2015: Optional arguments for "local" versions of biflam and biflam2 added.
!>               The local biflam, biflam2 are used in threaded versions of code to avoid
!>               race condition.
   SUBROUTINE msld_nbsoft_scale_enerforce(iblck,jblck,force1,energy1,force2,energy2,&
        drpdr, drpds, &
        biflam_loc,biflam2_loc)

      use stream
      use number

      implicit none
      integer, intent(in) :: iblck, jblck
      integer :: ibl, jbl
      real(chm_real), intent(inout) :: force1, energy1, force2, energy2
      real(chm_real), intent(in) :: drpdr, drpds
      real(chm_real) :: scale
      real(chm_real), intent(inout), optional :: biflam_loc(:), biflam2_loc(:)

      ibl=iblck
      jbl=jblck
      scale = fullblcoep(ibl,jbl)
      if (scale /= 1) then
         if (scale.gt.0) then
            if (present(biflam_loc) .and. present(biflam2_loc)) then
               call msld_lambdaforce(ibl,jbl,energy1+force1*scale*drpds, &
                  biflam_loc,biflam2_loc)
               call msld_lambdaforce(ibl,jbl,energy2+force2*scale*drpds, &
                  biflam_loc,biflam2_loc)
            else
               call msld_lambdaforce(ibl,jbl,energy1+force1*scale*drpds)
               call msld_lambdaforce(ibl,jbl,energy2+force2*scale*drpds)
            endif
#if KEY_DEBUG==1
            if (prnlev.gt.12) then
               write(outu,100) ibl, biflam(ibl), biflam2(ibl), jbl, biflam(jbl), biflam2(jbl)
            endif
#endif
            force1 = force1*scale*drpdr
            energy1 = energy1*scale
            force2 = force2*scale*drpdr
            energy2 = energy2*scale
         else
            force1 = zero
            energy1 = zero
            force2 = zero
            energy2 = zero
         endif
      endif

100 format("msld_nb_scale_enerforce> ", i5, 2f15.5, i5, 2f15.5)

   END subroutine msld_nbsoft_scale_enerforce

!-----------------------------------------------------------------------
!> Scales DIHE and IMPR energies and forces by block coefficents.
!>  Invoked from EPHIFS for use in qldm_dihe(blcop,nblock,mm,df,da)
!>     in energy subroutines when QMLD is active.
   subroutine msld_scale_enerforce(compute,ibl,jbl,blcop,force,energy)

      use stream
      use number

      implicit none
      integer, intent(in) :: compute, ibl, jbl
      real(chm_real), intent(in) :: blcop
      real(chm_real), intent(inout) :: force, energy

      if (compute.ne.1) then
         if (compute.gt.1) then
            call msld_lambdaforce(ibl,jbl,energy)
#if KEY_DEBUG==1
            if (prnlev.gt.12) then
               write(outu,100) ibl, biflam(ibl), biflam2(ibl), jbl, biflam(jbl), biflam2(jbl)
            endif
#endif 
            force = force*blcop
            energy = energy*blcop
         else
            force = zero
            energy = zero
         endif
      endif

100 format("msld_scale_enerforce> ", i5, 2f15.5, i5, 2f15.5)

   END subroutine msld_scale_enerforce

!-----------------------------------------------------------------------
!> Assigns initial velocities to lambda values.
!> Invoked from dynamc subroutines.
   subroutine msld_assignvelocities(temnew,nblock,bvlamb,iseed,iasvel)

      use stream
      use number
      use consta

      implicit none
      integer :: i
      integer, intent(in) :: nblock, iasvel, iseed
      real(chm_real) :: boltz, sd, vel
      real(chm_real), intent(in) :: temnew
      real(chm_real), intent(out), dimension(nblock) :: bvlamb

      BOLTZ=TEMNEW*KBOLTZ
      if (IASVEL.EQ.0) THEN
            IF(PRNLEV.GE.2) WRITE(OUTU,22)
  22     FORMAT(' NOTE: IASVEL is zero when assignment is requested.', &
              ' Lambda Velocities unchanged.')
      else
         do i = lstrt,nblock
            SD=BOLTZ/bimlam(i)
            SD=SQRT(SD)
            CALL GAUSSI(ZERO,SD,VEL,ISEED,IASVEL)
            bvlamb(I)=VEL
         enddo
      endif

   END subroutine msld_assignvelocities

!-----------------------------------------------------------------------
!> Assigns lambda values from thetas according to FNORM functional form.
!> Invoked from msld_setblcoef during dynamc subroutines
   subroutine msld_setblcoef_norm(nblock,ninter,bxlamb,blcop)

      use stream

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j, k, intx
      real(chm_real), dimension(nblock), intent(out) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP
      real(chm_real) :: bx2

      bxlamb(1) = 1.0
      do i = 2, nsitemld
         do j = 1, nsubmld(i)
#if KEY_DEBUG==1
            if (prnlev.gt.9) write(outu,100) i, j, bxlamb(blckmld(i,j)) 
#endif
            bxlamb(blckmld(i,j)) = thetamld(i,j) * thetamld(i,j)
#if KEY_DEBUG==1
            if (prnlev.gt.9) write(outu,110) i, j, bxlamb(blckmld(i,j)) 
#endif
         enddo
      enddo

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

100 format("testing_bxlambpre_norm> ", 2i10, f15.10)
110 format("testing_bxlambpost_norm> ", 2i10, f15.10)

   END subroutine msld_setblcoef_norm

!-----------------------------------------------------------------------
!> Assigns lambda values from thetas according to F2SIN functional form.
!> Invoked from msld_setblcoef during dynamc subroutines.
   subroutine msld_setblcoef_f2sin(nblock,ninter,bxlamb,blcop)

      use stream

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j, k, intx
      real(chm_real), dimension(nblock), intent(out) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP
      real(chm_real) :: bx2

      bxlamb(1) = 1.0
      do i = 2, nsitemld
         bxlamb(blckmld(i,1)) = sin(thetamld(i,1))*sin(thetamld(i,1))
         bxlamb(blckmld(i,2)) = 1.0 - bxlamb(blckmld(i,1))
#if KEY_DEBUG==1
         if (prnlev.gt.9) then
             write(outu,110) 1, 2, bxlamb(blckmld(i,1)), bxlamb(blckmld(i,2))
         endif
#endif 
      enddo

110 format("testing_bxlambpre_f2sin> ", 2i10, 2f15.10)

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

   END subroutine msld_setblcoef_f2sin

!-----------------------------------------------------------------------
!> Assigns lambda values from thetas according to F2EXP functional form.
!> Invoked from msld_setblcoef during dynamc subroutines
   subroutine msld_setblcoef_f2exp(nblock,ninter,bxlamb,blcop)

      use stream

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j, k, intx
      real(chm_real), dimension(nblock), intent(out) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP

      bxlamb(1) = 1.0
      do i = 2, nsitemld
         bxlamb(blckmld(i,2)) = 1.0/(1.0+exp(thetamld(i,1)))
         bxlamb(blckmld(i,1)) = exp(thetamld(i,1))*bxlamb(blckmld(i,2))
#if KEY_DEBUG==1
         if (prnlev.gt.9) then
            write(outu,110) 1, 2, bxlamb(blckmld(i,1)), bxlamb(blckmld(i,2))
         endif
#endif 
      enddo

110 format("testing_bxlambpre_f2exp> ", 2i10, 2f15.10)

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

   END subroutine msld_setblcoef_f2exp

!-----------------------------------------------------------------------
!> Assigns lambda values from thetas according to FNSIN functional form.
!> Invoked from msld_setblcoef during dynamc subroutines.
   subroutine msld_setblcoef_fnsin(nblock,ninter,bxlamb,blcop)

      use stream

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j, k, intx
      real(chm_real), dimension(nblock) :: num
      real(chm_real), dimension(nblock), intent(out) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP
      real(chm_real) :: bx2

      bxlamb(1) = 1.0
      do i = 2, nsitemld
         bx2 = 0.0
         do j = 1, nsubmld(i)
             num(j) = sin(thetamld(i,j)) * sin(thetamld(i,j))
             bx2 = bx2 + num(j)
         enddo
         do j = 1, nsubmld(i)
             bxlamb(blckmld(i,j)) = num(j)/bx2
#if KEY_DEBUG==1
             if (prnlev.gt.9) write(outu,110) i, j, bxlamb(blckmld(i,j)) 
#endif
         enddo
      enddo

110 format("testing_setblcoef_fnsin> ", 2i10, f15.10)

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

   END subroutine msld_setblcoef_fnsin

!-----------------------------------------------------------------------
!> Assigns lambda values from thetas according to FNEXP functional form.
!> Invoked from msld_setblcoef during dynamc subroutines.
   subroutine msld_setblcoef_fnexp(nblock,ninter,bxlamb,blcop)

      use stream

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j, k, intx
      real(chm_real), dimension(nblock) :: num
      real(chm_real), dimension(nblock), intent(out) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP
      real(chm_real) :: th
      real(chm_real) :: denom

      if (prnlev.ge.8) then
         write(outu,*) "testing_lookup_fnexp>  i,  j,  num(j),  thetamld(i,j),  bxlamb(blckmld(i,j))"
      endif

      bxlamb(1) = 1.0
      do i = 2, nsitemld
         denom = 0.0
         do j = 1, nsubmld(i)
             IF(QTHEOLD) THEN
                th=thetamldold(i,j) !GG Need to use old ThetaX in replica exchange since it hasn't update yet
             else
                th=thetamld(i,j)
             endif
             if (fnexp_factor==fnexp_factors(i)) then
                num(j) = lookupint_exp(th)
             else
                num(j) = exp(fnexp_factors(i)*sin(th))
             endif
             if (prnlev.ge.8) then
                write(outu,110) i, j, num(j), th, bxlamb(blckmld(i,j)) !GG
             endif
             denom = denom + num(j)
         enddo
         do j = 1, nsubmld(i)
             bxlamb(blckmld(i,j)) = num(j)/denom !GG "calculates" lambda value for precalc grid of theta->lamba correspondence
             if (prnlev.ge.8) then
                write(outu,120) i, j, bxlamb(blckmld(i,j))     !GG
             endif
         enddo
      enddo

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

110 format("testing_lookup_fnexp_pre> ", 2i5, 3f15.10)
120 format("testing_lookup_fnexp_post> ", 2i5, f15.10)

   END subroutine msld_setblcoef_fnexp

!-----------------------------------------------------------------------
!> Assigns lambda values from thetas according to FFIX functional form.
!> Invoked from msld_setblcoef during dynamc subroutines.
   subroutine msld_setblcoef_ffix(nblock,ninter,bxlamb,blcop)

      use stream

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j
      real(chm_real), dimension(nblock), intent(out) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP

      bxlamb(1) = 1.0
      do i = 2, nsitemld
         do j = 1, nsubmld(i)
             IF(QTHEOLD) THEN
                bxlamb(blckmld(i,j)) = thetamldold(i,j) !GG Need to use old ThetaX in replica exchange since it hasn't update yet
             ELSE
                bxlamb(blckmld(i,j)) = thetamld(i,j)
             ENDIF
             if (prnlev.ge.8) then
                write(outu,120) i, j, bxlamb(blckmld(i,j))     !GG
             endif
         enddo
      enddo

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

120 format("testing_ffix> ", 2i5, f15.10)

   END subroutine msld_setblcoef_ffix

!-----------------------------------------------------------------------
!> Distributes assignment of lambda values from thetas according to functional form.
!> Invoked from dynamics subroutines
   subroutine msld_setblcoef(nblock,ninter,bxlamb,blcop)

      use number
      use stream
      use parallel

      implicit none
      integer, intent(in) :: nblock, ninter
      integer :: i, j
      real(chm_real), dimension(nblock), intent(inout) :: bxlamb
      real(chm_real), dimension(ninter), intent(out) :: BLCOP
      real(chm_real), dimension(ninter) :: num
      real(chm_real) :: denom, denom1, odenom

      bldold = bxlamb
      bxlamb(1) = 1.0
      biflam = zero
      biflam2 = zero

      select case (fcnal_form)
      case ('2sin')
         call msld_setblcoef_f2sin(nblock,ninter,bxlamb,blcop)
      case ('2exp')
         call msld_setblcoef_f2exp(nblock,ninter,bxlamb,blcop)
      case ('norm')
         call msld_setblcoef_norm(nblock,ninter,bxlamb,blcop)
      case ('nsin')
         call msld_setblcoef_fnsin(nblock,ninter,bxlamb,blcop)
      case ('nexp')
         call msld_setblcoef_fnexp(nblock,ninter,bxlamb,blcop)
      case ('fixd')
         call msld_setblcoef_ffix(nblock,ninter,bxlamb,blcop)
      end select

      call msld_setup_blcoef(nblock,ninter,bxlamb,blcop)

   END subroutine msld_setblcoef

!-----------------------------------------------------------------------
!> Sets QTHEOLD flag as TRUE. This tells msld_setblcoeff_fnexp to use
!> thetamold(i,j) for calculating coefficients
   subroutine msld_swapcoeff_mod

      use stream

      QTHEOLD = .TRUE.

   END subroutine msld_swapcoeff_mod

!-----------------------------------------------------------------------
!> Sets QTHEOLD flag as FALSEE. This tells msld_setblcoeff_fnexp to use
!> thetam(i,j) for calculating coefficients (the normal way)
   subroutine msld_swapcoeff_norm

      use stream

      QTHEOLD = .FALSE.

   END subroutine msld_swapcoeff_norm

!-----------------------------------------------------------------------
!> Sets QNORAND flag as TRUE. This disables LD in theta dynamics. For
!> testing purposes
   subroutine msld_norand

      use stream

      QNORAND = .TRUE.

   END subroutine msld_norand

!-----------------------------------------------------------------------
!> Adds scaled fixed biases to potential energy total.
!> Invoked from energy/energy.src subroutine.
   subroutine msld_add_potentialenergy(nblock,bxlamb,energy)

      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j
      real(chm_real), intent(in), dimension(nblock) :: bxlamb
      real(chm_real), intent(inout) :: energy
      real(chm_real) :: bx, be, en

      en = 0.0

if (prnlev .gt. 9) then
      do i = lstrt, nblock
            write(outu,100) i, bielam(i), bxlamb(i), en
      enddo
endif

! add potential energy to interactions with other sites
      do i = lstrt, nblock
         be = bielam(i)
         bx = bxlamb(i)
         en = en - be*bx  ! GG Lambda x Gbias

!#IF DEBUG
         if (prnlev .gt. 9) then
            write(outu,100) i, bielam(i), bxlamb(i), en
         endif
!#ENDIF
      enddo
      energy = energy + en
      call msld_add_biasenergy(energy)

100 format("addbiasenergy> ", i5, 3f10.5)

   END subroutine msld_add_potentialenergy

!-----------------------------------------------------------------------
!> Generates random force.
   subroutine getrandomforce(num,frandtheta)

      use consta
      use clcg_mod,only : random
      use number
      use rndnum
      use stream
      use reawri
      use parallel !GG

      implicit none
      integer :: ig
      integer, intent(in) :: num
      real(chm_real) :: pis, a, b
      real(chm_real), intent(out) :: frandtheta

      IF (MYNOD == 0) THEN

! compute random force (frandtheta)
         PIS=PI
         if (qoldrng) then                        !yw 05-Aug-2008
            A=gammatheta(1)*SQRT(MINTWO*LOG(RANDOM(ISEED)))
            B=TWO*PIS*RANDOM(ISEED)
         else
            IG=1
            A=gammatheta(1)*SQRT(MINTWO*LOG(RANDOM(IG)))
            B=TWO*PIS*RANDOM(IG)
         endif
         if (mod(num,2) == 0) then
            frandtheta=A*COS(B)
         else
            frandtheta=A*SIN(B)
         endif

#if KEY_DEBUG==1
         if (prnlev.gt.11) write(outu,100) a, b, frandtheta  
#endif

         IF(QNORAND) THEN      !GG: Option to turn off random forces (for debugging)
            frandtheta=0D0
         ENDIF

      ENDIF
#if KEY_PARALLEL==1
      CALL PSND8(frandtheta,1) 
#endif
      IF(prnlev.ge.8) THEN     !GG: Option to writeout frandtheta values
         write(outu,'(a5,f12.6)') 'FRAND', frandtheta
      ENDIF

100 format("check_frand> ", 3f15.10)

   END subroutine getrandomforce

!-----------------------------------------------------------------------
!> Calculates force on each theta according to FNORM functional form.
!> Invoked from msld_add_force during dynamc subroutines.
   subroutine msld_add_force_norm(nblock)

      use consta
      use dimens_fcm
      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k
      real(chm_real) :: frandtheta

      call msld_fixedbiasforce(nblock,biflam)
      do i = 2, nsitemld
         do j = 1, nsubmld(i)
            call getrandomforce(i,frandtheta)
            thetafmld(i,j) = -two*thetamld(i,j)*(biflam(blckmld(i,j)) + biflam2(blckmld(i,j))) + frandtheta

#if KEY_DEBUG==1
            if (prnlev.gt.10) then
               write(outu,120) i,j, frandtheta, thetamld(i,j), thetafmld(i,j)
            endif
#endif 
         enddo
      enddo

100 format("test_biflam_norm> ", i10, 2f25.10)
120 format("test_frandtheta_norm> ", 2i5,3f15.10)

   END subroutine msld_add_force_norm

!-----------------------------------------------------------------------
!> Calculates force on each theta according to F2EXP functional form.
!> Invoked from msld_add_force during dynamc subroutines.
   subroutine msld_add_force_f2exp(nblock)

      use consta
      use dimens_fcm
      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, ijbl, ikbl
      real(chm_real) :: frandtheta, force1, force2

      call msld_fixedbiasforce(nblock,biflam)
      do i = 2, nsitemld
         call getrandomforce(i,frandtheta)
         ijbl = blckmld(i,1)
         ikbl = blckmld(i,2)
         force1 = biflam(ijbl) + biflam2(ijbl)
         force2 = biflam(ikbl) + biflam2(ikbl)
         thetafmld(i,1) = -bixlam(ijbl)*bixlam(ikbl)*(force1 - force2) + frandtheta

#if KEY_DEBUG==1
         if (prnlev.gt.10) then
            write(outu,120) i, frandtheta, thetamld(i,1), thetafmld(i,1)
         endif
#endif 
      enddo

100 format("test_add_force_f2exp> ", i10, 2f25.10)
120 format("test_frandtheta_f2exp> ", i5,3f15.10)

   END subroutine msld_add_force_f2exp

!-----------------------------------------------------------------------
!> Calculates force on each theta according to F2SIN functional form.
!> Invoked from msld_add_force during dynamc subroutines.
   subroutine msld_add_force_f2sin(nblock)

      use consta
      use dimens_fcm
      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, ijbl, ikbl
      real(chm_real) :: frandtheta, force1, force2

      call msld_fixedbiasforce(nblock,biflam)
      do i = 2, nsitemld
         call getrandomforce(i,frandtheta)
         ijbl = blckmld(i,1)
         ikbl = blckmld(i,2)
         force1 = biflam(ijbl) + biflam2(ijbl)
         force2 = biflam(ikbl) + biflam2(ikbl)
         thetafmld(i,1) = -(two*sin(thetamld(i,1))*cos(thetamld(i,1))*(force1 - force2)) + frandtheta

#if KEY_DEBUG==1
         if (prnlev.gt.10) then
            write(outu,120) i, frandtheta, thetamld(i,1), thetafmld(i,1)
            write(*,130) i, thetafmld(i,1), force1, force2, frandtheta
         endif
#endif 
         enddo

100 format("test_add_force_f2sin> ", i10, 2f25.5)
120 format("test_frandtheta_f2sin> ", i5, 3f15.5)
130 format("test_add_force_f2sin> ", i5, f15.5," ", f15.5," ",f15.5," ",f15.5, " ",f15.5)

   END subroutine msld_add_force_f2sin

!-----------------------------------------------------------------------
!> Calculates force on each theta according to FNSIN functional form.
!> Invoked from msld_add_force during dynamc subroutines.
   subroutine msld_add_force_fnsin(nblock)

      use consta
      use dimens_fcm
      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, ijbl, ikbl
      real(chm_real) :: frandtheta, force1, force2

      call msld_fixedbiasforce(nblock,biflam)
      do i = 2, nsitemld
         do j = 1, nsubmld(i)
            call getrandomforce(i,frandtheta)
            ijbl = blckmld(i,j)
            force1 = (one-bixlam(ijbl))*(biflam(ijbl)+biflam2(ijbl))
            force2 = zero
            do k = 1, nsubmld(i)
               if (k.ne.j) then
                  ikbl = blckmld(i,k)
                  force2 = force2 + bixlam(ikbl)*(biflam(ikbl)+biflam2(ikbl))
               endif
            enddo
            if (sin(thetamld(i,j)).eq.zero) then
               write(outu,*) "WARNING... sin(thetamld(i,j))=0"
            endif
            thetafmld(i,j) = -two*cos(thetamld(i,j))/sin(thetamld(i,j))*bixlam(ijbl)*(force1-force2)+frandtheta

#if KEY_DEBUG==1
            if (prnlev.gt.10) then
               write(outu,110) cos(thetamld(i,j)), thetafmld(i,j)
               write(outu,120) i, j, force1, force2, sin(thetamld(i,j)), biflam(ijbl)
               write(outu,130) i, j, bixlam(ijbl)
               write(outu,140) i,j, frandtheta, thetafmld(i,j)
            endif
#endif 
         enddo
      enddo

100 format("test_biflam_fnsin> ", i10, 2f25.10)
110 format("test_addforce1_norsim> ", 2f10.6)
120 format("test_addforce2_fnsin> ", 3i5, 4f10.6)
130 format("test_bixlam_fnsin> ", 2i5, f10.6)
140 format("test_frandtheta_fnsin> ", 2i5,2f25.10)

   END subroutine msld_add_force_fnsin

!-----------------------------------------------------------------------
!> Calculates force on each theta according to FNEXP functional form.
!> Invoked from msld_add_force during dynamc subroutines.
   subroutine msld_add_force_fnexp(nblock)

      use consta
      use dimens_fcm
      use stream
      use number
      use memory

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, ijbl, ikbl
      real(chm_real) :: frandtheta, force1, force2

! adds force from fixed (from ldin) and variable (from ldbv) biases into biflam
      call msld_fixedbiasforce(nblock,biflam)

! computes forces on each substituent on each site
      do i = 2, nsitemld
         do j = 1, nsubmld(i)
            call getrandomforce(i,frandtheta)
            ijbl = blckmld(i,j)

! force1 indicates term that needs to be scaled by d(lambda(A))/d(theta(A))
! d(lambda(A))/d(theta(A)) = fnexp_factor*cos(theta(A))*lambda(A)*(1-lambda(A))
            force1 = (one-bixlam(ijbl))*(biflam(ijbl) + biflam2(ijbl))
            force2 = zero
            do k = 1, nsubmld(i)
               if (k.ne.j) then
                  ikbl = blckmld(i,k)

                  if (prnlev.gt.10) then
                     write(outu,110) i, j, k, biflam(ikbl), biflam2(ikbl)
                     write(outu,115) i, j, k, cos(thetamld(i,j)), bixlam(ikbl)
                  endif

! force2 indicates term that needs to be scaled by d(lambda(B))/d(theta(A))
! d(lambda(B))/d(theta(A)) = -fnexp_factor*cos(theta(A))*lambda(A)*lambda(B)
                  force2 = force2 + bixlam(ikbl)*(biflam(ikbl) + biflam2(ikbl))

!#IF DEBUG
                  if (prnlev.gt.10) then
                     write(outu,110) i, j, k, biflam(ikbl), biflam2(ikbl)
                     write(outu,115) i, j, k, cos(thetamld(i,j)), bixlam(ikbl)
                  endif
!#ENDIF
               endif
            enddo

! compute overall force (forcemld) for this theta value
            thetafmld(i,j) = -fnexp_factors(i)*cos(thetamld(i,j))*bixlam(ijbl)*(force1-force2)+frandtheta
!#IF DEBUG
            if (prnlev.gt.10) then
               write(outu,130) i, j, thetafmld(i,j), force1, force2, frandtheta
            endif
!#ENDIF
         enddo
      enddo

!#IF DEBUG
         if (prnlev.ge.8) then
            write(outu,*) "test_add_force_fnexp>  i,  j,  thetamld(i,j),  thetafmld(i,j)"
            do i = 2, nsitemld
               do j = 1, nsubmld(i)
                  write(outu,120) i, j, thetamld(i,j), thetafmld(i,j)
               enddo
            enddo
         endif
!#ENDIF

100 format("test_biflam_fnexp> ", i10, 2f25.10)
110 format("test_add_force_fnexp> ", 3i5, f15.5,"  ",f15.5," ",f15.5)
115 format("test_add_force_fnexp> ", 3i5, f15.5,"  ",f15.5)
120 format("test_add_force_fnexp> ", 2i5, f15.5,"  ",f15.5)
130 format("test_add_force_fnexp> ", 2i5, f15.5," ", f15.5," ",f15.5," ",f15.5, " ",f15.5)
140 format("test_add_force_fnexp2>", 2i5, f15.5," ", f15.5)

   END subroutine msld_add_force_fnexp

!-----------------------------------------------------------------------
!> Calculates force on each theta according to FFIX functional form.
!> Invoked from msld_add_force during dynamc subroutines.
   subroutine msld_add_force_ffix(nblock)

      use consta
      use dimens_fcm
      use stream
      use number
      use memory

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, ijbl, ikbl
      real(chm_real) :: frandtheta, force1, force2

! adds force from fixed (from ldin) and variable (from ldbv) biases into biflam
      call msld_fixedbiasforce(nblock,biflam)

! computes forces on each substituent on each site
      do i = 2, nsitemld
         do j = 1, nsubmld(i)
            thetafmld(i,j) = 0
         enddo
      enddo

   END subroutine msld_add_force_ffix

!-----------------------------------------------------------------------
!> Invoked by msld_add_force_* subroutines.
!> Compatible with only with fnexp so far
  subroutine msld_fixedbiasforce(nblock,force)

      use chm_kinds
      use number
      use stream

      implicit none

      integer :: i
      integer, intent(in) :: nblock
      real(chm_real), intent(inout), dimension(nblock) :: force
      real(chm_real) :: bx, be

if (prnlev .gt. 10) then
      do i = lstrt, nblock
         write(outu,100) i, bielam(i), bixlam(i), force(i)
      enddo
endif

      do i = lstrt, nblock
         be = bielam(i)
         if (be .ne. 0.0) then
            force(i) = force(i) -be
         endif
      enddo

! computes forces from variables biases (set in ldbi lines)
      call msld_varbiasforce(nblock,force)

!#IF DEBUG
      if (prnlev .gt. 9) then
         do i = lstrt, nblock
             write(outu,100) i, bielam(i), bixlam(i), force(i), biflam(i)+biflam2(i)
         enddo
      endif
!#ENDIF

100 format("msld_fixedbiasforce> ", i5, 4f10.5)

    END subroutine msld_fixedbiasforce

!-----------------------------------------------------------------------
!> Invoked by msld_add_force_fnexp.
!> WARNING: ONLY COMPATIBLE WITH FNEXP functional form
  subroutine msld_varbiasforce(nblock,force)

      use chm_kinds
      use number
      use stream

      implicit none

      integer :: i, j, k, l, site
      integer, intent(in) :: nblock
      real(chm_real), intent(inout), dimension(nblock) :: force
      real(chm_real) :: bx, cont

      do k = 1, nbiasv
         cont = zero
         i = ibvidi(k)
         if (ibclas(k) .eq. 3) then
             j = ibvidj(k)
             bx = bixlam(i) - bixlam(j)
             cont = ikbias(k)*ipbias(k)*(bx)**(ipbias(k)-1)
             force(j) = force(j) - cont
         elseif (ibclas(k) .eq. 6) then
             !! potential en = en + ikbias(k)*bx*bixlam(j)
             j = ibvidj(k)
             cont = ikbias(k)*bixlam(j)
             force(j) = force(j) + ikbias(k)*bixlam(i)
         elseif (ibclas(k) .eq. 8) then
             !! potential en = en + ikbias(k)*bx*bixlam(j)/(bx+irreup(k))
             j = ibvidj(k)
             cont = ikbias(k)*irreup(k)*bixlam(j)/((bixlam(i)+irreup(k))*(bixlam(i)+irreup(k)))
             force(j) = force(j) + ikbias(k)*bixlam(i)/(bixlam(i)+irreup(k))
         elseif (ibclas(k) .eq. 9) then
             !! potential en = en + ikbias(k)*bixlam(j)*(1-((bx+irreup(k))/irreup(k))**ipbias(k))
             j = ibvidj(k)
             cont = ikbias(k)*bixlam(j)*(-ipbias(k)/irreup(k))*((bixlam(i)+irreup(k))/irreup(k))**(ipbias(k)-1)
             force(j) = force(j) + ikbias(k)*(1-((bixlam(i)+irreup(k))/irreup(k))**ipbias(k))
         elseif (ibclas(k) .eq. 10) then
             !! potential en = en + ikbias(k)*bixlam(j)*(1-exp(irreup(k)*bx))
             j = ibvidj(k)
             cont = ikbias(k)*bixlam(j)*(-irreup(k)*exp(irreup(k)*bixlam(i)))
             force(j) = force(j) + ikbias(k)*(1-exp(irreup(k)*bixlam(i)))
         else
            bx = bixlam(i)
            if (ibclas(k) .eq. 1) then
               if (bx .lt. irreup(k)) then
                  cont = ikbias(k)*ipbias(k)*(bx - irreup(k))**(ipbias(k)-1)
               endif
            elseif (ibclas(k) .eq. 2) then
               if (bx .gt. irrlow(k)) then
                  cont = ikbias(k)*ipbias(k)*(bx - irrlow(k))**(ipbias(k)-1)
               endif
            elseif (ibclas(k) .eq. 4) then
               if (bx .lt. bicut) then
                   cont = - ikbias(k)*2.0*bicut2in*(bx-bicut)
               endif
            elseif (ibclas(k) .eq. 5) then
               cont = - ikbias(k)
            elseif (ibclas(k) .eq. 7) then
               !! potential en = en + ikbias(k)*bx*(1-bx)/(bx+irreup(k))
               cont = ikbias(k)*(irreup(k)*(1+irreup(k))/((bx+irreup(k))*(bx+irreup(k))) - 1)
            endif
         endif

         if (cont.ne.0) then
            ! add force contribution to "same" block
            force(i) = force(i) + cont
         endif

!#IF DEBUG
         if(prnlev.gt.9) then
            if (ibclas(k) .eq. 2) then
               write(outu,100) k, cont, ibvidi(k), ibvidj(k), ikbias(k), ipbias(k), irrlow(k)
            else
               write(outu,100) k, cont, ibvidi(k), ibvidj(k), ikbias(k), ipbias(k), irreup(k)
            endif
         endif
!#ENDIF
      enddo

100 format("varbiasforce> ", i5, f15.10, 2i5, f10.5, i5, f10.5)

    END subroutine msld_varbiasforce

!-----------------------------------------------------------------------
!> Distributes theta force calculations according to functional form.
!> Invoked from dynamics subroutines.
   subroutine msld_add_force(nblock)

      use consta
      use dimens_fcm
      use number
      use reawri
      use stream
#if KEY_PARALLEL==1
      use parallel             
#endif

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, cblck
      real(chm_real) :: s2theta, frandtheta, force, force2, denom, odenom

#if KEY_PARALLEL==1
      call gcomb(biflam,nblock)
      call gcomb(biflam2,nblock)
#endif 

      IF(QTHEOLD) THEN
         IF(prnlev.ge.6) THEN
            write(outu,*) 'Skipping msld theta force updates'
         ENDIF
         GOTO 77
      ENDIF

      select case (fcnal_form)
      case ('norm')
         call msld_add_force_norm(nblock)
      case ('2sin')
         call msld_add_force_f2sin(nblock)
      case ('2exp')
         call msld_add_force_f2exp(nblock)
      case ('nsin')
         call msld_add_force_fnsin(nblock)
      case ('nexp')
         call msld_add_force_fnexp(nblock)
      case ('fixd')
         call msld_add_force_ffix(nblock)
      end select

77    CONTINUE

   END subroutine msld_add_force

!-----------------------------------------------------------------------
!> Computes first theta values.
!> Invoked from dynamics routines.
   subroutine msld_firsttheta(nblock,delta)

      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j
      real(chm_real), intent(in) :: delta
      real(chm_real) :: fact, alpha, delta2, tempxla, rsum, rsum3, vsum

      delta2 = delta*delta
      fact = delta2*gammatheta(3)/thetam
      alpha = 2.0*gammatheta(3)*gammatheta(4)*delta
      thetavmld = zero
      tempxla = zero

       select case (fcnal_form)
       case ('norm')
          do i = 2, nsitemld
             rsum = zero
             vsum = zero
             do j = 1, nsubmld(i)
#if KEY_DEBUG==1
                if (prnlev > 7) write(outu,110) i, j, thetamld(i,j), thetavmld(i,j), thetafmld(i,j) 
#endif
                tempxla = thetamld(i,j)
                thetamld(i,j) = thetamld(i,j) + thetavmld(i,j)*alpha + thetafmld(i,j)*fact
                thetavmld(i,j) = (thetamld(i,j) - tempxla)/delta
                rsum = rsum + thetamld(i,j)*thetamld(i,j)
                vsum = vsum + thetamld(i,j)*thetavmld(i,j)
             enddo
             rsum = one/sqrt(rsum)
             rsum3 = rsum*rsum*rsum
             do j = 1, nsubmld(i)
                thetavmld(i,j) = -vsum*thetamld(i,j)*rsum3 + thetavmld(i,j)*rsum
                thetamld(i,j) = thetamld(i,j)*rsum
#if KEY_DEBUG==1
                if (prnlev > 7) write(outu,120) i, j, thetamld(i,j), thetavmld(i,j), thetafmld(i,j) 
#endif
             enddo
          enddo
       case ('nsin', 'nexp')
          do i = 2, nsitemld
             do j = 1, nsubmld(i)
#if KEY_DEBUG==1
                if (prnlev > 7) write(outu,110) i, j, thetamld(i,j), thetavmld(i,j), thetafmld(i,j) 
#endif
                tempxla = thetamld(i,j)
                thetamld(i,j) = thetamld(i,j) + thetavmld(i,j)*alpha + thetafmld(i,j)*fact
                thetavmld(i,j) = (thetamld(i,j) - tempxla)/delta
#if KEY_DEBUG==1
                if (prnlev > 7) write(outu,120) i, j, thetamld(i,j), thetavmld(i,j), thetafmld(i,j) 
#endif
             enddo
          enddo
       case ('2sin', '2exp')
          do i = 2, nsitemld
             do j = 1, nsubmld(i) - 1
#if KEY_DEBUG==1
                if (prnlev > 7) write(outu,110) i, j, thetamld(i,j), thetavmld(i,j), thetafmld(i,j) 
#endif
                tempxla = thetamld(i,j)
                thetamld(i,j) = thetamld(i,j) + thetavmld(i,j)*alpha + thetafmld(i,j)*fact
                thetavmld(i,j) = (thetamld(i,j) - tempxla)/delta
#if KEY_DEBUG==1
                if (prnlev > 7) write(outu,120) i, j, thetamld(i,j), thetavmld(i,j), thetafmld(i,j) 
#endif
             enddo
          enddo
       end select

110 format("firsttheta_pre> ", 2i5, 15f15.10)
120 format("firsttheta_post> ", 2i5, 15f15.10)

   END subroutine msld_firsttheta

!-----------------------------------------------------------------------
!> Calculates new theta values.
!> Invoked from dynamics routines.
   subroutine msld_updatetheta(nblock,delta)

      use stream
      use number
      use memory

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j
      real(chm_real), intent(in) :: delta
      real(chm_real) :: rsum, rsum3, vsum

      thetamldold = thetamld
      select case (fcnal_form)
      case ('norm')
         do i = 2, nsitemld
            rsum = zero
            vsum = zero
            do j = 1, nsubmld(i)
               thetavmld(i,j) = gammatheta(3)*thetavmld(i,j) + gammatheta(2)*thetafmld(i,j)
               thetamld(i,j) = thetamld(i,j) + thetavmld(i,j)*delta
               rsum = rsum + thetamld(i,j)*thetamld(i,j)
               vsum = vsum + thetavmld(i,j)*thetamld(i,j)
            enddo
            rsum = one/sqrt(rsum)
            rsum3 = rsum*rsum*rsum
            do j = 1, nsubmld(i)
               thetavmld(i,j) = -vsum*thetamld(i,j)*rsum3 + thetavmld(i,j)*rsum
               thetamld(i,j) = thetamld(i,j)*rsum
            enddo
         enddo
      case ('nsin', 'nexp')
         do i = 2, nsitemld
            do j = 1, nsubmld(i)
               thetavmld(i,j) = gammatheta(3)*thetavmld(i,j) + gammatheta(2)*thetafmld(i,j)
               thetamld(i,j) = thetamld(i,j) + thetavmld(i,j)*delta
            enddo
         enddo
      case ('2sin', '2exp')
         do i = 2, nsitemld
            thetavmld(i,1) = gammatheta(3)*thetavmld(i,1) + gammatheta(2)*thetafmld(i,1)
            thetamld(i,1) = thetamld(i,1) + thetavmld(i,1)*delta
         enddo
      end select
      !if (prnlev.ge.8) then    !GG
      !   do i = 2, nsitemld
      !      do j = 1, nsubmld(i)
      !         if (prnlev.ge.8) then   !GG
      !         write(outu,100) i, j, gammatheta(3),gammatheta(2),thetamld(i,j), thetavmld(i,j), thetafmld(i,j)
      !         endif
      !      enddo
      !   enddo
      !endif
#if KEY_DEBUG==1
      if (prnlev.gt.10) then
         select case (fcnal_form)
         case ('norm', 'nsin', 'nexp')
            do i = 2, nsitemld
               do j = 1, nsubmld(i)
                  write(outu,100) i, j, gammatheta(3),gammatheta(2),thetamld(i,j), thetavmld(i,j), thetafmld(i,j)
               enddo
            enddo
         case ('2sin', '2exp')
            do i = 2, nsitemld
               write(outu,110) i, gammatheta(3),gammatheta(2),thetamld(i,1), thetavmld(i,1), thetafmld(i,1)
            enddo
         end select
      endif
#endif 

100 format("test_updatetheta> ", 2i5, 5f15.5)
110 format("test_updatetheta> ", i5, 5f15.5)

   END subroutine msld_updatetheta

!-----------------------------------------------------------------------
!> Adds theta contribution to kinetic energy total.
!> Invoked from dynamc subroutines.\n
!> Converts theta velocities into kinetic energy and adds
!> to cumulative kinetic energy total.
   SUBROUTINE MSLD_ADD_KINETICENERGY(NBLOCK,TEMPI)

      use stream
      use parallel

      implicit none
      integer, intent(in) :: nblock
      real(chm_real), intent(inout) :: tempi

      integer :: i, j

      if (mynod /= 0) return
      if (prnlev .gt. 10) then
         write(outu,110) tempi
      endif
      select case (fcnal_form)
      case ('2sin', '2exp')
         do i = 2, nsitemld
            tempi = tempi + thetavmld(i,1)*thetavmld(i,1)*thetam
         enddo
      case ('norm', 'nexp', 'nsin')
         do i = 2, nsitemld
            do j = 1, nsubmld(i)
               tempi = tempi + thetavmld(i,j)*thetavmld(i,j)*thetam
               if (prnlev .gt. 10) then
                  write(outu,100) tempi, thetavmld(i,j), thetam
               endif
            enddo
         enddo
      end select

100   format("msld_add_kinetic post   > ", 3f12.5)
110   format("msld_add_kinetic initial> ", f12.5)

   END SUBROUTINE MSLD_ADD_KINETICENERGY

!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
   subroutine ldm_init_qmcfr
     use number
     implicit none

     wangf = wangfi
     mcpro(1:mcboxes) = zero
     mccount(1:mcboxes) = 0
   end subroutine ldm_init_qmcfr

!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
   subroutine msld_ndegf(nblock,ndegf)

     use stream
     implicit none

     integer, intent(in) :: nblock
     integer, intent(inout) :: ndegf

     if (prnlev > 10 ) write(outu,100) ndegf
     select case (fcnal_form)
     case ('2sin', '2exp')
        ndegf = ndegf + nsitemld
     case ('norm', 'nexp', 'nsin')
        ndegf = ndegf + nblock - 1
     end select

     if (prnlev > 7) write(outu,100) ndegf

100  format("msld_ndegf > ", i12)

   end subroutine msld_ndegf

!-----------------------------------------------------------------------

!> Assigns individual theta values from lambda values according to FNORM functional form.
!> Invoked from msld_settheta during dynamc subroutines.
   subroutine msld_settheta_norm(nblock,bxlamb)

      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j
      real(chm_real) :: sum
      real(chm_real), intent(in), dimension(nblock) :: bxlamb

      do i = 2, nsitemld
         do j = 1, nsubmld(i)
            thetamld(i,j) = sqrt(bxlamb(blckmld(i,j)))
#if KEY_DEBUG==1
            if (prnlev.gt.9) write(outu,100) i, j, thetamld(i,j)  
#endif
         enddo
      enddo

100 format("testing_theta_norm> ", 2i5, " ", f15.8)

   END subroutine msld_settheta_norm

!-----------------------------------------------------------------------
!> Assigns individual theta values from lambda values according to F2SIN functional form.
!> Invoked from msld_settheta during dynamc subroutines.
   subroutine msld_settheta_f2sin(nblock,bxlamb)

      use stream

      implicit none
      integer, intent(in) :: nblock
      integer :: i
      real(chm_real), intent(in), dimension(nblock) :: bxlamb

      do i = 2, nsitemld
         thetamld(i,1) = asin(sqrt(bxlamb(blckmld(i,1))))
#if KEY_DEBUG==1
         if (prnlev.gt.9) write(outu,100) i, 1, bxlamb(blckmld(i,1)), thetamld(i,1) 
#endif
      enddo

100 format("testing_theta_f2sin> ", 2i5, " ", 2f15.8)

   END subroutine msld_settheta_f2sin

!-----------------------------------------------------------------------
!> Assigns individual theta values from lambda values according to FNSIN functional form.
!> Invoked from msld_settheta during dynamc subroutines.
!> Checks to ensure a minimum initial lambda value of 0.001 for better sampling.
!> If sin(thetamld(i,j)) = 0 then the force on thetamld(i,j) will be 0.
   subroutine msld_settheta_fnsin(nblock,bxlamb)

      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, count
      real(chm_real) :: s2, ttl, minlambda
      real(chm_real), intent(inout), dimension(nblock) :: bxlamb

      do i = 2, nsitemld
! check bounds
         minlambda = 0.00001
         count = 0
         ttl = 0.0
         do j = 1, nsubmld(i)
            if (bxlamb(blckmld(i,j)).lt.minlambda) then
                bxlamb(blckmld(i,j)) = minlambda
                count = 1
                write(outu,*) "WARNING: Incompatible initial lambda value for Block: ", blckmld(i,j)
            endif
            ttl = ttl + bxlamb(blckmld(i,j))
         enddo
! renormalize if needed
         if (count.eq.1) then
            write(outu,*) "WARNING: Renormalizing initial lambda values."
            ttl = 1.0/ttl
            do j = 1, nsubmld(i)
               bxlamb(blckmld(i,j)) = bxlamb(blckmld(i,j)) * ttl
            enddo
         endif

! assign initial theta values
         s2 = zero
         do j = 1, nsubmld(i)
            thetamld(i,j) = asin(sqrt((bxlamb(blckmld(i,j)))))
            s2 = s2 + sin(thetamld(i,j)) * sin(thetamld(i,j))
#if KEY_DEBUG==1
            if (prnlev.gt.9) write(outu,100) i, j, s2, bxlamb(blckmld(i,j)), thetamld(i,j) 
#endif
         enddo
         if (s2 .eq. zero ) then
            write(outu,*) "WARNING... msld... denominator equals 0. Re-scaling"
            s2 = 0.001
            do j = 1, nsubmld(i)
               bxlamb(blckmld(i,j)) = sin(thetamld(i,j)) * sin(thetamld(i,j)) / s2
#if KEY_DEBUG==1
               if (prnlev.gt.9) write(outu,100) i, j, s2, bxlamb(blckmld(i,j)), thetamld(i,j) 
#endif
               thetamld(i,j) = asin(sqrt((bxlamb(blckmld(i,j)))))
            enddo
         endif
      enddo

100 format("testing_theta_fnsin> ", 2i5, f15.8, " ", f15.8, " ", f15.8)

   END subroutine msld_settheta_fnsin

!-----------------------------------------------------------------------
!> Assigns individual theta values from lambda values according to F2EXP functional form.
!> Invoked from msld_settheta during dynamc subroutines.
   subroutine msld_settheta_f2exp(nblock,bxlamb)

      use stream
      use number

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k
      real(chm_real), intent(inout), dimension(nblock) :: bxlamb

      do i = 2, nsitemld
         thetamld(i,1) = log((1.0/bxlamb(blckmld(i,2)))-1.0)
#if KEY_DEBUG==1
         if (prnlev.gt.9) write(outu,100) i, 1, bxlamb(blckmld(i,1)), thetamld(i,1) 
#endif
      enddo

100 format("testing_theta_f2exp> ", 2i5, " ", f15.8, " ", f15.8)

   END subroutine msld_settheta_f2exp

!-----------------------------------------------------------------------
!> Assigns individual theta values from lambda values according to FNEXP functional form.
!> Invoked from msld_settheta during dynamc subroutines.
!> Checks to ensure that initial lambda values do not exceed the theoretical minimum and
!> maximum values given FNEXP parameters.
!>\verbatim
!> minimum lambda = exp(-FNEXP_factor)/((N-1)*exp(-FNEXP_factor)+(exp(FNEXP_factor)).
!> maximum lambda = exp(FNEXP_factor)/((N-1)*exp(-FNEXP_factor)+(exp(FNEXP_factor)).
!> N = number of block associated with a given site.
!> default FNEXP_factor = 5.5
!> e.g. for N = 5 and FNEXP = 5.5,  0.0000167 < lambda < 0.99993320
!>\endverbatim
   subroutine msld_settheta_fnexp(nblock,bxlamb)

      use stream
      use number
      use consta

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j, k, count
      real(chm_real) :: ttl, minlambda, maxlambda, min, max, denom
      real(chm_real), intent(inout), dimension(nblock) :: bxlamb

      do i = 2, nsitemld
         min = exp(-fnexp_factors(i))
         max = exp(fnexp_factors(i))

! check bounds
         denom = 1.0 / (max + (nsubmld(i)-1)*min)
         maxlambda = max*denom
         minlambda = denom

         count = 0
         ttl = 0.0
         do j = 1, nsubmld(i)
            if (bxlamb(blckmld(i,j)).gt.maxlambda) then
                bxlamb(blckmld(i,j)) = maxlambda
                count = 1
                write(outu,*) "WARNING: Incompatible initial lambda value for Block: ", blckmld(i,j)
            elseif (bxlamb(blckmld(i,j)).lt.minlambda) then
                bxlamb(blckmld(i,j)) = minlambda * nsubmld(i)
                count = 1
                write(outu,*) "WARNING: Incompatible initial lambda value for Block: ", blckmld(i,j)
            endif
            ttl = ttl + bxlamb(blckmld(i,j))
         enddo
! renormalize if needed
         if (count.eq.1) then
            write(outu,*) "WARNING: Renormalizing initial lambda values."
            ttl = 1.0/ttl
            do j = 1, nsubmld(i)
               bxlamb(blckmld(i,j)) = bxlamb(blckmld(i,j)) * ttl
            enddo
         endif

! assign initial theta values
         do j = 1, nsubmld(i)
            thetamld(i,j) = asin(log(bxlamb(blckmld(i,j)))/fnexp_factors(i))
         enddo
      enddo

#if KEY_DEBUG==1
      if (prnlev.gt.9) then
         do i = 2, nsitemld
            do j = 1, nsubmld(i)
               if (prnlev.gt.9) write(outu,100) i, j, bxlamb(blckmld(i,j)), thetamld(i,j)
            enddo
         enddo
      endif
#endif 

100 format("testing_theta_fnexp> ", 2i5, " ", f15.8, " ", f15.8)

   END subroutine msld_settheta_fnexp

!-----------------------------------------------------------------------
!> Assigns individual theta values from lambda values according to FFIX functional form.
!> Invoked from msld_settheta during dynamc subroutines.
   subroutine msld_settheta_ffix(nblock,bxlamb)

      use stream
      use number
      use consta

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j
      real(chm_real) :: ttl
      real(chm_real), intent(inout), dimension(nblock) :: bxlamb

      do i = 2, nsitemld
         ttl = 0.0
         do j = 1, nsubmld(i)
            ttl = ttl + bxlamb(blckmld(i,j))
         enddo
! renormalize if needed
         if (ttl.ne.1.0) then
            write(outu,*) "WARNING: Renormalizing initial lambda values."
            ttl = 1.0/ttl
            do j = 1, nsubmld(i)
               bxlamb(blckmld(i,j)) = bxlamb(blckmld(i,j)) * ttl
            enddo
         endif

! assign initial theta values
         do j = 1, nsubmld(i)
            thetamld(i,j) = bxlamb(blckmld(i,j))
         enddo
      enddo

#if KEY_DEBUG==1
      if (prnlev.gt.9) then
         do i = 2, nsitemld
            do j = 1, nsubmld(i)
               if (prnlev.gt.9) write(outu,100) i, j, bxlamb(blckmld(i,j)), thetamld(i,j)
            enddo
         enddo
      endif
#endif 

100 format("testing_theta_ffix> ", 2i5, " ", f15.8, " ", f15.8)

   END subroutine msld_settheta_ffix

!-----------------------------------------------------------------------
!> Distributes assignment of theta values from lambda values according to functional form.
!> Invoked from dynamics subroutines.
   subroutine msld_settheta(nblock,bxlamb)

      use number
      use stream

      implicit none
      integer, intent(in) :: nblock
      integer :: i, j
      real(chm_real) :: denom, tmp
      real(chm_real), intent(inout), dimension(nblock) :: bxlamb

      select case (fcnal_form)
      case ('norm')
         call msld_settheta_norm(nblock,bxlamb)
      case ('2sin')
         call msld_settheta_f2sin(nblock,bxlamb)
      case ('2exp')
         call msld_settheta_f2exp(nblock,bxlamb)
      case ('nsin')
         call msld_settheta_fnsin(nblock,bxlamb)
      case ('nexp')
         call msld_settheta_fnexp(nblock,bxlamb)
      case ('fixd')
         call msld_settheta_ffix(nblock,bxlamb)
      end select

   END subroutine msld_settheta

!-----------------------------------------------------------------------
!>    Parses TRAJ commands.
!>    Required for pre-processing for lambda binary files from Multi-Site l-dynamics.
!>    Called from io/trajio.src.
   subroutine msld_preprocessld(comlyn,comlen)

    use string
    use number
    use stream
    use parallel
    use cvio,only:trjspc
    implicit none
    integer :: refcom, iprint, nosub, iunit, nunit, firstu, nbegn, skip, nstop
    real(chm_real) :: itemp, cutlo, cuthi
    character(len=*), intent(inout) :: comlyn
    integer, intent(inout) :: comlen

    iprint = 0
    nosub = 0
 if (mynod == 0) then
    if (indxa(COMLYN,COMLEN,'QUER').GT.0) THEN
       IUNIT=GTRMI(COMLYN,COMLEN,'UNIT',-1)
       CALL msld_query_header(IUNIT)
    else
       call TRJSPC(COMLYN,COMLEN,NUNIT,FIRSTU,NBEGN,SKIP,NSTOP)
       itemp=GTRMF(COMLYN,COMLEN,'TEMP',zero)
       cutlo =GTRMF(COMLYN,COMLEN,'CTLO',0.8_chm_real)
       cuthi =GTRMF(COMLYN,COMLEN,'CTHI',0.9_chm_real)
       IF(INDXA(COMLYN,COMLEN,'NOSUB').GT.0) nosub=1
       IF(INDXA(COMLYN,COMLEN,'PRINT').GT.0) iprint=1
       refcom = GTRMI(COMLYN,COMLEN,'REFCOM',-1)
       IF(PRNLEV.GE.2) WRITE(OUTU,220) FIRSTU,NUNIT,SKIP
       call msld_readld(itemp,cutlo,cuthi,NUNIT,FIRSTU,NBEGN,SKIP,NSTOP,iprint,nosub,refcom)
    endif
 endif

220    FORMAT(' TRAJ: INITIATING READ OF A TRAJECTORY, OPTIONS;'/, &
            '    FIRSTU = ',I3,' NUNIT = ',I3,' SKIP = ',I5)

   END subroutine msld_preprocessld

!-----------------------------------------------------------------------
!> Reads lambda binary files from Multi-Site l-dynamics.
!> Assumes that files FIRSTU through FIRSTU+NUNIT-1 are already open.
!> Future development: generalize output for systems with >4 Sites;
!>    combine trajectories from multiple files.
   subroutine msld_readld(temp,cutlo,cuthi,NUNIT,FIRSTU,begin,skip,nstop,iprint,nosub,refcom)

      use chm_kinds
      use dimens_fcm
      use consta
      use stream
      use memory
      use param_store, only: set_param

      INTEGER, intent(in) :: FIRSTU,NUNIT, iprint, nosub, refcom
      integer :: iunit,nfile
      INTEGER :: ISTEP,ISTATS
      INTEGER :: NDEGF,NSAVV
      real(chm_real) :: delta
      real(chm_real) :: tmp, fpl_lo, fpl_hi, fpl_ttl, trans_ttl
      real(chm_real), intent(inout) :: temp
      real(chm_real), intent(inout) :: cutlo, cuthi
      INTEGER, intent(inout) :: BEGIN, nstop
      integer, intent(inout) :: SKIP
      CHARACTER(len=4) :: HDR1,HDR2
      CHARACTER(len=80) :: title
      INTEGER :: NTITLE
      INTEGER :: LASTU,IFILE
      ! INTEGER, dimension(20) :: ICNTRL
      integer(chm_int4), dimension(20) :: icntrl

      integer :: i, j, k, l, m, n, first, newstep, istop
      integer, allocatable, dimension(:) :: nsubmld, last_indlo, last_indhi, trans_indlo, trans_indhi
      integer, allocatable, dimension(:) :: count_indlo, count_indhi
      integer, allocatable, dimension(:,:) :: count_liglo, count_lighi
      real(chm_real) :: refpoplo, refpophi
      real(chm_real) :: refbias
      integer, allocatable, dimension(:) :: count_mslo, count_mshi
      integer :: i_ms, j_ms, N_ms
      integer, allocatable, dimension(:) :: ijk_ms
      real(chm_real) :: kt, ratio, bias, ddg_lo, ddg_hi, ddgbias_lo, ddgbias_hi
      INTEGER :: NINTVL,NTOT,MULTIP,LFILE
!      integer :: trans_lig, last_lig
      INTEGER :: NPREV,NFINAL,NEWSTE,TRANSF
      real(chm_real) TIME
      CHARACTER(len=4) :: HDRR
      LOGICAL :: RROR
      INTEGER :: ISTEP1
      integer :: int8traju

! for charmm lambda binary input file
      real(chm_real4), allocatable, dimension(:) :: bxlamb2, bielamb
      real(chm_real4), allocatable, dimension(:,:) :: thetamld
      real(chm_real4) :: delta4, trajtemp
      integer(chm_int4) :: natom

! for summary statistic
      integer :: trans_min, trans_max
      character(len=20) :: tmpword
      SAVE

! check upper and lower thresholds for defining lambda = 1
      if (cutlo.gt.cuthi) then
         tmp = cutlo
         cutlo = cuthi
         cuthi = tmp
         write(outu,*) "WARNING: low-cutoff (CTLO) larger than high-cutoff (CTHI)"
         write(outu,*) "   swapping cut-off values. New values: "
         write(outu,190) cutlo, cuthi
         190 format("Low-cutoff (CTLO) : ",f5.3,"     High-cutoff (CTHI) : ",f5.3)
         write(outu,*)
      endif

! check for incompatible SKIP number
      IF(SKIP.LE.0) THEN
         IF(WRNLEV.GE.2) WRITE(OUTU,2007) SKIP
 2007    FORMAT(' ***** WARNING ***** from READCV -- SKIP, ',I6, &
                ' was not positive.'/' It will be set to 1.')
         SKIP=1
      ENDIF

! check BEGIN value
      IF(BEGIN.LE.0) then
         IF(WRNLEV.GE.2) WRITE(OUTU,2001) BEGIN,skip
 2001    FORMAT(' *****  WARNING  ***** BEGIN=',I8, &
            ' Was not specified. It has been set to:',I8)
         begin = skip
      ENDIF

! read header information from first trajectory file
      call msld_readld_header(1,firstu,temp,hdrr,icntrl,delta,kt)
      if (out_nsitemld.ge.4) then
         write(outu,*) "WARNING: analysis will only be performed for ddG at Single-Sites."
         write(outu,*) "  Print out lambda values at each step so you can post-process for this system."
      endif

      call chmalloc('lambdadyn.src','msld_readld','last_indlo',out_nsitemld,intg=last_indlo)
      call chmalloc('lambdadyn.src','msld_readld','last_indhi',out_nsitemld,intg=last_indhi)
      call chmalloc('lambdadyn.src','msld_readld','trans_indlo',out_nsitemld,intg=trans_indlo)
      call chmalloc('lambdadyn.src','msld_readld','trans_indhi',out_nsitemld,intg=trans_indhi)

      call chmalloc('lambdadyn.src','msld_readld','count_indlo',out_nblock,intg=count_indlo)
      call chmalloc('lambdadyn.src','msld_readld','count_indlo',out_nblock,intg=count_indhi)

      if (out_nsitemld.eq.3) then
         call chmalloc('lambdadyn.src','msld_readld','count_liglo',out_nsubmld(2),out_nsubmld(3),intg=count_liglo)
         call chmalloc('lambdadyn.src','msld_readld','count_lighi',out_nsubmld(2),out_nsubmld(3),intg=count_lighi)
      endif

      N_ms = 1
      do i_ms = 2, out_nsitemld
         N_ms = N_ms * out_nsubmld(i_ms)
         if (N_ms.le.0 .or. N_ms.gt.100000)then
            N_ms = -1
         endif
      enddo
      if (N_ms.ne.-1) then
         call chmalloc('lambdadyn.src','msld_readld','count_mslo',N_ms,intg=count_mslo)
         call chmalloc('lambdadyn.src','msld_readld','count_mshi',N_ms,intg=count_mshi)
      else
         write(outu,*) "WARNING: More than 100000 system combinations, statistics will not be collected."
      endif
      call chmalloc('lambdadyn.src','msld_readld','ijk_ms',out_nsitemld,intg=ijk_ms)

      call chmalloc('lambdadyn.src','msld_readld','bxlamb2',out_nblock,cr4=bxlamb2)
      call chmalloc('lambdadyn.src','msld_readld','bielamb',out_nblock,cr4=bielamb)
      call chmalloc('lambdadyn.src','msld_readld','thetamld',out_nsitemld,out_nblock,cr4=thetamld)

! initialize values -- this will lead to cumulative statistics if multiple files are processed with traj
         count_indlo = 0
         count_indhi = 0
         trans_indlo = 0
         trans_indhi = 0
         last_indlo = 0
         last_indhi = 0
         fpl_ttl = 0
         if (out_nsitemld.eq.3) then
            count_liglo= 0
            count_lighi= 0
         endif
         if (N_ms.ne.-1) then
            count_mslo = 0
            count_mshi = 0
         endif
!=====start loop over files
      do iunit = firstu, firstu + nunit - 1

!     read a new file
! --- Users should have opened the files before this call ----
         if (iunit > firstu) then
            call msld_readld_header(2,iunit,temp,hdrr,icntrl,delta,kt)
         endif
         read(iunit) (bielamb(i),i=1,out_nblock)
         do j = 1, out_nblock
            write(outu,29) j, bielamb(j)
         enddo
  29     FORMAT( &
         '   BIAS ON BLOCK:  ', i5, f10.5)

         write(outu,*)
         write(outu,*) "WARNING... In this analysis, free energy differences are "
         write(outu,*) "           NOT adjusted for biases invoked by LDBI and LDBV"
         write(outu,*)

! file details
         NFILE=ICNTRL(1)
         nintvl=ICNTRL(3)
         istep = 0
         newstep = 0
         if (nstop.eq.0) then
             istop = nfile*nintvl
         else
             istop = nstop*nintvl
             nfile = nstop
         endif

         if (iprint.eq.1) then
            write(outu,*)
            write(outu,80) 2, out_nblock
            write(outu,*) "==================================================================="
            80 format("LAMBDA.......TIME(ps).. .BLOCKS  ", i2, "   THRU BLOCK ", i4)
         endif

!=====start loop over trajectory
         do ifile = 1, nfile
            newstep = newstep + nintvl

! read in lambda values
            read (iunit) (bxlamb2(i),i=1,out_nblock)
            if (icntrl(12) == 2) then
               read(iunit) (thetamld(i,1),i=2,out_nsitemld)
            else
               read(iunit) ((thetamld(i,j),j=1,out_nsubmld(i)),i=2,out_nsitemld)
            endif

! check to see if process lambda values
            if (newstep.ge.begin .and. newstep.le.istop .and. mod((newstep-begin),skip).eq.0) then
               fpl_ttl = fpl_ttl + 1
               if (iprint.eq.1) then
                  write(outu,70) delta*nintvl*ifile, (bxlamb2(i), i = 2, out_nblock)
                  if (icntrl(12) == 2) then
                     write(outu,71) delta*nintvl*ifile, (thetamld(i,1),i=2,out_nsitemld)
                  else
                     write(outu,71) delta*nintvl*ifile, ((thetamld(i,j),j=1,out_nsubmld(i)),i=2,out_nsitemld)
                  endif
               endif
70 format("LAMBDA>  ", f11.4,10f8.4)
71 format("THETAM>   ", f10.3,10f8.3)

! process lambda values by site
!-------single-site counts (low cutoff)
              do i = 2, out_nsitemld
                  do j = 1, out_nsubmld(i)
                     k = out_blckmld(i,j)
                     if (bxlamb2(k).ge.cutlo) then
                        count_indlo(k) = count_indlo(k) + 1
                        if (last_indlo(i).ne.j) then
                           trans_indlo(i) = trans_indlo(i) + 1
                           last_indlo(i) = j
                        endif
!---------two-site counts (low cutoff)
                        if (i.eq.2 .and. out_nsitemld.eq.3) then
                           l = 3
                           do m = 1, out_nsubmld(l)
                              n = out_blckmld(l,m)
                              if (bxlamb2(n).ge.cutlo) then
                                 count_liglo(j,m) = count_liglo(j,m) + 1
                              endif
                           enddo
                        endif
!-------single-site counts (high cutoff)
                        if (bxlamb2(k).ge.cuthi) then
                           count_indhi(k) = count_indhi(k) + 1
                           if (last_indhi(i).ne.j) then
                              trans_indhi(i) = trans_indhi(i) + 1
                              last_indhi(i) = j
                           endif
!---------two-site counts (high cutoff)
                           if (i.eq.2 .and. out_nsitemld.eq.3) then
                              l = 3
                              do m = 1, out_nsubmld(l)
                                 n = out_blckmld(l,m)
                                 if (bxlamb2(n).ge.cuthi) then
                                    count_lighi(j,m) = count_lighi(j,m) + 1
                                 endif
                              enddo
                           endif
                        endif
                     endif
                  enddo
               enddo
!---------multi-site counts (low cutoff)
               i_ms = 1
               do i = 2, out_nsitemld
                  if (i_ms.gt.0) then
                     i_ms = out_nsubmld(i) * (i_ms - 1)
                     j_ms = 0
                     do j = 1, out_nsubmld(i)
                        k = out_blckmld(i,j)
                        if (bxlamb2(k).ge.cutlo) then
                           j_ms = j
                        endif
                     enddo
                     if (j_ms.gt.0) then
                        i_ms = i_ms + j_ms
                     else
                        i_ms = 0
                     endif
                  endif
               enddo
               if (i_ms.gt.0 .and. N_ms.ne.-1) then
                  count_mslo(i_ms) = count_mslo(i_ms) + 1
               endif
! NOTE - what if cutlo is less than 0.5?
!---------multi-site counts (high cutoff)
               i_ms = 1
               do i = 2, out_nsitemld
                  if (i_ms.gt.0) then
                     i_ms = out_nsubmld(i) * (i_ms - 1)
                     j_ms = 0
                     do j = 1, out_nsubmld(i)
                        k = out_blckmld(i,j)
                        if (bxlamb2(k).ge.cuthi) then
                           j_ms = j
                        endif
                     enddo
                     if (j_ms.gt.0) then
                        i_ms = i_ms + j_ms
                     else
                        i_ms = 0
                     endif
                  endif
               enddo
               if (i_ms.gt.0 .and. N_ms.ne.-1) then
                  count_mshi(i_ms) = count_mshi(i_ms) + 1
               endif
            endif
         enddo

! print out results
         write(outu,*)
         if (iunit .eq. firstu) then
            write(outu,*) "SUMMARY STATISTICS:"
            write(outu,*) "====================="
         else
            write(outu,*) "CUMULATIVE SUMMARY STATISTICS (assuming timestep and biases of current traj):"
            write(outu,*) "==============================================================================="
         endif
         write(outu,*) "Total Population Count:"
         write(outu,200) cutlo, cuthi
         200 format("                   BLOCK.......> ",f5.3," ...> ",f5.3)
         do i = 2, out_nblock
            write(outu,100) i, count_indlo(i), count_indhi(i)
            100 format("SINGLE POPULATION> ", i5, 2i12)
            write(tmpword,'(a, i0)') 'POP', i
            if (nosub.ne.1) call set_param(tmpword,count_indlo(i))
         enddo
         write(outu,*)
         write(outu,*) "Transitions between substituents (i.e. Blocks at each Site): "
         write(outu,210) cutlo, cuthi
         210 format("                    SITE........> ",f5.3," ...> ",f5.3)

         do i = 2, out_nsitemld
            trans_ttl = delta*nintvl*(fpl_ttl)
            ! subtract 1 from i, to realign Site numbers with inputfile
            write(outu,110) i-1, trans_indlo(i), trans_indhi(i)
            write(outu,115) i-1, trans_indlo(i)/trans_ttl, trans_indhi(i)/trans_ttl
            110 format("SINGLE TRANSITIONS>", i5, 2i12)
            115 format("SINGLE TRANS RATES>", i5, 2f12.5)
            if (i.eq.2) then
               trans_min = trans_indlo(i)
               trans_max = trans_indlo(i)
            else
               if ( trans_indlo(i).le.trans_min ) then
                  trans_min = trans_indlo(i)
               else
                  if (trans_indlo(i).ge.trans_max ) trans_max = trans_indlo(i)
               endif
            endif
         enddo
         if (nosub.ne.1) then
            call set_param('TMIN',trans_min)
            call set_param('TMAX',trans_max)
         endif
         write(outu,*)
         fpl_lo = 0
         fpl_hi = 0
         if (out_nsitemld.eq.2) then
            do i = 2, out_nblock
               fpl_lo = fpl_lo + count_indlo(i)
               fpl_hi = fpl_hi + count_indhi(i)
            enddo
            fpl_lo = fpl_lo / fpl_ttl
            fpl_hi = fpl_hi / fpl_ttl
            write(outu,135) fpl_lo, fpl_hi
            135 format("FRACTION PHYSICAL LIGAND> ", f10.5, " ", f10.5)
            write(outu,*)
            if (nosub.ne.1) call set_param('FPL',fpl_lo)
         endif

         write(outu,*) "FREE ENERGY DIFFERENCES (-kTln(PopJ/PopI)):"
         write(outu,*) " (bias from ldin not included)"
         write(outu,120) temp
         120 format("Temperature is: ", f8.3, " K")

         write(outu,*) "Single-site differences:"
         write(outu,*) "                               nobias      nobias        bias        bias"
         write(outu,220) cutlo, cuthi, cutlo, cuthi
         220 format("             BLK(I)..BLK(J).....> ",f5.3," ....> ",f5.3" .....> ",f5.3," ....> ",f5.3)
         do i = 2, out_nsitemld
! subtract 1 from i, to realign Site numbers with inputfile
            write(outu,125) i-1
            125 format("Site: ", i5)
            do j = 1, out_nsubmld(i) - 1
               do k = j+1, out_nsubmld(i)
                  ratio = 1.0*count_indlo(out_blckmld(i,k))/count_indlo(out_blckmld(i,j))
                  ddg_lo = -kt*log(ratio)
                  ratio = 1.0*count_indhi(out_blckmld(i,k))/count_indhi(out_blckmld(i,j))
                  ddg_hi = -kt*log(ratio)
                  bias = (bielamb(out_blckmld(i,k)) - bielamb(out_blckmld(i,j)))
                  ddgbias_lo = ddg_lo + bias
                  ddgbias_hi = ddg_hi + bias
                  write(outu,130) out_blckmld(i,j), out_blckmld(i,k), ddg_lo, ddg_hi, ddgbias_lo, ddgbias_hi
                  130 format("SINGLE DDG> ", 2i7, 4f12.5)
                  write(tmpword,'(a, i0, a, i0)') 'DDG', out_blckmld(i,j), '_', out_blckmld(i,k)
                  if (nosub.ne.1) call set_param(tmpword,ddg_lo)
               enddo
            enddo
         enddo

         write(outu,*)
         if (N_ms.ne.-1)then
         fpl_lo = 0
         fpl_hi = 0
         do i = 1, N_ms
            fpl_lo = fpl_lo + count_mslo(i)
            fpl_hi = fpl_hi + count_mshi(i)
         enddo
         fpl_lo = fpl_lo / fpl_ttl
         fpl_hi = fpl_hi / fpl_ttl
         write(outu,136) fpl_lo, fpl_hi
         136 format("MULTI-SITE FRACTION PHYSICAL LIGAND> ", f10.5, " ", f10.5)
         write(outu,*)

         write(outu,*) "Multi Population Count:"
         write(outu,"(a)",advance="no") "                  "
         do i = 2, out_nsitemld
            write(outu,"(a)",advance="no") " B"
            write(outu,"(i1)",advance="no") i-1
         enddo
         write(outu,201) cutlo, cuthi
         201 format("  INDEX ....> ",f5.3," ....> ",f5.3)
         refbias = 0
         do i_ms = 1, N_ms
            write(outu,"(a)",advance="no") "MULTI POPULATION> "
            j_ms = i_ms - 1
            ijk_ms = 1
            do i = out_nsitemld, 2, -1
               ijk_ms(i) = j_ms - out_nsubmld(i) * (j_ms / out_nsubmld(i)) + 1
               j_ms = j_ms / out_nsubmld(i)
            enddo
            do i = 2, out_nsitemld
               j = ijk_ms(i)
               write(outu,"(i3)",advance="no") out_blckmld(i,j)
            enddo
            write(outu,101) i_ms, count_mslo(i_ms), count_mshi(i_ms)
            101 format(i7, 2i12)
            if (i_ms.eq.refcom) then
               refpoplo = count_mslo(i_ms)
               refpophi = count_mshi(i_ms)
               do i = 2, out_nsitemld
                  j = ijk_ms(i)
                  refbias = refbias + bielamb(out_blckmld(i,j))
               enddo
            endif
         enddo
         write(outu,*)

         if ((refcom.gt.0).and.(refcom.le.N_ms)) then
            write(outu,*) "MULTI-SITE FREE ENERGY (-kTln(PopINDEX/PopRef)):"
            write(outu,*) " (bias from ldin not included)"
            write(outu,122) refcom
            122 format("Compound",i7," chosen as reference compound")
            if (refpoplo.eq.0) then
               write(outu,*) "Reference population is 0 at ctlo threshold"
               write(outu,*) "Will use arbitrary reference for ctlo calculation"
               refpoplo = fpl_ttl
            endif
            if (refpophi.eq.0) then
               write(outu,*) "Reference population is 0 at cthi threshold"
               write(outu,*) "Will use arbitrary reference for cthi calculation"
               refpophi = fpl_ttl
            endif
         else
            write(outu,*) "MULTI-SITE FREE ENERGY (-kTln(PopINDEX/TotFrames)):"
            write(outu,*) " (bias from ldin not included)"
            if (refcom.ne.-1) then
               write(outu,123) refcom
               123 format(i7," is not a valid reference compound")
            endif
            write(outu,*) "No valid reference compound specified. Will use an"
            write(outu,*) "arbitrary reference point. Add for example"
            write(outu,*) "'refcom 2' to 'traj lamb' command to use index=2"
            write(outu,*) "compound as the reference. Indices are listed in"
            write(outu,*) "index column below."
            refbias = 0
            refpoplo = fpl_ttl
            refpophi = fpl_ttl
         endif
         write(outu,121) temp
         121 format("Temperature is: ", f8.3, " K")

         write(outu,*) "Multi-site differences:"
         write(outu,"(a)",advance="no") "           "
         do i = 2, out_nsitemld
            write(outu,"(a)",advance="no") "   "
         enddo
         write(outu,*) "            nobias      nobias        bias        bias"
         write(outu,"(a)",advance="no") "           "
         do i = 2, out_nsitemld
            write(outu,"(a)",advance="no") " B"
            write(outu,"(i1)",advance="no") i-1
         enddo
         write(outu,221) cutlo, cuthi, cutlo, cuthi
         221 format("  INDEX ....> ",f5.3," ....> ",f5.3" ....> ",f5.3," ....> ",f5.3)
         do i_ms = 1, N_ms
            ratio = count_mslo(i_ms)/refpoplo
            ddg_lo = -kt*log(ratio)
            ratio = count_mshi(i_ms)/refpophi
            ddg_hi = -kt*log(ratio)
            ! bias = bielamb(out_blckmld(i,j))
            j_ms = i_ms - 1
            ijk_ms = 1
            do i = out_nsitemld, 2, -1
               ijk_ms(i) = j_ms - out_nsubmld(i) * (j_ms / out_nsubmld(i)) + 1
               j_ms = j_ms / out_nsubmld(i)
            enddo
            bias = 0
            write(outu,"(a)",advance="no") "MULTI DDG> "
            do i = 2, out_nsitemld
               j = ijk_ms(i)
               bias = bias + bielamb(out_blckmld(i,j))
               write(outu,131,advance="no") out_blckmld(i,j)
               131 format(1i3)
            enddo
            ddgbias_lo = ddg_lo + bias - refbias
            ddgbias_hi = ddg_hi + bias - refbias
            write(outu,132) i_ms, ddg_lo, ddg_hi, ddgbias_lo, ddgbias_hi
            132 format(1i7, 4f12.5)
         enddo
         endif

         write(outu,*)
         if (out_nsitemld.gt.3) then
            ! write(outu,*) "Too many Sites for current Multi-Site analysis"
            write(outu,*) "Too many Sites for Two-Site analysis"
         endif
      if (out_nsitemld.eq.3) then
         write(outu,*) "SUMMARY STATISTICS for Hybrid Ligand with Blocks assigned to Two Sites:"
         write(outu,*) "Multi-site Populations:"
         write(outu,*) "(Site 0 = environment; S1 = Site 1; S2 = Site 2)"
         write(outu,230) cutlo, cuthi
         230 format("             BLOCK(S1)..BLOCK(S2)...> ",f5.3," ..> ",f5.3)
         do i = 1, out_nsubmld(2)
            do j = 1, out_nsubmld(3)
               write(outu,140) out_blckmld(2,i), out_blckmld(3,j), count_liglo(i,j), count_lighi(i,j)
               140 format("MULTI POPULATION> ", 2i5, 2i12)
               fpl_lo = fpl_lo + count_liglo(i,j)
               fpl_hi = fpl_hi + count_lighi(i,j)
            enddo
         enddo
         write(outu,*)

         fpl_lo = fpl_lo / fpl_ttl
         fpl_hi = fpl_hi / fpl_ttl
         write(outu,135) fpl_lo, fpl_hi
         write(outu,*)

         write(outu,*) "FREE ENERGY DIFFERENCES (-kTln(PopJ/PopI)):"
         write(outu,120) temp

         write(outu,*) "Multi-site differences:"
         write(outu,*) "   LIGAND(I) defined by dominant blocks specified at Site1 and Site2 (BLK(S1) and BLK(S2))"
         write(outu,*) "        LIGAND(I)     LIGAND(J)       nobias     nobias       bias       bias"
         write(outu,240) cutlo, cuthi, cutlo, cuthi
         240 format("     BLK(S1)+BLK(S2)..BLK(S1)+BLK(S2)....> ",f5.3,"...> ",f5.3,"....> ",f5.3,".....> ",f5.3)
         do i = 1, out_nsubmld(2)
            do j = 1, out_nsubmld(3)
               do k = i, out_nsubmld(2)
                  if (i.eq.k) then
                     first = j + 1
                  else
                     first = 1
                  endif
                  do l = first, out_nsubmld(3)
                     ratio = 1.0*count_liglo(k,l)/count_liglo(i,j)
                     ddg_lo = -kt*log(ratio)
                     ratio = 1.0*count_lighi(k,l)/count_lighi(i,j)
                     ddg_hi = -kt*log(ratio)
                     bias = (bielamb(out_blckmld(2,k)) - bielamb(out_blckmld(2,i))) + &
                            (bielamb(out_blckmld(3,l)) - bielamb(out_blckmld(3,j)))
                     ddgbias_lo = ddg_lo + bias
                     ddgbias_hi = ddg_hi + bias
                     write(outu,150) out_blckmld(2,i), out_blckmld(3,j), out_blckmld(2,k), out_blckmld(3,l), &
                           ddg_lo, ddg_hi, ddgbias_lo, ddgbias_hi
                     150 format("MULTI DDG> ", i3," + ",i3, " .... ", i3," + ",i3, 4f12.5)
!                     write(tmpword,'(a, i0, a, i0, a, i0, a, i0)') 'MDDG', out_blckmld(2,i), '_', out_blckmld(3,j), '__', out_blckmld(2,k), '_', out_blckmld(3,l)
!                     if (nosub.ne.1) call set_param(tmpword,ddg_lo)
                  enddo
               enddo
            enddo
         enddo
      endif
!=====end loop over trajectory
         rewind(iunit)
         ! don't close (iunit), let the input script do it explicitly
      enddo
!=====end loop over files

      call chmdealloc('lambdadyn.src','msld_readld','thetamld',out_nsitemld,out_nblock,cr4=thetamld)
      call chmdealloc('lambdadyn.src','msld_readld','bielamb',out_nblock,cr4=bielamb)
      call chmdealloc('lambdadyn.src','msld_readld','bxlamb2',out_nblock,cr4=bxlamb2)

      if (out_nsitemld.eq.3) then
         call chmdealloc('lambdadyn.src','msld_readld','count_liglo',out_nsubmld(2),out_nsubmld(3),intg=count_liglo)
         call chmdealloc('lambdadyn.src','msld_readld','count_lighi',out_nsubmld(2),out_nsubmld(3),intg=count_lighi)
      endif

      if (N_ms.ne.-1) then
         call chmdealloc('lambdadyn.src','msld_readld','count_mslo',N_ms,intg=count_mslo)
         call chmdealloc('lambdadyn.src','msld_readld','count_mshi',N_ms,intg=count_mshi)
      endif
      call chmdealloc('lambdadyn.src','msld_readld','ijk_ms',out_nsitemld,intg=ijk_ms)

      call chmdealloc('lambdadyn.src','msld_readld','last_indlo',out_nsitemld,intg=last_indlo)
      call chmdealloc('lambdadyn.src','msld_readld','last_indhi',out_nsitemld,intg=last_indhi)
      call chmdealloc('lambdadyn.src','msld_readld','trans_indlo',out_nsitemld,intg=trans_indlo)
      call chmdealloc('lambdadyn.src','msld_readld','trans_indhi',out_nsitemld,intg=trans_indhi)

      call chmdealloc('lambdadyn.src','msld_readld','count_indlo',out_nblock,intg=count_indlo)
      call chmdealloc('lambdadyn.src','msld_readld','count_indlo',out_nblock,intg=count_indhi)

      call msld_deallocate_out

   end subroutine msld_readld

!-----------------------------------------------------------------------
!> Deallocates arrays required for analysis of MSLD trajectories.
  subroutine msld_deallocate_out

      use memory
      implicit none

      call chmdealloc('lambda_ltm.src','msld_readld','out_firstisitemld',out_nblock,intg=out_firstisitemld)
      call chmdealloc('lambda_ltm.src','msld_readld','out_isitemld',out_nblock,intg=out_isitemld)
      call chmdealloc('lambda_ltm.src','msld_readld','out_nsubmld',out_nblock,intg=out_nsubmld)
      call chmdealloc('lambda_ltm.src','msld_readld','out_blckmld',out_nsitemld,out_nblock,intg=out_blckmld)

   end subroutine msld_deallocate_out

!-----------------------------------------------------------------------
!> Extracts header and array information from lambda-dynamics lambda file.
!>  Modified from dynamc/dynio subroutine GTICNT(IUNIT,HDR,ICNTRL).
!>  Reads from unit IUNIT (which is REWOUND).
!>  HDR      type of trajectory (LAMB)
!>  ICNTRL   the whole ICNTRL array
!>  Sanity checks: trajectory generated by MSLD; if multiple trajectories are
!>  then icntrl arrays much be identical.
   subroutine msld_readld_header(flag,iunit,temp,hdrr,icntrl,delta,kt)

      use chm_kinds
      use consta
      use stream
      use memory
      use number
      use param_store, only: set_param

      implicit none
      integer, intent(in) :: flag, iunit
      integer :: i, j
      integer, dimension(:), allocatable :: out_count
      real(chm_real), intent(inout) :: temp
      real(chm_real), intent(out) :: delta, kt
! for charmm lambda binary input file
      integer(chm_int4), dimension(20), intent(inout) :: icntrl
      integer(chm_int4), dimension(20) :: icntrl2
      character(len=80) :: title
      character(len=4), intent(out) :: hdrr
      real(chm_real4) :: delta4, trajtemp
      integer(chm_int4) :: natom

! read header from new file
      read(iunit) hdrr, icntrl2

! sanity check: trajectory generated by MSLD
      IF(HDRR.NE."MSLD") then
         IF(WRNLEV.GE.2) WRITE(OUTU,903)
903      FORMAT(' *****  ERROR  ***** FILE NOT COMPATIBLE WITH MSLD ANALYSIS')
         CALL DIEWRN(-1)
      ENDIF

! sanity check 1: if multiple files then nblock and nsubmld must be identical
      if (flag.eq.1) then
         icntrl = icntrl2
         out_nblock = icntrl(7)
         out_nsitemld = icntrl(11)
         call chmalloc('lambda_ltm.src','msld_readld_header','out_firstisitemld',out_nblock,intg=out_firstisitemld)
         call chmalloc('lambda_ltm.src','msld_readld_header','out_isitemld',out_nblock,intg=out_isitemld)
         call chmalloc('lambda_ltm.src','msld_readld_header','out_nsubmld',out_nblock,intg=out_nsubmld)
         call chmalloc('lambda_ltm.src','msld_readld_header','out_blckmld',out_nsitemld,out_nblock,intg=out_blckmld)
      else
         if (icntrl(7).ne.icntrl2(7)) then
            IF(WRNLEV.GE.2) WRITE(OUTU,904)
904         FORMAT(' *****  ERROR  ***** ICNTRL NBLOCK DIFFERENT FROM PREVIOUS TRAJECTORIES')
            CALL DIEWRN(-1)
         elseif (icntrl(11).ne.icntrl2(11)) then
            IF(WRNLEV.GE.2) WRITE(OUTU,905)
905         FORMAT(' *****  ERROR  ***** ICNTRL NSUBMLD DIFFERENT FROM PREVIOUS TRAJECTORIES')
            CALL DIEWRN(-1)
         else
            icntrl = icntrl2
         endif
      endif
      call chmalloc('lambda_ltm.src','msld_readld_header','out_count',out_nblock,intg=out_count)

! read remaining header information from new file
      read(iunit) delta4
      read(IUNIT) title
      read(IUNIT) natom           ! number of variable biases
      read(IUNIT)                 ! variable_bias parameters
      read(iunit) (out_isitemld(i),i=1,out_nblock)

! sanity check 2: if multiple files then site assignments must be identical
      if (flag.eq.1) then
         out_firstisitemld = out_isitemld
      else
         do i = 1, out_nblock
            if (out_firstisitemld(i) .ne. out_isitemld(i) ) then
               IF(WRNLEV.GE.2) WRITE(OUTU,906)
906            FORMAT(' *****  ERROR  ***** SITES DIFFERENT FROM PREVIOUS TRAJECTORIES')
               CALL DIEWRN(-1)
            endif
         enddo
      endif

! reset counters
      out_count = 0
      do i = 2, out_nblock
          out_count(out_isitemld(i)) = out_count(out_isitemld(i)) + 1
          out_blckmld(out_isitemld(i),out_count(out_isitemld(i))) = i
      enddo
      do i = 2, out_nsitemld
         out_nsubmld(i) = out_count(i)
      enddo
      call chmdealloc('lambda_ltm.src','msld_readld_header','out_count',out_nblock,intg=out_count)

      read(IUNIT) trajtemp
      if (temp == ZERO) then
         temp = real(trajtemp,chm_real8)
         write(outu,50) temp
         50 format("Temperature not specified, using temperature from trajectory:  ", f8.2, " K")
      else
         write(outu,60) temp
         60 format("Using temperature from command line:  ", f8.2, " K")
      endif
      kt = kboltz*temp
      DELTA=DELTA4*TIMFAC ! switch from AKMA time to picoseconds - BRB

      IF(PRNLEV.GE.2) THEN
         WRITE(OUTU,26) IUNIT,(ICNTRL(I),I=1,4)
  26        FORMAT(/' READING TRAJECTORY FROM UNIT',I4,/ &
            '   NUMBER OF LAMBDA VALUES IN FILE:    ',I8,/ &
            '   NUMBER OF PREVIOUS DYNAMICS STEPS:  ',I8,/ &
            '   FREQUENCY FOR SAVING LAMBDA VALUES: ',I8,/ &
            '   NUMBER OF STEPS FOR CREATION RUN:   ',I8,/)
         WRITE(OUTU,27) ICNTRL(8),DELTA
  27        FORMAT( &
            '   NUMBER OF DEGREES OF FREEDOM:     ',I8,/ &
            '   THE INTEGRATION TIME STEP (PS):',F11.4)
         do i = 1, out_nblock
! decrease isitemld(i) by 1 to align with input files
            write(outu,28) i, out_isitemld(i) - 1
  28        FORMAT('   BLOCK ', i3, ' assigned to Site: ', i3)
         enddo
         write(outu,*)
      ENDIF

! set some substitution parameters based on this new file
      CALL set_param('NFILE',ICNTRL(1))
      CALL set_param('START',ICNTRL(2))
      CALL set_param('SKIP', ICNTRL(3))
      CALL set_param('NSTEP',ICNTRL(4))
      CALL set_param('NDEGF',ICNTRL(8))
      call set_param('DELTA',DELTA)

   END subroutine msld_readld_header

!-----------------------------------------------------------------------
!> Sets up to read header information in lambda trajectory file.
   subroutine msld_query_header(iunit)

      use chm_kinds
      use number

      implicit none
      integer, intent(in) :: iunit
      integer(chm_int4), dimension(20) :: icntrl
      character(len=4) :: hdrr
      real(chm_real) :: temp, delta, kt

      temp = ZERO
      call msld_readld_header(1,iunit,temp,hdrr,icntrl,delta,kt)
      call msld_deallocate_out

   END subroutine msld_query_header

!-----------------------------------------------------------------------
!> Writes a set of lambda and theta variables for a single MSLD dynamics step.
!> modified from writld subroutine in dynamc/dynio.src (04/01/10)
   subroutine msld_writld(NBLOCK,NPRIV, &
        ISTEP,NSTEP, &
        delta )

       use chm_kinds
       use dimens_fcm
       use stream
       use image
       use version
       use parallel

       implicit none
       integer, intent(in) :: nblock,npriv,istep, nstep
       real(chm_real), intent(in) :: delta

       real(chm_real4) :: delta4
       integer :: i,j,k

       integer, dimension(20) :: icntrl
       integer :: ifile, nfile
       logical :: error
       character(len=4) :: HDR,HDRC
       PARAMETER (HDRC='MSLD')

       ! Before we do anything, fix the lambda values
       ! Lambda values not updated to match theta values until next energy call
       call msld_setblcoef(nblock,ninter,bixlam,blcoep)

! save all variables between calls to WRITCV
    if (mynod == 0) then

       IF(IUNLDM < 0 &
#if KEY_PARALLEL==1
            .OR. IOLEV < 0 &     
#endif
            ) RETURN

      IFILE=ISTEP/NSAVL
      NFILE=NSTEP/NSAVL

      IF (IFILE <= 0) THEN
! ERROR IN INITIATION
         IF(WRNLEV >= 2) WRITE(OUTU,44) NBLOCK,NPRIV,ISTEP, &
              NSAVL,NSTEP,NTITLL,IUNLDM
44       FORMAT(' ** ERROR IN WRITLD INITIATION **',/ &
              '  NBLOCK,NPRIV,ISTEP,', &
              'NSAVL,NSTEP,NTITLL,IUNLDM'/,12I6)
         CALL DIEWRN(-3)
      ELSE IF (IFILE == 1) THEN
         ICNTRL(1:20) = 0
         ICNTRL(1)=NFILE
         ICNTRL(2)=NPRIV
         ICNTRL(3)=NSAVL
         ICNTRL(4)=NSTEP

         icntrl(7) = nblock
         icntrl(8) = nblock - nsitemld  ! ndegf_lambda
         icntrl(11) = nsitemld
         if (fcnal_form == '2sin' .or. fcnal_form == '2exp') then
             icntrl(12) = 2
         else
             icntrl(12) = 0
         endif
         hdr=hdrc
         delta4 = real(delta,chm_real4)

         write(iunldm) hdr, icntrl
         write(iunldm) delta4
         call wrtitl(titlel,ntitll,iunldm,-1)
         write(iunldm) int(nbiasv,chm_int4)
         write(iunldm) (real(ibvidi(i),chm_real4),real(ibvidj(i),chm_real4),real(ibclas(i),chm_real4), &
               real(irreup(i),chm_real4),real(irrlow(i),chm_real4),real(ikbias(i),chm_real4), &
               real(ipbias(i),chm_real4), i=1,nbiasv)
         write(iunldm) (isitemld(i),i=1,nblock)
         write(iunldm) real(tbld,chm_real4)
         write(iunldm) (real(bielam(i),chm_real4),i=1,nblock)
      endif

      write(iunldm) (real(bixlam(i),chm_real4),i=1,nblock)
      if (fcnal_form == '2sin' .or. fcnal_form == '2exp') then
         write(iunldm) ((real(thetamld(i,1),chm_real4)),i=2,nsitemld)
      else
         write(iunldm) ((real(thetamld(i,j),chm_real4),j=1,nsubmld(i)),i=2,nsitemld)
      endif

!++  LN MOD /APR 90
!     Make sure everything is put on disk (which is needed on some
!     machines in case of a job crash
     CALL SAVEIT(IUNLDM)

     IF(IFILE < NFILE) RETURN
     IF(PRNLEV >= 2) THEN
        write(outu,101) nfile, npriv, nsavl, iunldm
101     FORMAT(/2X,I10,'   LAMBDA SETS STARTING FROM',/, &
          5X,'STEP NO ',I10,'   FOR EVERY ',I5,'  STEPS',/, &
          5X,'WRITTEN ON UNIT',I5,/)
     ENDIF
     CALL VCLOSE(IUNLDM,'KEEP',ERROR)
    endif

  END subroutine msld_writld

!-----------------------------------------------------------------------
!> Writes current and old lambda values and velocities to restart file.
!> Restart file on unit U.
  subroutine msld_write_restart(u,nblock)

  use stream
  implicit none
  integer, intent(in) :: u, nblock
  integer :: i, j, skip

  write(u,'(/A)')  ' !LAMBDAOLD'
  write(u,'(1D22.15)') (bldold(i),i=1,nblock)
  write(u,'(/A)')  ' !LAMBDA_V'
  write(u,'(1D22.15)') (bivlam(i),i=1,nblock)
  write(u,'(/A)')  ' !LAMBDA'
  write(u,'(1D22.15)') (bixlam(i),i=1,nblock)
  write(u,'(/A)')  ' !THETA_V'
  if (fcnal_form == '2exp' .or. fcnal_form == '2sin') then
     skip = 1
  else
     skip = 0
  endif
  write(u,'(1D22.15)') ((thetamld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)
  write(u,'(1D22.15)') ((thetavmld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)

  if (prnlev > 9) then
     write(outu,*) "Writing to restart file:"
     write(outu,*) (bldold(i),i=1,nblock)
     write(outu,*) (bivlam(i),i=1,nblock)
     write(outu,*) (bixlam(i),i=1,nblock)
     write(outu,*) ((thetamld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)
     write(outu,*) ((thetavmld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)
  endif

  END subroutine msld_write_restart

!-----------------------------------------------------------------------
!> Reads current and old lambda values and velocities to restart file.
!> Restart file on unit U.
  subroutine msld_read_restart(u,nblock)

  use stream
  use parallel   !GG
  implicit none
  integer, intent(in) :: u, nblock
  integer :: i, j, status, skip
  integer K7                                     !GG: MSLD-compatibility
  real(chm_real) n(nsitemld,nblock)              !GG: MSLD-compatibility
  real(chm_real) m(nsitemld*nblock)              !GG: MSLD-compatibility
  real(chm_real) THETAVMLDS(nsitemld*nblock)     !GG: MSLD-compatibility
  real(chm_real) THETAMLDS(nsitemld*nblock)      !GG: MSLD-compatibility
  character(len=128) :: line

  read(u,'(/A)',iostat=status) line
  if ( status/= 0 ) call wrndie(-3,'<lambdadyn>','EOF during read')
  read(u,'(1D22.15)') (bldold(i),i=1,nblock)

  read(u,'(/A)',iostat=status) line
  if ( status/= 0 ) call wrndie(-3,'<lambdadyn>','EOF during read')
  read(u,'(1D22.15)') (bivlam(i),i=1,nblock)

  read(u,'(/A)',iostat=status) line
  if ( status/= 0 ) call wrndie(-3,'<lambdadyn>','EOF during read')
  read(u,'(1D22.15)') (bixlam(i),i=1,nblock)

  read(u,'(/A)',iostat=status) line
  if ( status/= 0 ) call wrndie(-3,'<lambdadyn>','EOF during read')
  if (fcnal_form == '2exp' .or. fcnal_form == '2sin') then
     skip = 1
  else
     skip = 0
  endif
  read(u,'(1D22.15)') ((thetamld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)
  read(u,'(1D22.15)') ((thetavmld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)

  if (prnlev.gt.9) then
     write(outu,*) "Reading from restart file:"
     write(outu,*) (bldold(i),i=1,nblock)
     write(outu,*) (bivlam(i),i=1,nblock)
     write(outu,*) (bixlam(i),i=1,nblock)
     write(outu,*) ((thetamld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)
     write(outu,*) ((thetavmld(i,j),j=1,nsubmld(i)-skip),i=2,nsitemld)
  endif

  END subroutine msld_read_restart

!-----------------------------------------------------------------------
!> Reads current and old lambda values and velocities to restart file.
!> Restart file on unit U.
  subroutine msld_restart_broadcast(nblock)
  use stream
  use parallel   !GG
  implicit none
  integer, intent(in) :: nblock
#if KEY_PARALLEL==1
  integer K7                                     !GG: MSLD-compatibility
  real(chm_real) n(nsitemld,nblock)              !GG: MSLD-compatibility
  real(chm_real) m(nsitemld*nblock)              !GG: MSLD-compatibility
  real(chm_real) THETAVMLDS(nsitemld*nblock)     !GG: MSLD-compatibility
  real(chm_real) THETAMLDS(nsitemld*nblock)      !GG: MSLD-compatibility
  character(len=128) :: line

  IF (prnlev.ge.8) THEN
     write(outu,'(a)') 'Transferring restart theta variables to all CPUs'
  ENDIF
  K7 = nsitemld*nblock                         !GG: Calc total no. of elements in MSLD array
  IF (MYNOD == 0) THEN
     THETAMLDS = RESHAPE(THETAMLD,SHAPE(M))       !GG: Reshape array for coordinates to 1D array
     THETAVMLDS = RESHAPE(THETAVMLD,SHAPE(M))     !GG: Processing current velocity coordinates
  ENDIF
     CALL PSND8(bldold,nblock)
     CALL PSND8(bivlam,nblock)
     CALL PSND8(bixlam,nblock)
     CALL PSND8(THETAMLDS,K7)
     CALL PSND8(THETAVMLDS,K7)
     IF (MYNOD.NE.0) THEN
        THETAMLD = RESHAPE(THETAMLDS,SHAPE(N))
        THETAVMLD = RESHAPE(THETAVMLDS,SHAPE(N))
     ENDIF
#endif 
  END subroutine msld_restart_broadcast

!-----------------------------------------------------------------------
!> Adds fixed bias (lambdaF(i)) scaled by lambda(i) to total potential energy.
!> Invoked by msld_add_potentialenergy.
  subroutine msld_add_biasenergy(energy)

      use chm_kinds
      use number
      use stream

      implicit none
      integer :: i, j, k
      real(chm_real), intent(inout) :: energy
      real(chm_real) :: bx, en

      en = zero
      if(prnlev.gt.9) write(outu,*) "preadd_biasenergy> total energy: ", energy !#DEBUG
      do k = 1, nbiasv
         i = ibvidi(k)
         bx = bixlam(i)
         if (ibclas(k) .eq. 1) then
            if (bx .lt. irreup(k)) en = en + ikbias(k)*(bx - irreup(k))**ipbias(k)
         elseif (ibclas(k) .eq. 2) then
            if (bx .gt. irrlow(k)) en = en + ikbias(k)*(bx - irrlow(k))**ipbias(k)
         elseif (ibclas(k) .eq. 3) then
            j = ibvidj(k)
            bx = bx - bixlam(j)
            en = en + ikbias(k)*(bx**ipbias(k))
         elseif (ibclas(k) .eq. 4) then
            if (bx .ge. bicut) then
               en = en - ikbias(k)
            else
               en = en - ikbias(k)*(1.0-(bicut2in*(bx-bicut)*(bx-bicut)))
            endif
         elseif (ibclas(k) .eq. 5) then
            en = en - ikbias(k)*bx
         elseif (ibclas(k) .eq. 6) then
            j = ibvidj(k)
            en = en + ikbias(k)*bx*bixlam(j)
         elseif (ibclas(k) .eq. 7) then
            en = en + ikbias(k)*bx*(1-bx)/(bx+irreup(k))
         elseif (ibclas(k) .eq. 8) then
            j = ibvidj(k)
            en = en + ikbias(k)*bx*bixlam(j)/(bx+irreup(k))
         elseif (ibclas(k) .eq. 9) then
            j = ibvidj(k)
            en = en + ikbias(k)*bixlam(j)*(1-((bx+irreup(k))/irreup(k))**ipbias(k))
         elseif (ibclas(k) .eq. 10) then
            j = ibvidj(k)
            en = en + ikbias(k)*bixlam(j)*(1-exp(irreup(k)*bx))
         endif
!#IF DEBUG
         if(prnlev.gt.9) then
            write(outu,*) "class: ", k, ibclas(k)
            if (ibclas(k) .eq. 1) then
               write(outu,100) k, en, ibvidi(k), ibvidj(k), ikbias(k), ipbias(k), irreup(k)
            elseif (ibclas(k) .eq. 2) then
               write(outu,110) k, en, ibvidi(k), ibvidj(k), ikbias(k), ipbias(k), irrlow(k)
            else
               write(outu,110) k, en, ibvidi(k), ibvidj(k), ikbias(k), ipbias(k)
            endif
         endif
!#ENDIF

      enddo
      energy = energy + en

      if(prnlev.gt.9) write(outu,*) "postadd_biasenergy> total energy: ", energy !#DEBUG

100 format("add_biasenergy> ", i5, f15.10, 2i5, f10.5, i5, f10.5)
110 format("add_biasenergy> ", i5, f15.10, 2i5, f10.5, i5)

    END subroutine msld_add_biasenergy

!-----------------------------------------------------------------------
!> Check that correct params for msld have been swapped
  subroutine msld_checkvariables(flag)

      use chm_kinds
      use number
      use stream
      use energym
      implicit none
      integer :: i, j, flag, nblock
      real(chm_real) :: EDIFF

      701 format(i2,i2,f12.6,f12.6,f12.6,f12.6)
      702 format(a1,i2,a5,f12.6)
      703 format(i2,i2,f16.10)
      704 format(a10,f20.8)
      705 format(a10,f20.8,f20.8)
      IF(prnlev.ge.6) THEN !GG: Print out theta variables
         write(outu,'(a)') '-------------------------GG---------------------------'
         IF (flag .eq. 1) THEN
            write(outu,'(a)') 'Theta Variables Before MC Exchange'
         ELSE IF (flag .eq. 2) THEN
            write(outu,'(a)') 'Theta Variables Before Transmission'
         ELSE IF (flag .eq. 3) THEN
            write(outu,'(a)') 'Theta Variables After Swap, Before Call Energy'
         ELSE IF (flag .eq. 4) THEN
            write(outu,'(a)') 'Theta Variables After Swap, After Call Energy'
         ELSE IF (flag .eq. 5) THEN
            write(outu,'(a)') 'Theta Variables After MC Exchange'
         ELSE
            write(outu,'(a)') 'Unknown step detected'
         ENDIF
         write(outu,'(a)') 'Site, Sub, ThetX, ThetXold, ThetV, ThetF'
         DO i = 2, nsitemld
            DO j = 1, nsubmld(i)
               write(outu,701) i, j, thetamld(i,j), thetamldold(i,j), thetavmld(i,j), thetafmld(i,j)
            ENDDO
         ENDDO
         write(outu,'(a)') 'Bias values'
         DO i = lstrt, nblock !GG: Print Gbias values
            write(outu,702) 'I', i, 'Gbias', bielam(i)
         ENDDO
         DO i = 1, nbiasv     !GG: Print kbias values
            write(outu,702) 'I', i, 'kbias', ikbias(i)
         ENDDO
         IF(prnlev.ge.7) THEN
            write(outu,'(a)') 'Block Coefficient'
            DO i = 1, nblock     !GG: Print block coefficient values
               write(outu,703) i, i, fullblcoep(i,i)
               DO j = i+1, nblock
                 write(outu,703) i, j, fullblcoep(i,j)
                 write(outu,703) j, i, fullblcoep(j,i)
               ENDDO
            ENDDO
         ENDIF
         IF(prnlev.ge.7) THEN
            write(outu,704) 'Eterm(VDW)', ETERM(6)
            write(outu,704) 'Eterm(ELE)', ETERM(7)
            write(outu,704) 'Eterm(IVWD)', ETERM(16)
            write(outu,704) 'Eterm(IELE)', ETERM(17)
         ENDIF
         write(outu,'(a)') '-------------------------GG---------------------------'
      ENDIF



  END subroutine msld_checkvariables

!=========================================================================================

   real(chm_real) function lookupint_exp(x)

      use consta

      implicit none
      real(chm_real), intent(in) :: x
      integer :: x1
      real(chm_real) :: y1, y2, pi2, x2

      pi2 = 2.0*pi
      x2 = modulo(x, pi2)
      x1 = int(x2*2500/pi) ! floor is unnecessary because x2 .ge. 0
      y1 = exp_table(x1)
      y2 = exp_table(x1+1)
      lookupint_exp = y1 + (y2-y1)*(x2*2500/pi-x1)

   END function lookupint_exp

!=========================================================================================
#endif /* (ldm_mod)*/

end module lambdam

