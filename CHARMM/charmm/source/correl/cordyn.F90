SUBROUTINE QSF(H,Y,Z,NDIM)
  !----------------------------------------------------------------------C
  !OMMENT   QSF COMPUTES THE VECTOR OF INTEGRAL VALUES FOR A GIVEN       C
  !     EQUIDISTANT TABLE OF FUNCTION VALUES, USING SIMPSONS RULE        C
  !     TOGETHER WITH NEWTONS 3/8 RULE OR A COMBINATION OF THESE TWO     C
  !     RULES, SEE F.B. HILDEBRAND, INTRODUCTION TO NUMERICAL ANALYSIS,  C
  !     MCGRAW-HILL, NEW YORK, 1956, PP 71-76.                           C
  !     IT HAS BEEN COPIED FROM THE IBM SCIENTIFIC SUBROUTINE PACKAGE.   C
  !                                                                      C
  !     H = CONSTANT INCREMENT OF ARGUMENT VALUES                        C
  !     Y(1..NDIM) = VECTOR OF FUNCTION VALUES                           C
  !     Z(1..NDIM) = DELIVERED WITH VECTOR OF INTEGRAL VALUES;           C
  !                  Z MAY BE IDENTICAL WITH Y                           C
  !     NDIM = DIMENSION OF VECTORS Y AND Z (.GE.3)                      C
  !                                                                      C
  !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  !
  use chm_kinds
  implicit none
  real(chm_real) H
  real(chm_real) Y(*),Z(*)
  INTEGER NDIM
  !
  real(chm_real) HT,SUM1,SUM2,AUX1,AUX2
  INTEGER I
  !
  HT=1.0
  HT=HT/3.0*H
  !
  IF(NDIM.GT.5) THEN
     !*****NDIM IS GREATER THAN 5, PREPARATIONS FOR INTEGRATION LOOP
     SUM1=HT*(Y(1)+4.0*Y(2)+Y(3))
     AUX1=SUM1+HT*(Y(3)+4.0*Y(4)+Y(5))
     AUX2=HT*(Y(1)+3.8750*(Y(2)+Y(5))+2.6250*(Y(3)+Y(4))+Y(6))
     SUM2=AUX2-HT*(Y(4)+4.0*Y(5)+Y(6))
     Z(1)=0.0
     Z(2)=SUM2-HT*(Y(2)+4.0*Y(3)+Y(4))
     Z(3)=SUM1
     Z(4)=SUM2
     !
     !*****INTEGRATION LOOP
     DO I=7,NDIM,2
        SUM1=AUX1
        SUM2=AUX2
        AUX1=SUM1+HT*(Y(I-2)+4.0*Y(I-1)+Y(I))
        Z(I-2)=SUM1
        IF(I.GE.NDIM) THEN
           Z(NDIM-1)=SUM2
           Z(NDIM)=AUX1
           RETURN
        ENDIF
        AUX2=SUM2+HT*(Y(I-1)+4.0*Y(I)+Y(I+1))
        Z(I-1)=SUM2
     ENDDO
     Z(NDIM-1)=AUX1
     Z(NDIM)=AUX2
     RETURN
     !
     !*****END OF INTEGRATION LOOP
     !
  ELSE IF(NDIM.LT.3) THEN
     CONTINUE
  ELSE IF(NDIM.EQ.3) THEN
     Z(2)=HT*(1.25*Y(1)+2.0*Y(2)-Y(3)/4.0)
     Z(3)=HT*(Y(1)+4.0*Y(2)+Y(3))
     Z(1)=0.0
  ELSE
     !
     !*****NDIM IS EQUAL TO 4 OR 5
     SUM2=1.125*HT*(Y(1)+3.0*(Y(2)+Y(3))+Y(4))
     SUM1=HT*(Y(1)+4.0*Y(2)+Y(3))
     Z(1)=0.0
     Z(2)=SUM2-HT*(Y(2)+4.0*Y(3)+Y(4))
     IF(NDIM.GE.5) Z(5)=SUM1+HT*(Y(3)+4.0*Y(4)+Y(5))
     Z(3)=SUM1
     Z(4)=SUM2
  ENDIF
  RETURN
  !
  !*****NDIM IS EQUAL TO 3
END SUBROUTINE QSF

SUBROUTINE correl_FFT(A,B,NTOT,N,NSPAN,ISN)
  !----------------------------------------------------------------------C
  !OMMENT   FFT PERFORMS A MULTIVARIATE COMPLEX FOURIER TRANSFORM,       C
  !     COMPUTED INPLACE USING A MIXED-RADIX FAST FOURIER TRANSFORM      C
  !     ALGORITHM, GIVEN BY R.C. SINGLETON, IEEE TRANS. AUDIO            C
  !     ELECTROACOUSTICS AU-17 (1969) 93.                                C
  !     FOR COMMENTS ON USE, ARRAY-SIZES, ETC., LOOK THERE.              C
  !                                                                      C
  !     A(1..NTOT) = REAL PART OF THE FUNCTION TO BE TRANSFORMED, IT IS  C
  !                  DELIVERED WITH THE REAL PARTS OF THE FOURIER        C
  !                  COEFFICIENTS                                        C
  !     B(1..NTOT) = IDEM FOR THE IMAGINARY PARTS                        C
  !     NTOT = TOTAL NUMBER OF COMPLEX DATA VALUES                       C
  !     N = THE DIMENSION OF THE CURRENT VARIABLE                        C
  !     NSPAN : NSPAN/N IS THE SPACING OF CONSECUTIVE DATA VALUES WHILE  C
  !             INDEXING THE CURRENT VARIABLE                            C
  !     ISN : THE SIGN OF ISN DETERMINES THE SIGN OF THE COMPLEX         C
  !           EXPONENTIAL, AND THE MAGNITUDE OF ISN IS NORMALLY ONE      C
  !                                                                      C
  !     THE MAXIMUM PRIME FACTOR OF N MUST BE .LE. MAXFT.                C
  !     THE NUMBER OF PRIME FACTORS OF N MUST BE .LT. MAXP.              C
  !     IF THE SQUARE-FREE PORTION K OF N HAS TWO OR MORE PRIME FACTORS, C
  !     THEN K-1 MUST BE .LE. MAXP.                                      C
  !     N MUST NOT CONTAIN MORE THAN 21 FACTORS.                         C
  !     IF N HAS MORE THAN ONE SQUARE-FREE FACTOR, THE PRODUCT OF THESE  C
  !     FACTORS MUST BE .LE. 501.                                        C
  !                                                                      C
  !CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  !
  use chm_kinds
  use number
  use dimens_fcm
  use memory
  implicit none
  character(len=*),parameter :: file_name="cordyn.src"
  character(len=*),parameter :: routine_name="fft"
!
  INTEGER MAXFT,MAXN
  PARAMETER (MAXFT=137,MAXN=21)
  !
  !ln...B980928.ln
  INTEGER NTOT
  real(chm_real) A(NTOT),B(NTOT),AT(MAXFT),CK(MAXFT),BT(MAXFT), &
       SK(MAXFT)
  INTEGER NFAC(MAXN)
  integer, allocatable, dimension(:) :: NP
  INTEGER I,II
  EQUIVALENCE (I,II)
  !
  real(chm_real) AA,AJ,AJM,AJP,AK,AKM,AKP,BB,BJ, &
       BJM,BJP,BK,BKM,BKP,C1
  real(chm_real) C2,C3,C72,CD
  INTEGER INC,ISN,J,JC,JF,JJ,K,K1,K2,K3,K4,KK,KS,KSPAN
  INTEGER KSPNN,KT,M,N,NN,NSPAN,NT,MAXF
  real(chm_real) RAD,RADF,S1,S120,S2,S3,S72,SD
  !
  call chmalloc(file_name,routine_name,'np ',maxp,intg=np)
  MAXF=MAXFT
  !
  IF (N.LT.2) RETURN
  INC=ISN
  RAD=8.0* ATAN(ONE)
  S72=RAD/5.0
  C72= COS(S72)
  S72= SIN(S72)
  S120= SQRT(PT75)
  IF (ISN.GE.0) GOTO 10
  S72=-S72
  S120=-S120
  RAD=-RAD
  INC=-INC
10 NT=INC*NTOT
  KS=INC*NSPAN
  KSPAN=KS
  NN=NT-INC
  JC=KS/N
  RADF=RAD*JC*0.5
  I=0
  JF=0
  !
  !*****DETERMINE THE FACTORS OF N
  M=0
  K=N
  GOTO 20
15 M=M+1
  NFAC(M)=4
  K=K/16
20 IF (K-(K/16)*16.EQ.0) GOTO 15
  J=3
  JJ=9
  GOTO 30
25 M=M+1
  NFAC(M)=J
  K=K/JJ
30 IF (MOD(K,JJ).EQ.0) GOTO 25
  J=J+2
  JJ=J**2
  IF (JJ.LE.K) GOTO 30
  IF (K.GT.4) GOTO 40
  KT=M
  NFAC(M+1)=K
  IF (K.NE.1) M=M+1
  GOTO 80
40 IF (K-(K/4)*4.NE.0) GOTO 50
  M=M+1
  NFAC(M)=2
  K=K/4
50 KT=M
  J=2
60 IF (MOD(K,J).NE.0) GOTO 70
  M=M+1
  NFAC(M)=J
  K=K/J
70 J=((J+1)/2)*2+1
  IF (J.LE.K) GOTO 60
80 IF (KT.EQ.0) GOTO 100
  J=KT
90 M=M+1
  NFAC(M)=NFAC(J)
  J=J-1
  IF (J.NE.0) GOTO 90
  !
100 CONTINUE
  !
  !*****COMPUTE FOURIER TRANSFORM
  SD=RADF/KSPAN
  CD=2.0* SIN(SD)**2
  SD= SIN(SD+SD)
  KK=1
  I=I+1
  IF (NFAC(I).NE.2) GOTO 400
  !
  !*****TRANSFORM FOR FACTOR OF 2 (INCLUDING ROTATION FACTOR)
  KSPAN=KSPAN/2
  K1=KSPAN+2
210 K2=KK+KSPAN
  AK=A(K2)
  BK=B(K2)
  A(K2)=A(KK)-AK
  B(K2)=B(KK)-BK
  A(KK)=A(KK)+AK
  B(KK)=B(KK)+BK
  KK=K2+KSPAN
  IF (KK.LE.NN) GOTO 210
  KK=KK-NN
  IF (KK.LE.JC) GOTO 210
  IF (KK.GT.KSPAN) GOTO 800
220 C1=1.0-CD
  S1=SD
230 K2=KK+KSPAN
  AK=A(KK)-A(K2)
  BK=B(KK)-B(K2)
  A(KK)=A(KK)+A(K2)
  B(KK)=B(KK)+B(K2)
  A(K2)=C1*AK-S1*BK
  B(K2)=S1*AK+C1*BK
  KK=K2+KSPAN
  IF (KK.LT.NT) GOTO 230
  K2=KK-NT
  C1=-C1
  KK=K1-K2
  IF (KK.GT.K2) GOTO 230
  AK=C1-(CD*C1+SD*S1)
  S1=(SD*C1-CD*S1)+S1
  !
  !*****THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERROR.
  !*****IF ROUNDED ARITHMETIC IS USED, SUBSTITUTE
  !     C1=AK
  C1=0.50/(AK**2+S1**2)+0.50
  S1=C1*S1
  C1=C1*AK
  KK=KK+JC
  IF (KK.LT.K2) GOTO 230
  K1=K1+INC+INC
  KK=(K1-KSPAN)/2+JC
  IF (KK.LE.JC+JC) GOTO 220
  GOTO 100
  !
  !*****TRANSFORM FOR FACTOR OF 3 (OPTIONAL CODE)
320 K1=KK+KSPAN
  K2=K1+KSPAN
  AK=A(KK)
  BK=B(KK)
  AJ=A(K1)+A(K2)
  BJ=B(K1)+B(K2)
  A(KK)=AK+AJ
  B(KK)=BK+BJ
  AK=-0.50*AJ+AK
  BK=-0.50*BJ+BK
  AJ=(A(K1)-A(K2))*S120
  BJ=(B(K1)-B(K2))*S120
  A(K1)=AK-BJ
  B(K1)=BK+AJ
  A(K2)=AK+BJ
  B(K2)=BK-AJ
  KK=K2+KSPAN
  IF (KK.LT.NN) GOTO 320
  KK=KK-NN
  IF (KK.LE.KSPAN) GOTO 320
  GOTO 700
  !
  !*****TRANSFORM FOR FACTOR OF 4
400 IF (NFAC(I).NE.4) GOTO 600
  KSPNN=KSPAN
  KSPAN=KSPAN/4
410 C1=1.0
  S1=0.0
420 K1=KK+KSPAN
  K2=K1+KSPAN
  K3=K2+KSPAN
  AKP=A(KK)+A(K2)
  AKM=A(KK)-A(K2)
  AJP=A(K1)+A(K3)
  AJM=A(K1)-A(K3)
  A(KK)=AKP+AJP
  AJP=AKP-AJP
  BKP=B(KK)+B(K2)
  BKM=B(KK)-B(K2)
  BJP=B(K1)+B(K3)
  BJM=B(K1)-B(K3)
  B(KK)=BKP+BJP
  BJP=BKP-BJP
  IF (ISN.LT.0) GOTO 450
  AKP=AKM-BJM
  AKM=AKM+BJM
  BKP=BKM+AJM
  BKM=BKM-AJM
  IF (S1.EQ.0.0) GOTO 460
430 A(K1)=AKP*C1-BKP*S1
  B(K1)=AKP*S1+BKP*C1
  A(K2)=AJP*C2-BJP*S2
  B(K2)=AJP*S2+BJP*C2
  A(K3)=AKM*C3-BKM*S3
  B(K3)=AKM*S3+BKM*C3
  KK=K3+KSPAN
  IF (KK.LE.NT) GOTO 420
440 C2=C1-(CD*C1+SD*S1)
  S1=(SD*C1-CD*S1)+S1
  !
  !*****THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERROR.
  !*****IF ROUNDED ARITHMETIC IS USED, SUBSTITUTE
  !     C1=C2
  C1=0.50/(C2**2+S1**2)+0.50
  S1=C1*S1
  C1=C1*C2
  C2=C1**2-S1**2
  S2=2.0*C1*S1
  C3=C2*C1-S2*S1
  S3=C2*S1+S2*C1
  KK=KK-NT+JC
  IF (KK.LE.KSPAN) GOTO 420
  KK=KK-KSPAN+INC
  IF (KK.LE.JC) GOTO 410
  IF (KSPAN.EQ.JC) GOTO 800
  GOTO 100
450 AKP=AKM+BJM
  AKM=AKM-BJM
  BKP=BKM-AJM
  BKM=BKM+AJM
  IF (S1.NE.0.0) GOTO 430
460 A(K1)=AKP
  B(K1)=BKP
  A(K2)=AJP
  B(K2)=BJP
  A(K3)=AKM
  B(K3)=BKM
  KK=K3+KSPAN
  IF (KK.LE.NT) GOTO 420
  GOTO 440
  !
  !*****TRANSFORM FOR FACTOR OF 5 (OPTIONAL CODE)
510 C2=C72**2-S72**2
  S2=2.0*C72*S72
520 K1=KK+KSPAN
  K2=K1+KSPAN
  K3=K2+KSPAN
  K4=K3+KSPAN
  AKP=A(K1)+A(K4)
  AKM=A(K1)-A(K4)
  BKP=B(K1)+B(K4)
  BKM=B(K1)-B(K4)
  AJP=A(K2)+A(K3)
  AJM=A(K2)-A(K3)
  BJP=B(K2)+B(K3)
  BJM=B(K2)-B(K3)
  AA=A(KK)
  BB=B(KK)
  A(KK)=AA+AKP+AJP
  B(KK)=BB+BKP+BJP
  AK=AKP*C72+AJP*C2+AA
  BK=BKP*C72+BJP*C2+BB
  AJ=AKM*S72+AJM*S2
  BJ=BKM*S72+BJM*S2
  A(K1)=AK-BJ
  A(K4)=AK+BJ
  B(K1)=BK+AJ
  B(K4)=BK-AJ
  AK=AKP*C2+AJP*C72+AA
  BK=BKP*C2+BJP*C72+BB
  AJ=AKM*S2-AJM*S72
  BJ=BKM*S2-BJM*S72
  A(K2)=AK-BJ
  A(K3)=AK+BJ
  B(K2)=BK+AJ
  B(K3)=BK-AJ
  KK=K4+KSPAN
  IF (KK.LT.NN) GOTO 520
  KK=KK-NN
  IF (KK.LE.KSPAN) GOTO 520
  GOTO 700
  !
  !*****TRANSFORM FOR ODD FACTORS
600 K=NFAC(I)
  KSPNN=KSPAN
  KSPAN=KSPAN/K
  IF (K.EQ.3) GOTO 320
  IF (K.EQ.5) GOTO 510
  IF (K.EQ.JF) GOTO 640
  JF=K
  S1=RAD/K
  C1= COS(S1)
  S1= SIN(S1)
  IF (JF.GT.MAXF) GOTO 998
  CK(JF)=1.0
  SK(JF)=0.0
  J=1
630 CK(J)=CK(K)*C1+SK(K)*S1
  SK(J)=CK(K)*S1-SK(K)*C1
  K=K-1
  CK(K)=CK(J)
  SK(K)=-SK(J)
  J=J+1
  IF (J.LT.K) GOTO 630
640 K1=KK
  K2=KK+KSPNN
  AA=A(KK)
  BB=B(KK)
  AK=AA
  BK=BB
  J=1
  K1=K1+KSPAN
650 K2=K2-KSPAN
  J=J+1
  AT(J)=A(K1)+A(K2)
  AK=AT(J)+AK
  BT(J)=B(K1)+B(K2)
  BK=BT(J)+BK
  J=J+1
  AT(J)=A(K1)-A(K2)
  BT(J)=B(K1)-B(K2)
  K1=K1+KSPAN
  IF (K1.LT.K2) GOTO 650
  A(KK)=AK
  B(KK)=BK
  K1=KK
  K2=KK+KSPNN
  J=1
660 K1=K1+KSPAN
  K2=K2-KSPAN
  JJ=J
  AK=AA
  BK=BB
  AJ=0.0
  BJ=0.0
  K=1
670 K=K+1
  AK=AT(K)*CK(JJ)+AK
  BK=BT(K)*CK(JJ)+BK
  K=K+1
  AJ=AT(K)*SK(JJ)+AJ
  BJ=BT(K)*SK(JJ)+BJ
  JJ=JJ+J
  IF (JJ.GT.JF) JJ=JJ-JF
  IF (K.LT.JF) GOTO 670
  K=JF-J
  A(K1)=AK-BJ
  B(K1)=BK+AJ
  A(K2)=AK+BJ
  B(K2)=BK-AJ
  J=J+1
  IF (J.LT.K) GOTO 660
  KK=KK+KSPNN
  IF (KK.LE.NN) GOTO 640
  KK=KK-NN
  IF (KK.LE.KSPAN) GOTO 640
  !
  !*****MULTIPLY BY ROTATION FACTOR (EXCEPT FOR FACTORS OF 2 AND 4)
700 IF (I.EQ.M) GOTO 800
  KK=JC+1
710 C2=1.0-CD
  S1=SD
720 C1=C2
  S2=S1
  KK=KK+KSPAN
730 AK=A(KK)
  A(KK)=C2*AK-S2*B(KK)
  B(KK)=S2*AK+C2*B(KK)
  KK=KK+KSPNN
  IF (KK.LE.NT) GOTO 730
  AK=S1*S2
  S2=S1*C2+C1*S2
  C2=C1*C2-AK
  KK=KK-NT+KSPAN
  IF (KK.LE.KSPNN) GOTO 730
  C2=C1-(CD*C1+SD*S1)
  S1=S1+(SD*C1-CD*S1)
  !
  !*****THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION ERRORS.
  !*****IF ROUNDED ARITHMETIC IS USED, THEY MAY BE DELETED
  C1=0.50/(C2**2+S1**2)+0.50
  S1=C1*S1
  C2=C1*C2
  KK=KK-KSPNN+JC
  IF (KK.LE.KSPAN) GOTO 720
  KK=KK-KSPAN+JC+INC
  IF (KK.LE.JC+JC) GOTO 710
  GOTO 100
  !
  !*****PERMUTE THE RESULTS TO NORMAL ORDER, IN TWO STEPS
  !*****PERMUTATION FOR SQUARE FACTORS OF N
800 NP(1)=KS
  IF (KT.EQ.0) GOTO 890
  K=KT+KT+1
  IF (M.LT.K) K=K-1
  J=1
  NP(K+1)=JC
810 NP(J+1)=NP(J)/NFAC(J)
  NP(K)=NP(K+1)*NFAC(J)
  J=J+1
  K=K-1
  IF (J.LT.K) GOTO 810
  K3=NP(K+1)
  KSPAN=NP(2)
  KK=JC+1
  K2=KSPAN+1
  J=1
  IF (N.NE.NTOT) GOTO 850
  !
  !*****PERMUTATION FOR SINGLE-VARIATE TRANSFORM (OPTIONAL CODE)
820 AK=A(KK)
  A(KK)=A(K2)
  A(K2)=AK
  BK=B(KK)
  B(KK)=B(K2)
  B(K2)=BK
  KK=KK+INC
  K2=KSPAN+K2
  IF (K2.LT.KS) GOTO 820
830 K2=K2-NP(J)
  J=J+1
  K2=NP(J+1)+K2
  IF (K2.GT.NP(J)) GOTO 830
  J=1
840 IF (KK.LT.K2) GOTO 820
  KK=KK+INC
  K2=KSPAN+K2
  IF (K2.LT.KS) GOTO 840
  IF (KK.LT.KS) GOTO 830
  JC=K3
  GOTO 890
  !
  !*****PERMUTATION FOR MULTI-VARIATE TRANSFORM
850 K=KK+JC
860 AK=A(KK)
  A(KK)=A(K2)
  A(K2)=AK
  BK=B(KK)
  B(KK)=B(K2)
  B(K2)=BK
  KK=KK+INC
  K2=K2+INC
  IF (KK.LT.K) GOTO 860
  KK=KK+KS-JC
  K2=K2+KS-JC
  IF (KK.LT.NT) GOTO 850
  K2=K2-NT+KSPAN
  KK=KK-NT+JC
  IF (K2.LT.KS) GOTO 850
870 K2=K2-NP(J)
  J=J+1
  K2=NP(J+1)+K2
  IF (K2.GT.NP(J)) GOTO 870
  J=1
880 IF (KK.LT.K2) GOTO 850
  KK=KK+JC
  K2=KSPAN+K2
  IF (K2.LT.KS) GOTO 880
  IF (KK.LT.KS) GOTO 870
  JC=K3
890 IF (2*KT+1.GE.M) RETURN
  KSPNN=NP(KT+1)
  !
  !*****PERMUTATION FOR SQUARE-FREE FACTORS OF N
  J=M-KT
  NFAC(J+1)=1
900 NFAC(J)=NFAC(J)*NFAC(J+1)
  J=J-1
  IF (J.NE.KT) GOTO 900
  KT=KT+1
  NN=NFAC(KT)-1
  IF (NN.GT.MAXP) GOTO 998
  JJ=0
  J=0
  GOTO 906
902 JJ=JJ-K2
  K2=KK
  K=K+1
  KK=NFAC(K)
904 JJ=KK+JJ
  IF (JJ.GE.K2) GOTO 902
  NP(J)=JJ
906 K2=NFAC(KT)
  K=KT+1
  KK=NFAC(K)
  J=J+1
  IF (J.LE.NN) GOTO 904
  !
  !*****DETERMINE THE PERMUTATION CYCLES OF LENGTH GREATER THAN 1
  J=0
  GOTO 914
910 K=KK
  KK=NP(K)
  NP(K)=-KK
  IF (KK.NE.J) GOTO 910
  K3=KK
914 J=J+1
  KK=NP(J)
  IF (KK.LT.0) GOTO 914
  IF (KK.NE.J) GOTO 910
  NP(J)=-J
  IF (J.NE.NN) GOTO 914
  MAXF=INC*MAXF
  !
  !*****REORDER A AND B, FOLLOWING THE PERMUTATION CYCLES
  GOTO 950
924 J=J-1
  IF (NP(J).LT.0) GOTO 924
  JJ=JC
926 KSPAN=JJ
  IF (JJ.GT.MAXF) KSPAN=MAXF
  JJ=JJ-KSPAN
  K=NP(J)
  KK=JC*K+II+JJ
  K1=KK+KSPAN
  K2=0
928 K2=K2+1
  AT(K2)=A(K1)
  BT(K2)=B(K1)
  K1=K1-INC
  IF (K1.NE.KK) GOTO 928
932 K1=KK+KSPAN
  K2=K1-JC*(K+NP(K))
  K=-NP(K)
936 A(K1)=A(K2)
  B(K1)=B(K2)
  K1=K1-INC
  K2=K2-INC
  IF (K1.NE.KK) GOTO 936
  KK=K2
  IF (K.NE.J) GOTO 932
  K1=KK+KSPAN
  K2=0
940 K2=K2+1
  A(K1)=AT(K2)
  B(K1)=BT(K2)
  K1=K1-INC
  IF (K1.NE.KK) GOTO 940
  IF (JJ.NE.0) GOTO 926
  IF (J.NE.1) GOTO 924
950 J=K3+1
  NT=NT-KSPNN
  II=NT-INC+1
  IF (NT.GE.0) GOTO 924
  RETURN
  !
  !*****ERROR FINISH, INSUFFICIENT ARRAY STORAGE
998 ISN=0
  CALL WRNDIE(-4,'<FFT>', &
       'Array bounds exceeded within subroutine')
  !
  return
end SUBROUTINE correl_FFT


